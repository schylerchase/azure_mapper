<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'self'">
<title>Azure Network Topology Map</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600&display=swap');
  :root {
    --bg-primary:#0a0e17;--bg-secondary:#111827;--bg-tertiary:#1a2236;
    --bg-input:#0d1220;--bg-card:rgba(17,24,39,.92);--border:#1e2d4a;--border-focus:#3b82f6;
    --text-primary:#e2e8f0;--text-secondary:#94a3b8;--text-muted:#64748b;
    --accent-blue:#3b82f6;--accent-cyan:#06b6d4;--accent-green:#10b981;
    --accent-purple:#8b5cf6;--accent-orange:#f59e0b;--accent-red:#ef4444;
    --accent-pink:#ec4899;
    --vnet-stroke:#3b82f6;--subnet-public:#06b6d4;--subnet-private:#8b5cf6;
    --nsg-color:#10b981;--nat-color:#f59e0b;--fw-color:#ec4899;
    --bastion-color:#ef4444;--pe-color:#a78bfa;--peer-color:#fb923c;
    --appgw-color:#38bdf8;--vpn-color:#f97316;--lb-color:#60a5fa;
    --txt-scale:1;--dp-txt-scale:1;
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{font-family:'IBM Plex Sans',sans-serif;background:var(--bg-primary);color:var(--text-primary);height:100vh;overflow:hidden;display:flex}
  .sidebar{width:360px;min-width:360px;background:var(--bg-secondary);border-right:1px solid var(--border);display:flex;flex-direction:column;height:100vh;z-index:10;transition:width .2s,min-width .2s}
  .sidebar.collapsed{width:0;min-width:0;overflow:hidden;border-right:none}
  .sidebar-toggle{position:absolute;top:8px;left:360px;z-index:11;width:24px;height:24px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:4px;color:var(--text-secondary);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:left .2s,background .15s;line-height:1}
  .sidebar-toggle:hover{background:var(--border);color:var(--text-primary)}
  .sidebar.collapsed~.sidebar-toggle{left:4px}
  .sidebar-header{padding:14px 16px;border-bottom:1px solid var(--border);background:var(--bg-tertiary)}
  .sidebar-header h1{font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600;letter-spacing:1.5px;text-transform:uppercase;color:var(--accent-cyan);margin-bottom:3px}
  .sidebar-header p{font-size:11px;color:var(--text-muted);font-family:'IBM Plex Mono',monospace}
  .global-txt-ctrl{display:flex;align-items:center;gap:6px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border)}
  .gtc-label{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--text-muted);letter-spacing:.5px;text-transform:uppercase}
  .gtc-btn{width:26px;height:26px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:4px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
  .gtc-btn:hover{background:var(--border);color:var(--text-primary)}
  .gtc-val{font-family:'IBM Plex Mono',monospace;font-size:10px;color:var(--accent-cyan);min-width:36px;text-align:center}
  .sidebar-body{flex:1;overflow-y:auto;padding:0}
  .sidebar-body::-webkit-scrollbar{width:6px}
  .sidebar-body::-webkit-scrollbar-track{background:transparent}
  .sidebar-body::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
  .sec-hdr{display:flex;align-items:center;justify-content:space-between;padding:7px 14px;background:var(--bg-tertiary);border-bottom:1px solid var(--border);cursor:pointer;user-select:none}
  .sec-hdr:hover{background:rgba(30,45,74,.5)}
  .sec-hdr span{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:600;color:var(--text-secondary);text-transform:uppercase;letter-spacing:1px}
  .sec-hdr .arr{color:var(--text-muted);font-size:10px;transition:transform .2s}
  .sec-hdr.collapsed .arr{transform:rotate(-90deg)}
  .sec-body{padding:6px 10px;border-bottom:1px solid var(--border)}
  .sec-body.hidden{display:none}
  .ig{margin-bottom:5px}
  .ig-lbl{display:flex;align-items:center;justify-content:space-between;margin-bottom:2px;padding:0 2px}
  .ig-lbl span{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:500;color:var(--text-secondary);letter-spacing:.4px}
  .ig-lbl code{font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--text-muted);background:var(--bg-primary);padding:1px 4px;border-radius:3px}
  .ji{width:100%;height:48px;background:var(--bg-input);border:1px solid var(--border);border-radius:5px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));padding:5px 7px;resize:vertical;transition:border-color .2s;line-height:1.4}
  .ji:focus{outline:none;border-color:var(--border-focus);box-shadow:0 0 0 2px rgba(59,130,246,.15)}
  .ji.valid{border-color:var(--accent-green)}.ji.invalid{border-color:var(--accent-red)}
  .sidebar-actions{padding:10px 12px;border-top:1px solid var(--border);display:flex;gap:8px}
  .btn{flex:1;padding:9px 14px;border:none;border-radius:6px;font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale));font-weight:600;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .2s}
  .btn-primary{background:var(--accent-blue);color:#fff}.btn-primary:hover{background:#2563eb}
  .btn-secondary{background:var(--bg-tertiary);color:var(--text-secondary);border:1px solid var(--border)}.btn-secondary:hover{background:var(--border);color:var(--text-primary)}
  .btn-demo{background:transparent;color:var(--accent-cyan);border:1px solid var(--accent-cyan);opacity:.7}.btn-demo:hover{opacity:1;background:rgba(6,182,212,.08)}
  .main{flex:1;position:relative;background:var(--bg-primary);overflow:hidden}
  .main svg{width:100%;height:100%;display:block;touch-action:none}
  .grid-bg{position:absolute;inset:0;background-image:radial-gradient(circle at 1px 1px,rgba(50,70,100,.35) 1px,transparent 0);background-size:24px 24px;pointer-events:none}
  .empty-state{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none}
  .empty-state .icon{width:80px;height:80px;border:2px dashed var(--border);border-radius:16px;display:flex;align-items:center;justify-content:center;margin-bottom:20px;color:var(--text-muted);font-size:32px}
  .empty-state h2{font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:500;color:var(--text-muted);margin-bottom:8px}
  .empty-state p{font-size:12px;color:var(--text-muted);opacity:.6}
  .stats-bar{position:absolute;top:12px;left:0;right:0;display:none;gap:5px;flex-wrap:wrap;z-index:5;justify-content:center;padding:0 440px 0 40px;transition:padding-right .2s}
  .main:has(.detail-panel.open) .stats-bar{padding-right:860px}
  .main:has(.detail-panel.open) .export-bar{right:432px}
  .stat-chip{font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale));font-weight:500;padding:5px 10px;border-radius:4px;background:var(--bg-card);border:1px solid var(--border);backdrop-filter:blur(8px);color:var(--text-secondary);cursor:pointer;transition:border-color .15s,background .15s}
  .stat-chip:hover{border-color:var(--accent-blue);background:rgba(59,130,246,.12)}
  .stat-chip b{color:var(--text-primary);font-weight:600;margin-right:3px}
  .legend{position:absolute;bottom:12px;left:12px;display:none;flex-direction:column;gap:3px;background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:10px 14px;backdrop-filter:blur(8px);z-index:5;transition:all .2s}
  .legend-title{font-family:'IBM Plex Mono',monospace;font-size:9px;font-weight:600;letter-spacing:1px;text-transform:uppercase;color:var(--text-muted);margin-bottom:3px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;gap:8px;user-select:none}
  .legend-title .lg-arr{font-size:7px;transition:transform .2s}
  .legend.collapsed .legend-title .lg-arr{transform:rotate(-90deg)}
  .legend.collapsed .legend-item,.legend.collapsed .legend-hint{display:none}
  .legend-item{display:flex;align-items:center;gap:7px;font-size:10px;color:var(--text-secondary)}
  .legend-swatch{width:10px;height:10px;border-radius:2px;flex-shrink:0}
  .legend-hint{font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--text-muted);margin-top:4px;padding-top:4px;border-top:1px solid var(--border);opacity:.7}
  .zoom-controls{position:absolute;bottom:12px;right:12px;display:flex;flex-direction:column;gap:4px;z-index:5}
  .zoom-btn{width:32px;height:32px;background:var(--bg-card);border:1px solid var(--border);border-radius:6px;color:var(--text-secondary);font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-family:'IBM Plex Mono',monospace;transition:all .15s;backdrop-filter:blur(8px)}
  .zoom-btn:hover{background:var(--bg-tertiary);color:var(--text-primary)}
  .zoom-btn.wide{width:auto;padding:0 10px;font-size:9px;letter-spacing:.5px}
  .tooltip{position:absolute;display:none;background:rgba(10,14,23,.96);border:1px solid var(--border);border-radius:8px;padding:12px 16px;max-width:420px;min-width:200px;z-index:100;pointer-events:none;backdrop-filter:blur(12px);box-shadow:0 8px 32px rgba(0,0,0,.5)}
  .tt-title{font-family:'IBM Plex Mono',monospace;font-size:12px;font-weight:600;color:var(--accent-cyan);margin-bottom:5px;word-break:break-all}
  .tt-sub{font-family:'IBM Plex Mono',monospace;font-size:10px;color:var(--text-muted);margin-bottom:7px;word-break:break-all}
  .tt-sec{margin-bottom:5px}
  .tt-sh{font-family:'IBM Plex Mono',monospace;font-size:9px;font-weight:600;text-transform:uppercase;letter-spacing:.8px;color:var(--text-muted);margin-bottom:2px}
  .tt-r{font-family:'IBM Plex Mono',monospace;font-size:11px;color:var(--text-secondary);line-height:1.6;padding-left:8px}
  .tt-r .a{color:var(--accent-green)}.tt-r .d{color:var(--accent-red)}.tt-r .p{color:var(--accent-orange)}.tt-r .i{color:var(--accent-cyan)}
  .vnet-group rect{stroke-dasharray:6 3;rx:8;ry:8}
  .vnet-label{font-family:'IBM Plex Mono',monospace;font-size:calc(13px * var(--txt-scale));font-weight:600;fill:var(--vnet-stroke);text-transform:uppercase;letter-spacing:.5px}
  .vnet-cidr{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));fill:var(--text-muted)}
  .subnet-node rect{rx:5;ry:5;cursor:pointer}
  .subnet-label{font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale));font-weight:500;fill:#fff;pointer-events:none}
  .subnet-cidr{font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale));fill:rgba(255,255,255,.7);pointer-events:none}
  .subnet-badge{font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale));font-weight:600;pointer-events:none}
  .gw-node{cursor:pointer}
  .gw-label{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:600;pointer-events:none}
  .gw-id{font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale));fill:var(--text-muted);pointer-events:none;opacity:.6}
  .gw-name{font-family:'IBM Plex Mono',monospace;font-size:calc(8px * var(--txt-scale));fill:var(--text-secondary);pointer-events:none}
  .route-line{fill:none;stroke-width:1.5;opacity:.35;pointer-events:none}
  .peering-line{fill:none;stroke-width:2;opacity:.6;stroke-dasharray:9 9;animation:dashFlow 1.2s linear infinite}
  .peering-port{cursor:pointer}
  .peering-port circle{transition:r .15s,fill-opacity .15s}
  .peering-port:hover circle{r:8;fill-opacity:.25}
  @keyframes dashFlow{from{stroke-dashoffset:0}to{stroke-dashoffset:-18}}
  .animated{animation:dashFlow 1s linear infinite}
  .export-bar{position:absolute;top:12px;right:12px;display:none;gap:4px;z-index:6;flex-direction:column}
  .export-btn{padding:8px 12px;background:var(--bg-card);border:1px solid var(--border);border-radius:5px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale));font-weight:500;cursor:pointer;backdrop-filter:blur(8px);transition:all .15s;text-align:left;white-space:nowrap}
  .export-btn:hover{background:var(--bg-tertiary);color:var(--text-primary);border-color:var(--accent-blue)}
  .export-btn span{color:var(--text-muted);font-size:7px;display:block;margin-top:1px}
  .export-bar.collapsed .export-btn{display:none}
  .export-bar .eb-toggle{padding:4px 10px;background:var(--bg-card);border:1px solid var(--border);border-radius:5px;color:var(--text-muted);font-family:'IBM Plex Mono',monospace;font-size:11px;cursor:pointer;white-space:nowrap;transition:all .15s}
  .export-bar .eb-toggle:hover{color:var(--text-primary);border-color:var(--accent-blue)}
  .upload-row{padding:8px 12px;border-bottom:1px solid var(--border);display:flex;gap:6px}
  .btn-upload{flex:1;padding:9px 14px;border:none;border-radius:6px;font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:600;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .2s;background:var(--accent-green);color:#fff;text-align:center}
  .btn-upload:hover{background:#059669}
  .upload-status{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--accent-green);padding:4px 12px;display:none;border-bottom:1px solid var(--border)}
  .detail-panel{position:absolute;top:0;right:0;width:420px;height:100%;background:rgba(10,14,23,.97);border-left:1px solid var(--border);backdrop-filter:blur(16px);z-index:50;display:none;flex-direction:column;box-shadow:-4px 0 24px rgba(0,0,0,.4)}
  .detail-panel.open{display:flex}
  .dp-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:flex-start;gap:8px;flex-shrink:0}
  .dp-title{font-family:'IBM Plex Mono',monospace;font-size:calc(13px * var(--txt-scale) * var(--dp-txt-scale));font-weight:600;color:var(--accent-cyan);word-break:break-all;line-height:1.4}
  .dp-subtitle{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-muted);margin-top:4px;word-break:break-all;line-height:1.5}
  .dp-close{width:28px;height:28px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:5px;color:var(--text-muted);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .15s}
  .dp-close:hover{background:var(--border);color:var(--text-primary)}
  .dp-body{flex:1;overflow-y:auto;padding:0}
  .dp-body::-webkit-scrollbar{width:6px}
  .dp-body::-webkit-scrollbar-track{background:transparent}
  .dp-body::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
  .dp-section{border-bottom:1px solid var(--border)}
  .dp-sec-hdr{display:flex;align-items:center;justify-content:space-between;padding:9px 16px;cursor:pointer;user-select:none;transition:background .15s}
  .dp-sec-hdr:hover{background:rgba(30,45,74,.3)}
  .dp-sec-title{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));font-weight:600;color:var(--text-secondary);text-transform:uppercase;letter-spacing:.8px}
  .dp-sec-count{font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-muted);background:var(--bg-tertiary);padding:2px 6px;border-radius:3px}
  .dp-sec-arr{color:var(--text-muted);font-size:10px;transition:transform .2s;margin-left:6px}
  .dp-sec-hdr.collapsed .dp-sec-arr{transform:rotate(-90deg)}
  .dp-sec-body{padding:4px 16px 10px}
  .dp-sec-body.hidden{display:none}
  .dp-row{font-family:'IBM Plex Mono',monospace;font-size:calc(11px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-secondary);line-height:1.7;padding:3px 0;border-bottom:1px solid rgba(30,45,74,.3)}
  .dp-row:last-child{border-bottom:none}
  .dp-row .lbl{color:var(--text-muted);font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));display:block}
  .dp-row .val{color:var(--text-primary)}
  .dp-row .a{color:var(--accent-green)}.dp-row .d{color:var(--accent-red)}.dp-row .p{color:var(--accent-orange)}.dp-row .i{color:var(--accent-cyan)}.dp-row .s{color:var(--accent-purple)}
  .dp-kv{display:flex;justify-content:space-between;align-items:baseline;gap:8px;padding:3px 0}
  .dp-kv .k{color:var(--text-muted);font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));flex-shrink:0}
  .dp-kv .v{color:var(--text-primary);font-size:calc(11px * var(--txt-scale) * var(--dp-txt-scale));text-align:right;word-break:break-all;cursor:pointer}
  .dp-kv .v:hover{color:var(--accent-cyan)}
  .dp-badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px;font-weight:600;margin-left:4px}
  .dp-badge.running{background:rgba(16,185,129,.15);color:var(--accent-green)}
  .dp-badge.stopped{background:rgba(239,68,68,.15);color:var(--accent-red)}
  .dp-badge.pub{background:rgba(6,182,212,.15);color:var(--accent-cyan)}
  .dp-badge.prv{background:rgba(139,92,246,.15);color:var(--accent-purple)}
  .dp-empty{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale) * var(--dp-txt-scale));color:var(--text-muted);padding:6px 0;font-style:italic}
  .dp-toolbar{display:flex;align-items:center;gap:6px;padding:6px 16px;border-bottom:1px solid var(--border);flex-shrink:0}
  .dp-size-btn{width:24px;height:24px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:4px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:12px;font-weight:600;cursor:pointer;display:flex;align-items:center;justify-content:center}
  .dp-size-btn:hover{background:var(--border);color:var(--text-primary)}
  .dp-size-label{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--text-muted)}
  .dp-nav-btn{display:inline-block;font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--accent-blue);cursor:pointer;margin-left:6px;padding:1px 5px;border:1px solid rgba(59,130,246,.3);border-radius:3px;background:rgba(59,130,246,.08);transition:background .15s}
  .dp-nav-btn:hover{background:rgba(59,130,246,.2)}
  .fw-visual{padding:8px 0}
  .fw-rule-bar{display:flex;align-items:center;gap:6px;margin:3px 0;font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale) * var(--dp-txt-scale))}
  .fw-arrow{width:40px;height:20px;position:relative;flex-shrink:0}
  .fw-arrow-line{position:absolute;top:9px;left:0;right:8px;height:2px}
  .fw-arrow-head{position:absolute;right:0;top:4px;width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent}
  .fw-arrow.allow .fw-arrow-line{background:var(--accent-green)}.fw-arrow.allow .fw-arrow-head{border-left:8px solid var(--accent-green)}
  .fw-arrow.deny .fw-arrow-line{background:var(--accent-red)}.fw-arrow.deny .fw-arrow-head{border-left:8px solid var(--accent-red)}
  .fw-port{padding:1px 5px;border-radius:3px;font-weight:600;font-size:calc(9px * var(--txt-scale) * var(--dp-txt-scale))}
  .fw-port.allow{background:rgba(16,185,129,.12);color:var(--accent-green);border:1px solid rgba(16,185,129,.25)}
  .fw-port.deny{background:rgba(239,68,68,.12);color:var(--accent-red);border:1px solid rgba(239,68,68,.25)}
  .fw-src{color:var(--text-muted);font-size:8px;margin-left:auto;max-width:120px;text-align:right;word-break:break-all}
  .fw-proto{color:var(--accent-orange);font-size:8px;min-width:28px;flex-shrink:0;text-align:center}
  .copyable{cursor:pointer;position:relative;border-bottom:1px dashed rgba(100,116,139,.4)}
  .copyable:hover{color:var(--accent-cyan);border-bottom-color:var(--accent-cyan)}
  .copy-toast{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(16,185,129,.9);color:#fff;font-family:'IBM Plex Mono',monospace;font-size:10px;padding:6px 16px;border-radius:5px;z-index:200;pointer-events:none;opacity:0;transition:opacity .2s}
  .copy-toast.show{opacity:1}
  .update-banner{position:fixed;top:0;left:0;right:0;z-index:300;display:none;align-items:center;justify-content:center;gap:12px;padding:8px 16px;background:linear-gradient(135deg,rgba(59,130,246,.95),rgba(139,92,246,.95));color:#fff;font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:500;backdrop-filter:blur(8px);box-shadow:0 2px 12px rgba(0,0,0,.3)}
  .update-banner.visible{display:flex}
  .update-banner a{color:#fff;text-decoration:underline;font-weight:600;cursor:pointer}
  .update-banner a:hover{opacity:.85}
  .update-banner .ub-close{background:none;border:1px solid rgba(255,255,255,.3);border-radius:4px;color:#fff;font-size:12px;cursor:pointer;padding:2px 8px;font-family:inherit;transition:background .15s}
  .update-banner .ub-close:hover{background:rgba(255,255,255,.15)}
  @keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
  .loading-overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(10,14,23,.85);z-index:60;flex-direction:column;gap:12px}
  .region-label{font-family:'IBM Plex Mono',monospace;font-size:calc(10px * var(--txt-scale));font-weight:600;fill:var(--text-muted);letter-spacing:1px;text-transform:uppercase;opacity:.6}
  .hl-locked-indicator{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(17,24,39,.95);border:1px solid var(--accent-cyan);border-radius:6px;padding:5px 14px;font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--accent-cyan);display:none;z-index:10;cursor:pointer;backdrop-filter:blur(8px)}
  .hl-locked-indicator:hover{background:rgba(17,24,39,1);border-color:#fff}
  .sev-badge{font-size:calc(10px * var(--txt-scale,1) * var(--dp-txt-scale,1));font-weight:700;padding:2px 7px;border-radius:3px;text-transform:uppercase;letter-spacing:.5px;flex-shrink:0}
  .sev-CRITICAL{background:rgba(220,38,38,.2);color:#dc2626}
  .sev-HIGH{background:rgba(239,68,68,.15);color:#ef4444}
  .sev-MEDIUM{background:rgba(245,158,11,.15);color:#f59e0b}
  .sev-LOW{background:rgba(59,130,246,.15);color:#3b82f6}
  .resource-icon{font-family:'IBM Plex Mono',monospace;font-size:calc(9px * var(--txt-scale));pointer-events:none}

  /* ============================================================
     MOBILE-FRIENDLY OVERRIDES
     ============================================================ */

  /* --- TABLET: (max-width 1024px) --- */
  @media (max-width:1024px){
    .sidebar{width:300px;min-width:300px}
    .sidebar-toggle{left:300px}
    .sidebar.collapsed~.sidebar-toggle{left:4px}
    .detail-panel{width:360px}
    .stats-bar{padding:0 380px 0 32px}
    .main:has(.detail-panel.open) .stats-bar{padding-right:740px}
    .main:has(.detail-panel.open) .export-bar{right:372px}
  }

  /* --- PHONE / SMALL TABLET: (max-width 768px) --- */
  @media (max-width:768px){
    body{flex-direction:column}

    /* Sidebar: full-width overlay. Use svh so it ends above Safari's toolbar. */
    .sidebar{position:fixed;top:0;left:0;width:100vw;min-width:100vw;height:100vh;height:100svh;z-index:100;transform:translateX(-100%);transition:transform .25s ease;display:flex;flex-direction:column;overflow:hidden}
    .sidebar:not(.collapsed){transform:translateX(0)}
    .sidebar.collapsed{width:100vw;min-width:100vw;overflow:hidden;transform:translateX(-100%)}
    /* Sidebar body: must scroll, flex-shrink so actions stay pinned at bottom */
    .sidebar-body{flex:1;overflow-y:auto;min-height:0;-webkit-overflow-scrolling:touch}
    /* Upload row: compact on mobile */
    .upload-row{padding:6px 10px}
    .upload-status{padding:0 10px}

    /* Sidebar toggle: compact hamburger top-left */
    .sidebar-toggle{position:fixed;top:8px;left:8px;z-index:101;width:34px;height:34px;font-size:16px;border-radius:6px;background:rgba(17,24,39,.95);backdrop-filter:blur(8px);border:1px solid var(--border)}
    .sidebar.collapsed~.sidebar-toggle{left:8px}
    .sidebar:not(.collapsed)~.sidebar-toggle{left:calc(100vw - 42px);z-index:101}

    /* Sidebar header: compact on mobile */
    .sidebar-header{padding:10px 14px}
    .sidebar-header h1{font-size:13px;margin-bottom:1px}
    .sidebar-header p{font-size:9px}
    .global-txt-ctrl{margin-top:4px}

    /* Sidebar actions: pinned at bottom (sidebar is 100svh, so already above toolbar) */
    .sidebar-actions{padding:10px 12px 16px;gap:8px;flex-shrink:0;border-top:1px solid var(--border);background:var(--bg-secondary)}
    .btn{padding:10px 12px;font-size:calc(11px * var(--txt-scale))}
    .btn-upload{padding:10px 12px;font-size:11px}

    /* Sidebar sections: compact inputs, all collapsed by default (via JS) */
    .ji{height:44px;font-size:calc(10px * var(--txt-scale))}
    .ig{padding:4px 10px}
    .ig-lbl{margin-bottom:2px}
    .ig-lbl code{font-size:8px}
    .sec-hdr{padding:8px 12px}
    .sec-hdr span{font-size:calc(9px * var(--txt-scale))}

    /* Main fills viewport — use svh so bottom elements clear Safari toolbar */
    .main{width:100vw;height:100vh;height:100svh}

    /* Detail panel: full-width overlay from bottom — use svh to clear Safari toolbar */
    .detail-panel{width:100vw;height:70vh;height:70svh;top:auto;bottom:0;border-left:none;border-top:1px solid var(--border);border-radius:16px 16px 0 0}
    .dp-header{padding:16px;padding-left:56px}
    .dp-close{width:36px;height:36px;font-size:18px}
    .dp-sec-hdr{padding:12px 16px}

    /* Stats bar: hide on mobile */
    .stats-bar{display:none !important}

    /* Export bar: small toggle top-right */
    .export-bar{top:8px;right:8px}
    .main:has(.detail-panel.open) .export-bar{right:8px}
    .export-btn{padding:8px 12px;font-size:calc(11px * var(--txt-scale))}
    .eb-toggle{padding:5px 10px;font-size:9px}

    /* Hide layout selector row in export bar on mobile */
    .export-bar>div:has(#layoutMode){display:none}

    /* Zoom controls: above bottom toolbar */
    .zoom-controls{bottom:52px;right:10px;z-index:15}
    .zoom-btn{width:36px;height:36px;font-size:17px;border-radius:6px}

    /* Legend: above bottom toolbar */
    .legend{bottom:52px;left:10px;max-width:160px;font-size:8px;padding:6px 10px;z-index:15}
    .legend-item{font-size:8px;gap:5px}
    .legend-swatch{width:8px;height:8px}
    .legend .legend-hint{display:none}
    .legend-title{font-size:8px}

    /* Bottom toolbar: scrollable on mobile */
    #bottomToolbar{left:0 !important;right:0 !important;transform:none !important;overflow-x:auto;-webkit-overflow-scrolling:touch;padding:0 10px 6px !important;gap:5px !important;scrollbar-width:none}
    #bottomToolbar::-webkit-scrollbar{display:none}
    #bottomToolbar button{flex-shrink:0;font-size:10px;height:28px;padding:0 10px}

    /* Locked indicator */
    .hl-locked-indicator{font-size:8px;padding:4px 10px;bottom:70px}

    /* Tooltip: responsive width */
    .tooltip{max-width:85vw;min-width:160px}

    /* Empty state: responsive */
    .empty-state .icon{width:60px;height:60px;font-size:24px}
    .empty-state h2{font-size:13px}
    .empty-state p{font-size:11px}

    /* IaC modal: full screen */
    #scanModal>div{width:100vw;max-height:100vh;border-radius:0}
  }

  /* --- SMALL PHONE: iPhone SE, narrow Android (max-width 430px) --- */
  @media (max-width:430px){
    /* Export buttons: hide descriptions */
    .export-btn span{display:none}

    /* Zoom controls: even smaller */
    .zoom-controls{bottom:10px;right:8px}
    .zoom-btn{width:32px;height:32px;font-size:15px}

    .detail-panel{height:85vh;height:85svh}

    /* Legend: extra compact */
    .legend{padding:5px 8px;max-width:140px}
    .legend-swatch{width:7px;height:7px}

    /* Sidebar header */
    .sidebar-header h1{font-size:13px}
    .sidebar-header p{font-size:10px}
  }

  /* Mobile drag handle for bottom sheets */
  .dp-drag-handle{display:none;padding:8px 0 4px;cursor:grab;touch-action:none}
  .dp-drag-bar{width:36px;height:4px;background:var(--text-muted);border-radius:2px;margin:0 auto;opacity:.5}
  @media (max-width:768px){
    .dp-drag-handle{display:block}
  }

  /* --- TOUCH DEVICE ENHANCEMENTS --- */
  @media (hover:none) and (pointer:coarse){
    /* Larger tap targets for touch */
    .sidebar-toggle{width:40px;height:40px;font-size:20px}
    .zoom-btn{min-width:36px;min-height:36px}
    .dp-close{min-width:36px;min-height:36px}
    .gtc-btn{width:32px;height:32px;font-size:16px}
    .sec-hdr{padding:10px 14px}
    .dp-sec-hdr{padding:12px 16px;min-height:44px}
    .btn{min-height:44px}
    .btn-upload{min-height:44px}
    .export-btn{min-height:44px}

    /* Remove hover-only states on touch */
    .stat-chip:hover,.export-btn:hover,.zoom-btn:hover{background:initial}

    /* Smooth scrolling for touch */
    .sidebar-body,.dp-body{
      -webkit-overflow-scrolling:touch;scroll-behavior:smooth}

    /* Prevent text selection on interactive elements */
    .btn,.zoom-btn,.export-btn,.stat-chip,.sidebar-toggle,.dp-close,.gtc-btn{
      -webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;user-select:none}
  }

  /* --- LANDSCAPE PHONE --- */
  @media (max-width:768px) and (max-height:500px) and (orientation:landscape){
    .detail-panel{height:100vh;height:100svh;border-radius:0}
    .zoom-controls{bottom:8px;right:6px}
    .zoom-btn{width:30px;height:30px;font-size:14px}
    .legend{bottom:8px;left:6px;max-width:130px}
  }

  /* --- SAFE AREA INSETS for notched phones (iPhone X+) ---
       .main already uses height:100svh so bottom:0 = above Safari toolbar.
       env(safe-area-inset-bottom) only adds clearance for the home indicator. */
  @supports (padding: env(safe-area-inset-top)){
    @media (max-width:768px){
      .sidebar-header{padding-top:calc(14px + env(safe-area-inset-top))}
      .sidebar-toggle{top:calc(8px + env(safe-area-inset-top))}
      .export-bar{top:calc(8px + env(safe-area-inset-top))}
      #bottomToolbar{bottom:calc(12px + env(safe-area-inset-bottom)) !important}
      .zoom-controls{bottom:calc(52px + env(safe-area-inset-bottom))}
      .legend{bottom:calc(52px + env(safe-area-inset-bottom))}
      .detail-panel{padding-bottom:env(safe-area-inset-bottom)}
      .sidebar-actions{padding-bottom:calc(12px + env(safe-area-inset-bottom))}
      .hl-locked-indicator{bottom:calc(52px + env(safe-area-inset-bottom))}
    }
  }
</style>
</head>
<body>
<div class="update-banner" id="updateBanner">
  <span id="updateMsg">A new version is available</span>
  <a id="updateLink" href="#" target="_blank">Download</a>
  <button class="ub-close" onclick="document.getElementById('updateBanner').classList.remove('visible')">Dismiss</button>
</div>
<div class="sidebar">
  <div class="sidebar-header">
    <h1>Azure Network Map <span style="font-size:8px;color:var(--text-muted);font-weight:400">v1.1</span></h1>
    <p>Paste Azure CLI JSON exports or upload folder</p>
    <div class="global-txt-ctrl">
      <span class="gtc-label">Text Size</span>
      <button class="gtc-btn" id="gTxtDown">-</button>
      <span class="gtc-val" id="gTxtVal">100%</span>
      <button class="gtc-btn" id="gTxtUp">+</button>
    </div>
  </div>
  <div class="upload-row">
    <button class="btn-upload" id="uploadBtn">Upload JSON Files</button>
    <button class="btn-upload" id="importFolderBtn" style="display:none;background:linear-gradient(135deg,#f59e0b,#d97706);margin-left:4px">Import Folder</button>
    <input type="file" id="fileInput" multiple accept=".json" style="display:none" />
  </div>
  <div class="upload-status" id="uploadStatus"></div>
  <div class="sidebar-body" id="sidebarBody"></div>
  <div class="sidebar-actions">
    <button class="btn btn-demo" id="loadDemo">Demo</button>
    <button class="btn btn-secondary" id="clearBtn">Clear</button>
    <button class="btn btn-primary" id="renderBtn">Render Map</button>
  </div>
</div>
<button class="sidebar-toggle" id="sidebarToggle" title="Toggle sidebar">&#x25C0;</button>
<div class="main">
  <div class="grid-bg"></div>
  <div class="loading-overlay" id="loadingOverlay"><div style="width:40px;height:40px;border:3px solid var(--border);border-top-color:var(--accent-cyan);border-radius:50%;animation:spin 1s linear infinite"></div><div style="font-family:'IBM Plex Mono',monospace;font-size:11px;color:var(--text-muted)">Rendering map...</div></div>
  <div class="copy-toast" id="copyToast">Copied!</div>
  <div class="empty-state" id="emptyState"><div class="icon">&#9700;</div><h2 id="emptyTitle">No data loaded</h2><p id="emptyDesc">Paste Azure CLI JSON exports and click Render Map</p></div>
  <svg id="mapSvg"></svg>
  <div class="stats-bar" id="statsBar"></div>
  <div class="legend" id="legend">
    <div class="legend-title" onclick="this.parentElement.classList.toggle('collapsed')">Legend <span class="lg-arr">&#9660;</span></div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--subnet-public)"></div>Public Subnet (has Public IP / NAT)</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--subnet-private)"></div>Private Subnet</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--nsg-color)"></div>NSG</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--nat-color)"></div>NAT Gateway</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--bastion-color)"></div>Bastion</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--fw-color)"></div>Azure Firewall</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--pe-color)"></div>Private Endpoint</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--peer-color)"></div>VNet Peering / VPN</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--appgw-color)"></div>App Gateway</div>
    <div class="legend-item"><div class="legend-swatch" style="background:var(--lb-color)"></div>Load Balancer</div>
    <div class="legend-item"><div class="legend-swatch" style="border:1.5px dashed var(--vnet-stroke);background:transparent"></div>VNet Boundary</div>
    <div class="legend-hint">Click subnets for details | Hover to preview</div>
  </div>
  <div class="zoom-controls">
    <button class="zoom-btn" id="zoomIn">+</button>
    <button class="zoom-btn" id="zoomOut">-</button>
    <button class="zoom-btn" id="zoomFit">~</button>
    <div id="zoomLevel" style="font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--text-muted);text-align:center;padding:2px 0;min-width:32px">100%</div>
  </div>
  <div class="export-bar collapsed" id="exportBar">
    <button class="eb-toggle" id="ebToggle">Export &#9654;</button>
    <div style="display:flex;align-items:center;gap:8px;margin-right:12px;padding-right:12px;border-right:1px solid var(--border)">
      <label style="font-family:'IBM Plex Mono',monospace;font-size:8px;color:var(--text-muted);text-transform:uppercase">Layout</label>
      <select id="layoutMode" style="background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:9px;padding:4px 6px;cursor:pointer">
        <option value="grid">Grid (columns)</option>
        <option value="landingzone">Landing Zone (hub-spoke)</option>
        <option value="executive">Executive Overview</option>
      </select>
    </div>
    <button class="export-btn" id="expPng">PNG Image<span>Auto-scaled to fit</span></button>
    <button class="export-btn" onclick="exportSVG()">SVG Image<span>Vector format</span></button>
    <button class="export-btn" onclick="openIaCModal('terraform')">Terraform<span>HCL export</span></button>
    <button class="export-btn" onclick="openIaCModal('arm')">ARM Template<span>JSON export</span></button>
    <button class="export-btn" onclick="openIaCModal('bicep')">Bicep<span>DSL export</span></button>
    <button class="export-btn" onclick="openSnapshotPanel()">Snapshots<span>Save / restore states</span></button>
  </div>
  <div id="bottomToolbar" style="position:absolute;bottom:12px;left:50%;transform:translateX(-50%);z-index:7;display:flex;gap:6px;align-items:center">
    <button id="saveProjectBtn" style="height:30px;border-radius:15px;background:var(--bg-card);border:1px solid var(--accent-green);color:var(--accent-green);font-family:'IBM Plex Mono',monospace;font-size:11px;cursor:pointer;display:flex;align-items:center;gap:5px;padding:0 14px;transition:all .15s" title="Save project (Ctrl+S)">Save</button>
    <button id="loadProjectBtn" style="height:30px;border-radius:15px;background:var(--bg-card);border:1px solid var(--accent-orange);color:var(--accent-orange);font-family:'IBM Plex Mono',monospace;font-size:11px;cursor:pointer;display:flex;align-items:center;gap:5px;padding:0 14px;transition:all .15s" title="Load project from file">Open</button>
    <div style="width:1px;height:18px;background:var(--border);opacity:.5"></div>
    <button id="searchBtn" style="height:30px;border-radius:15px;background:var(--bg-card);border:1px solid var(--border);color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:11px;cursor:pointer;display:flex;align-items:center;gap:5px;padding:0 14px;transition:all .15s" title="Search resources (/)">Search</button>
    <button id="flowBtn" style="height:30px;border-radius:15px;background:var(--bg-card);border:1px solid var(--accent-purple);color:var(--accent-purple);font-family:'IBM Plex Mono',monospace;font-size:11px;cursor:pointer;display:flex;align-items:center;gap:5px;padding:0 14px;transition:all .15s" title="Traffic Flow Tracer (Shift+T)" onclick="openFlowForm()">Flow</button>
    <button id="complianceBtn" style="height:30px;border-radius:15px;background:var(--bg-card);border:1px solid var(--accent-red);color:var(--accent-red);font-family:'IBM Plex Mono',monospace;font-size:11px;cursor:pointer;display:flex;align-items:center;gap:5px;padding:0 14px;transition:all .15s" title="Compliance Dashboard (Shift+C)" onclick="openComplianceDashboard()">Compliance</button>
    <button id="scanAzureBtn" style="display:none;height:30px;border-radius:15px;background:var(--bg-card);border:1px solid #f59e0b;color:#f59e0b;font-family:'IBM Plex Mono',monospace;font-size:11px;cursor:pointer;align-items:center;gap:5px;padding:0 14px;transition:all .15s;font-weight:600" title="Scan Azure subscription via CLI">Scan Azure</button>
  </div>
  <input type="file" id="loadProjectInput" accept=".azuremap,.json" style="display:none">
  <!-- Scan Azure Modal (Electron only) -->
  <div id="scanModal" style="display:none;position:fixed;inset:0;z-index:500;background:rgba(0,0,0,.7);align-items:center;justify-content:center">
    <div style="background:#111827;border:1px solid var(--border);border-radius:12px;padding:28px;width:420px;max-height:80vh;overflow:auto;font-family:'IBM Plex Mono',monospace">
      <h3 style="margin:0 0 16px;color:#f59e0b;font-size:14px">Scan Azure Subscription</h3>
      <div id="scanForm">
        <label style="font-size:11px;color:var(--text-secondary);display:block;margin-bottom:4px">Subscription (name or ID)</label>
        <input id="scanSubscription" style="width:100%;box-sizing:border-box;padding:6px 10px;background:#0b1120;border:1px solid var(--border);border-radius:6px;color:var(--text-primary);font-family:inherit;font-size:12px;margin-bottom:12px" placeholder="my-subscription">
        <label style="font-size:11px;color:var(--text-secondary);display:block;margin-bottom:4px">Resource Group (optional)</label>
        <input id="scanResourceGroup" style="width:100%;box-sizing:border-box;padding:6px 10px;background:#0b1120;border:1px solid var(--border);border-radius:6px;color:var(--text-primary);font-family:inherit;font-size:12px;margin-bottom:16px" placeholder="All resource groups">
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="scanCancel" style="padding:6px 16px;border-radius:6px;background:none;border:1px solid var(--border);color:var(--text-secondary);cursor:pointer;font-family:inherit;font-size:11px">Cancel</button>
          <button id="scanStart" style="padding:6px 16px;border-radius:6px;background:#f59e0b;border:none;color:#000;cursor:pointer;font-family:inherit;font-size:11px;font-weight:600">Start Scan</button>
        </div>
      </div>
      <div id="scanProgress" style="display:none">
        <pre id="scanLog" style="background:#0b1120;border:1px solid var(--border);border-radius:6px;padding:10px;font-size:10px;color:var(--text-secondary);max-height:300px;overflow:auto;white-space:pre-wrap;margin:0 0 12px"></pre>
      </div>
    </div>
  </div>
  <!-- Search Overlay -->
  <div id="searchOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;z-index:90">
    <div style="position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5)" id="searchBackdrop"></div>
    <div style="position:absolute;top:60px;left:50%;transform:translateX(-50%);width:500px;max-width:90%;background:var(--bg-secondary);border:1px solid var(--border);border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,.5);padding:8px">
      <input id="searchInput" type="text" placeholder="Search by name, ID, CIDR, or type..." style="width:100%;background:var(--bg-input);border:1px solid var(--border);border-radius:6px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:13px;padding:10px 14px;outline:none" autocomplete="off">
      <div id="searchResults" style="max-height:400px;overflow-y:auto;margin-top:6px"></div>
    </div>
  </div>
  <div class="hl-locked-indicator" id="hlLockInd">Highlight locked -- click to unlock</div>
  <div class="tooltip" id="tooltip"></div>
  <div class="detail-panel" id="detailPanel">
    <div class="dp-drag-handle"><div class="dp-drag-bar"></div></div>
    <div class="dp-header">
      <div><div class="dp-title" id="dpTitle"></div><div class="dp-subtitle" id="dpSub"></div></div>
      <button class="dp-close" id="dpClose">x</button>
    </div>
    <div class="dp-toolbar">
      <span class="dp-size-label">Text</span>
      <button class="dp-size-btn" id="dpSizeDown">-</button>
      <button class="dp-size-btn" id="dpSizeUp">+</button>
      <button class="dp-size-btn" id="dpSizeReset" style="font-size:9px;width:auto;padding:0 6px">Reset</button>
    </div>
    <div class="dp-body" id="dpBody"></div>
  </div>
</div>
<script>
// ============================================================
// AZURE NETWORK TOPOLOGY MAPPER — Phase 1
// ============================================================

const _isElectron = !!(typeof window !== 'undefined' && window.electronAPI);

// ---- Mobile detection ----
const _isMobile = () => window.innerWidth <= 768;

// ---- Preferences ----
const PREFS_KEY = 'azureNetMapPrefs';
function loadPrefs() { try { const r = localStorage.getItem(PREFS_KEY); return r ? JSON.parse(r) : {} } catch(e) { return {} } }
function savePrefs(p) { const c = loadPrefs(); for (const k of Object.keys(p)) { if (k==='__proto__'||k==='constructor'||k==='prototype') continue; c[k]=p[k] } try { localStorage.setItem(PREFS_KEY, JSON.stringify(c)) } catch(e){} }
const _prefs = loadPrefs();

// ---- Global text scaling ----
let gTxtScale = _prefs.gTxtScale || 1.0;
function applyGlobalTxtScale() {
  document.documentElement.style.setProperty('--txt-scale', gTxtScale);
  document.getElementById('gTxtVal').textContent = Math.round(gTxtScale * 100) + '%';
}
document.getElementById('gTxtUp').addEventListener('click', () => { gTxtScale = Math.min(2.5, gTxtScale + 0.15); applyGlobalTxtScale(); savePrefs({ gTxtScale }) });
document.getElementById('gTxtDown').addEventListener('click', () => { gTxtScale = Math.max(0.5, gTxtScale - 0.15); applyGlobalTxtScale(); savePrefs({ gTxtScale }) });

// ---- Sidebar toggle ----
document.getElementById('sidebarToggle').addEventListener('click', () => {
  const sb = document.querySelector('.sidebar');
  const btn = document.getElementById('sidebarToggle');
  sb.classList.toggle('collapsed');
  btn.innerHTML = sb.classList.contains('collapsed') ? '&#x25B6;' : '&#x25C0;';
  if (!_isElectron) {
    // Show/hide mobile backdrop (browser only)
    const bd = document.getElementById('mobileBackdrop');
    if (bd) { bd.style.display = (!sb.classList.contains('collapsed') && _isMobile()) ? 'block' : 'none' }
  }
  if (!_isMobile()) savePrefs({ sidebarCollapsed: sb.classList.contains('collapsed') });
});
// Mobile backdrop: browser only (not needed in Electron desktop app)
if (!_isElectron) {
  (function() {
    const bd = document.createElement('div');
    bd.id = 'mobileBackdrop';
    bd.style.cssText = 'display:none;position:fixed;inset:0;background:rgba(0,0,0,.5);z-index:99;backdrop-filter:blur(2px)';
    document.body.appendChild(bd);
    bd.addEventListener('click', () => {
      const sb = document.querySelector('.sidebar');
      sb.classList.add('collapsed');
      document.getElementById('sidebarToggle').innerHTML = '&#x25B6;';
      bd.style.display = 'none';
    });
  })();
}
// Restore sidebar state (collapse on mobile by default, not in Electron)
if (_prefs.sidebarCollapsed || (!_isElectron && _isMobile())) {
  document.querySelector('.sidebar').classList.add('collapsed');
  document.getElementById('sidebarToggle').innerHTML = '&#x25B6;';
}

// ---- Detail panel text scaling ----
let dpTxtScale = 1.0;
document.getElementById('dpSizeUp').addEventListener('click', () => { dpTxtScale = Math.min(2.0, dpTxtScale + 0.1); document.documentElement.style.setProperty('--dp-txt-scale', dpTxtScale) });
document.getElementById('dpSizeDown').addEventListener('click', () => { dpTxtScale = Math.max(0.5, dpTxtScale - 0.1); document.documentElement.style.setProperty('--dp-txt-scale', dpTxtScale) });
document.getElementById('dpSizeReset').addEventListener('click', () => { dpTxtScale = 1.0; document.documentElement.style.setProperty('--dp-txt-scale', 1) });
document.getElementById('dpClose').addEventListener('click', closeDetailPanel);

function closeDetailPanel() {
  document.getElementById('detailPanel').classList.remove('open');
}

// ============================================================
// UTILITY FUNCTIONS
// ============================================================

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML.replace(/'/g, '&#39;').replace(/\\/g, '&#92;') }

function safeParse(t) {
  if (!t || !t.trim()) return [];
  t = t.trim();
  try { const r = JSON.parse(t); return Array.isArray(r) ? r : [r] }
  catch(e) {
    // Try to extract multiple JSON objects/arrays
    const results = [];
    let depth = 0, start = -1, inStr = false, escNext = false;
    for (let i = 0; i < t.length; i++) {
      const ch = t[i];
      if (escNext) { escNext = false; continue }
      if (ch === '\\') { escNext = true; continue }
      if (ch === '"') { inStr = !inStr; continue }
      if (inStr) continue;
      if (ch === '{' || ch === '[') { if (depth === 0) start = i; depth++ }
      else if (ch === '}' || ch === ']') {
        depth--;
        if (depth === 0 && start >= 0) {
          try { const obj = JSON.parse(t.substring(start, i + 1)); if (Array.isArray(obj)) results.push(...obj); else results.push(obj) } catch(e2) {}
          start = -1;
        }
      }
    }
    return results;
  }
}

// Azure resource ID parser
function parseResourceId(id) {
  if (!id) return null;
  const parts = id.split('/');
  if (parts.length < 9) return null;
  const result = {
    subscriptionId: parts[2] || '',
    resourceGroup: parts[4] || '',
    provider: (parts[6] || '') + '/' + (parts[7] || ''),
    resourceType: parts[7] || '',
    resourceName: parts[8] || '',
    childType: parts[9] || null,
    childName: parts[10] || null,
    full: id
  };
  return result;
}

// Short name from resource ID or name
function shortName(resource) {
  if (!resource) return '?';
  if (typeof resource === 'string') {
    if (resource.includes('/')) {
      const parts = resource.split('/');
      return parts[parts.length - 1];
    }
    return resource;
  }
  return resource.name || shortName(resource.id) || '?';
}

// Get value from element
function gv(id) { const el = document.getElementById(id); return el ? el.value : '' }

// CIDR utilities
function parseCIDR(cidr) {
  if (!cidr || typeof cidr !== 'string') return null;
  const m = cidr.match(/^(\d+\.\d+\.\d+\.\d+)\/(\d+)$/);
  if (!m) return null;
  const octets = m[1].split('.').map(Number);
  if (octets.some(o => o < 0 || o > 255)) return null;
  const prefix = parseInt(m[2]);
  if (prefix < 0 || prefix > 32) return null;
  const ip = (octets[0] << 24 | octets[1] << 16 | octets[2] << 8 | octets[3]) >>> 0;
  const mask = prefix === 0 ? 0 : (~0 << (32 - prefix)) >>> 0;
  return { ip, mask, prefix, network: (ip & mask) >>> 0, broadcast: ((ip & mask) | ~mask) >>> 0, size: 1 << (32 - prefix), cidr };
}

function cidrContains(parent, child) {
  const p = parseCIDR(parent), c = parseCIDR(child);
  if (!p || !c) return false;
  return (c.network & p.mask) === p.network && p.prefix <= c.prefix;
}

function ipInCIDR(ip, cidr) {
  const c = parseCIDR(cidr);
  if (!c || !ip) return false;
  const octets = ip.split('.').map(Number);
  const ipNum = (octets[0] << 24 | octets[1] << 16 | octets[2] << 8 | octets[3]) >>> 0;
  return (ipNum & c.mask) === c.network;
}

// Copy to clipboard
function copyText(text) {
  navigator.clipboard.writeText(text).then(() => {
    const toast = document.getElementById('copyToast');
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 1200);
  }).catch(() => {});
}

// ============================================================
// SIDEBAR INPUT FIELDS — All 40 resource types
// ============================================================

const INPUT_SECTIONS = [
  { title: 'Core Networking', inputs: [
    { id: 'in_vnets', l: 'VNets', c: 'az network vnet list' },
    { id: 'in_nsgs', l: 'NSGs', c: 'az network nsg list' },
    { id: 'in_rts', l: 'Route Tables', c: 'az network route-table list' },
    { id: 'in_nics', l: 'NICs', c: 'az network nic list' },
    { id: 'in_pips', l: 'Public IPs', c: 'az network public-ip list' },
    { id: 'in_natgws', l: 'NAT Gateways', c: 'az network nat gateway list' },
    { id: 'in_pes', l: 'Private Endpoints', c: 'az network private-endpoint list' },
    { id: 'in_asgs', l: 'ASGs', c: 'az network asg list' },
  ]},
  { title: 'Compute', inputs: [
    { id: 'in_vms', l: 'Virtual Machines', c: 'az vm list --show-details' },
    { id: 'in_funcs', l: 'Function Apps', c: 'az functionapp list' },
    { id: 'in_aci', l: 'Container Instances', c: 'az container list' },
    { id: 'in_aks', l: 'AKS Clusters', c: 'az aks list' },
  ]},
  { title: 'Load Balancing', inputs: [
    { id: 'in_appgws', l: 'Application Gateways', c: 'az network application-gateway list' },
    { id: 'in_lbs', l: 'Load Balancers', c: 'az network lb list' },
  ]},
  { title: 'Connectivity', inputs: [
    { id: 'in_peerings', l: 'VNet Peerings', c: '(aggregated)' },
    { id: 'in_vpnconns', l: 'VPN Connections', c: 'az network vpn-connection list' },
    { id: 'in_vwans', l: 'Virtual WANs', c: 'az network vwan list' },
    { id: 'in_vhubs', l: 'Virtual Hubs', c: 'az network vhub list' },
    { id: 'in_hubconns', l: 'Hub Connections', c: '(aggregated)' },
  ]},
  { title: 'Storage', inputs: [
    { id: 'in_disks', l: 'Managed Disks', c: 'az disk list' },
    { id: 'in_snapshots', l: 'Snapshots', c: 'az snapshot list' },
    { id: 'in_storage', l: 'Storage Accounts', c: 'az storage account list' },
  ]},
  { title: 'DNS', inputs: [
    { id: 'in_dnszones', l: 'DNS Zones (Public)', c: 'az network dns zone list' },
    { id: 'in_privdns', l: 'DNS Zones (Private)', c: 'az network private-dns zone list' },
    { id: 'in_dnsrecords', l: 'DNS Record Sets', c: '(aggregated)' },
  ]},
  { title: 'Security & Edge', inputs: [
    { id: 'in_frontdoors', l: 'Front Door', c: 'az afd profile list' },
    { id: 'in_wafpolicies', l: 'WAF Policies', c: 'az network application-gateway waf-policy list' },
  ]},
  { title: 'Database', inputs: [
    { id: 'in_sqlservers', l: 'SQL Servers', c: 'az sql server list' },
    { id: 'in_sqldbs', l: 'SQL Databases', c: '(aggregated)' },
    { id: 'in_redis', l: 'Redis Caches', c: 'az redis list' },
    { id: 'in_synapse', l: 'Synapse Workspaces', c: 'az synapse workspace list' },
  ]},
  { title: 'Identity', inputs: [
    { id: 'in_roleassign', l: 'Role Assignments', c: 'az role assignment list --all' },
    { id: 'in_roledefs', l: 'Role Definitions', c: 'az role definition list' },
    { id: 'in_sps', l: 'Service Principals', c: 'az ad sp list --all' },
  ]},
  { title: 'Azure Infrastructure', inputs: [
    { id: 'in_rgs', l: 'Resource Groups', c: 'az group list' },
    { id: 'in_bastions', l: 'Bastions', c: 'az network bastion list' },
    { id: 'in_watchers', l: 'Network Watchers', c: 'az network watcher list' },
    { id: 'in_firewalls', l: 'Azure Firewalls', c: 'az network firewall list' },
  ]},
];

// Build sidebar
(function buildSidebar() {
  const body = document.getElementById('sidebarBody');
  let html = '';
  const mobile = !_isElectron && _isMobile();
  INPUT_SECTIONS.forEach((sec, si) => {
    const startCollapsed = mobile || si > 3;
    html += `<div class="sec-hdr${startCollapsed ? ' collapsed' : ''}" onclick="this.classList.toggle('collapsed');this.nextElementSibling.classList.toggle('hidden')"><span>${esc(sec.title)}</span><span class="arr">&#9660;</span></div>`;
    html += `<div class="sec-body${startCollapsed ? ' hidden' : ''}">`;
    sec.inputs.forEach(inp => {
      html += `<div class="ig"><div class="ig-lbl"><span>${esc(inp.l)}</span><code>${esc(inp.c)}</code></div><textarea id="${inp.id}" class="ji" placeholder="Paste ${esc(inp.c)} JSON..."></textarea></div>`;
    });
    html += '</div>';
  });
  body.innerHTML = html;

  // JSON validation on input
  document.querySelectorAll('.ji').forEach(el => {
    el.addEventListener('input', function() {
      if (!this.value.trim()) { this.className = 'ji'; return }
      try { JSON.parse(this.value); this.className = 'ji valid' }
      catch(e) { this.className = 'ji invalid' }
    });
  });
})();

// ============================================================
// FILE UPLOAD
// ============================================================

const FILE_TO_INPUT_MAP = {
  'vnets': 'in_vnets', 'nsgs': 'in_nsgs', 'route-tables': 'in_rts',
  'nics': 'in_nics', 'public-ips': 'in_pips', 'nat-gateways': 'in_natgws',
  'private-endpoints': 'in_pes', 'asgs': 'in_asgs',
  'vms': 'in_vms', 'function-apps': 'in_funcs', 'container-instances': 'in_aci', 'aks-clusters': 'in_aks',
  'application-gateways': 'in_appgws', 'load-balancers': 'in_lbs',
  'vnet-peerings': 'in_peerings', 'vpn-connections': 'in_vpnconns',
  'vwans': 'in_vwans', 'vhubs': 'in_vhubs', 'vhub-connections': 'in_hubconns',
  'managed-disks': 'in_disks', 'snapshots': 'in_snapshots', 'storage-accounts': 'in_storage',
  'dns-zones': 'in_dnszones', 'private-dns-zones': 'in_privdns', 'dns-record-sets': 'in_dnsrecords',
  'front-doors': 'in_frontdoors', 'waf-policies': 'in_wafpolicies',
  'sql-servers': 'in_sqlservers', 'sql-databases': 'in_sqldbs',
  'redis-caches': 'in_redis', 'synapse-workspaces': 'in_synapse',
  'role-assignments': 'in_roleassign', 'role-definitions': 'in_roledefs',
  'service-principals': 'in_sps',
  'resource-groups': 'in_rgs', 'bastions': 'in_bastions',
  'network-watchers': 'in_watchers', 'firewalls': 'in_firewalls',
};

document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change', function() {
  const statusEl = document.getElementById('uploadStatus');
  let loaded = 0;
  Array.from(this.files).forEach(file => {
    const reader = new FileReader();
    reader.onload = function(e) {
      const key = file.name.replace(/\.json$/i, '');
      const inputId = FILE_TO_INPUT_MAP[key];
      if (inputId) {
        const el = document.getElementById(inputId);
        if (el) { el.value = e.target.result; el.className = 'ji valid'; loaded++ }
      }
      statusEl.style.display = 'block';
      statusEl.textContent = `Loaded ${loaded} file(s)`;
    };
    reader.readAsText(file);
  });
});

// Electron folder import
if (_isElectron && window.electronAPI.onImportFolder) {
  document.getElementById('importFolderBtn').style.display = '';
  window.electronAPI.onImportFolder(data => {
    let loaded = 0;
    for (const [key, content] of Object.entries(data)) {
      const inputId = FILE_TO_INPUT_MAP[key];
      if (inputId) {
        const el = document.getElementById(inputId);
        if (el) { el.value = content; el.className = 'ji valid'; loaded++ }
      }
    }
    document.getElementById('uploadStatus').style.display = 'block';
    document.getElementById('uploadStatus').textContent = `Imported ${loaded} file(s) from folder`;
  });
}

// ============================================================
// LOOKUP MAP BUILDERS
// ============================================================

let _lk = {}; // Global lookup maps

function buildLookups(data) {
  const lk = {
    vnets: [], subnets: [], nsgs: [], routeTables: [], nics: [], publicIps: [],
    natGateways: [], privateEndpoints: [], asgs: [], vms: [], functionApps: [],
    containerInstances: [], aksClusters: [], appGateways: [], loadBalancers: [],
    peerings: [], vpnConnections: [], vwans: [], vhubs: [], hubConnections: [],
    disks: [], snapshots: [], storageAccounts: [], dnsZones: [], privateDnsZones: [],
    dnsRecords: [], frontDoors: [], wafPolicies: [], sqlServers: [], sqlDatabases: [],
    redisCaches: [], synapseWorkspaces: [], roleAssignments: [], roleDefinitions: [],
    servicePrincipals: [], resourceGroups: [], bastions: [], networkWatchers: [],
    firewalls: [],
    // Relationship maps
    subnetsByVnet: {},       // vnetId -> subnet[]
    nicsBySubnet: {},        // subnetId -> nic[]
    vmsByNic: {},            // nicId -> vm
    vmsBySubnet: {},         // subnetId -> vm[]
    nsgBySubnet: {},         // subnetId -> nsg
    nsgByNic: {},            // nicId -> nsg
    rtBySubnet: {},          // subnetId -> routeTable
    natBySubnet: {},         // subnetId -> natGw
    publicIpByNic: {},       // nicId -> publicIp
    publicIpById: {},        // pipId -> publicIp
    disksByVm: {},           // vmId -> disk[]
    pesBySubnet: {},         // subnetId -> pe[]
    peeringsByVnet: {},      // vnetId -> peering[]
    appGwBySubnet: {},       // subnetId -> appGw[]
    lbBySubnet: {},          // subnetId -> lb[]
    funcBySubnet: {},        // subnetId -> funcApp[]
    nsgById: {},             // nsgId -> nsg
    rtById: {},              // rtId -> routeTable
    nicById: {},             // nicId -> nic
    vnetById: {},            // vnetId -> vnet
    subnetById: {},          // subnetId -> subnet
    vmById: {},              // vmId -> vm
    rgByName: {},            // rgName (lower) -> rg
    subscriptions: new Set(),
  };

  // Parse all inputs
  lk.vnets = data.vnets || [];
  lk.nsgs = data.nsgs || [];
  lk.routeTables = data.routeTables || [];
  lk.nics = data.nics || [];
  lk.publicIps = data.publicIps || [];
  lk.natGateways = data.natGateways || [];
  lk.privateEndpoints = data.privateEndpoints || [];
  lk.asgs = data.asgs || [];
  lk.vms = data.vms || [];
  lk.functionApps = data.functionApps || [];
  lk.containerInstances = data.containerInstances || [];
  lk.aksClusters = data.aksClusters || [];
  lk.appGateways = data.appGateways || [];
  lk.loadBalancers = data.loadBalancers || [];
  lk.peerings = data.peerings || [];
  lk.vpnConnections = data.vpnConnections || [];
  lk.vwans = data.vwans || [];
  lk.vhubs = data.vhubs || [];
  lk.hubConnections = data.hubConnections || [];
  lk.disks = data.disks || [];
  lk.snapshots = data.snapshots || [];
  lk.storageAccounts = data.storageAccounts || [];
  lk.dnsZones = data.dnsZones || [];
  lk.privateDnsZones = data.privateDnsZones || [];
  lk.dnsRecords = data.dnsRecords || [];
  lk.frontDoors = data.frontDoors || [];
  lk.wafPolicies = data.wafPolicies || [];
  lk.sqlServers = data.sqlServers || [];
  lk.sqlDatabases = data.sqlDatabases || [];
  lk.redisCaches = data.redisCaches || [];
  lk.synapseWorkspaces = data.synapseWorkspaces || [];
  lk.roleAssignments = data.roleAssignments || [];
  lk.roleDefinitions = data.roleDefinitions || [];
  lk.servicePrincipals = data.servicePrincipals || [];
  lk.resourceGroups = data.resourceGroups || [];
  lk.bastions = data.bastions || [];
  lk.networkWatchers = data.networkWatchers || [];
  lk.firewalls = data.firewalls || [];

  // Collect subscriptions
  lk.vnets.forEach(v => { if (v.id) { const p = parseResourceId(v.id); if (p) lk.subscriptions.add(p.subscriptionId) } });

  // Index resource groups
  lk.resourceGroups.forEach(rg => { if (rg.name) lk.rgByName[rg.name.toLowerCase()] = rg });

  // Index VNets and extract subnets
  lk.vnets.forEach(vnet => {
    if (vnet.id) lk.vnetById[vnet.id.toLowerCase()] = vnet;
    lk.subnetsByVnet[vnet.id] = [];
    if (vnet.subnets && Array.isArray(vnet.subnets)) {
      vnet.subnets.forEach(sub => {
        lk.subnets.push(sub);
        lk.subnetsByVnet[vnet.id].push(sub);
        if (sub.id) lk.subnetById[sub.id.toLowerCase()] = sub;
      });
    }
  });

  // Index NSGs
  lk.nsgs.forEach(nsg => { if (nsg.id) lk.nsgById[nsg.id.toLowerCase()] = nsg });

  // Index Route Tables
  lk.routeTables.forEach(rt => { if (rt.id) lk.rtById[rt.id.toLowerCase()] = rt });

  // Index NICs and build relationships
  lk.nics.forEach(nic => {
    if (nic.id) lk.nicById[nic.id.toLowerCase()] = nic;
    // NSG on NIC
    if (nic.networkSecurityGroup && nic.networkSecurityGroup.id) {
      lk.nsgByNic[nic.id.toLowerCase()] = lk.nsgById[nic.networkSecurityGroup.id.toLowerCase()] || nic.networkSecurityGroup;
    }
    // NIC -> Subnet mapping
    if (nic.ipConfigurations) {
      nic.ipConfigurations.forEach(ipc => {
        if (ipc.subnet && ipc.subnet.id) {
          const subId = ipc.subnet.id.toLowerCase();
          if (!lk.nicsBySubnet[subId]) lk.nicsBySubnet[subId] = [];
          lk.nicsBySubnet[subId].push(nic);
        }
        // Public IP on NIC
        if (ipc.publicIpAddress && ipc.publicIpAddress.id) {
          lk.publicIpByNic[nic.id.toLowerCase()] = ipc.publicIpAddress;
        }
      });
    }
  });

  // Index Public IPs
  lk.publicIps.forEach(pip => { if (pip.id) lk.publicIpById[pip.id.toLowerCase()] = pip });

  // Resolve publicIpByNic to full objects
  for (const [nicId, pipRef] of Object.entries(lk.publicIpByNic)) {
    if (pipRef.id) {
      const full = lk.publicIpById[pipRef.id.toLowerCase()];
      if (full) lk.publicIpByNic[nicId] = full;
    }
  }

  // Index VMs
  lk.vms.forEach(vm => {
    if (vm.id) lk.vmById[vm.id.toLowerCase()] = vm;
    if (vm.networkProfile && vm.networkProfile.networkInterfaces) {
      vm.networkProfile.networkInterfaces.forEach(nicRef => {
        if (nicRef.id) lk.vmsByNic[nicRef.id.toLowerCase()] = vm;
      });
    }
  });

  // Build vmsBySubnet: VM -> NIC -> Subnet
  lk.vms.forEach(vm => {
    if (vm.networkProfile && vm.networkProfile.networkInterfaces) {
      vm.networkProfile.networkInterfaces.forEach(nicRef => {
        const nic = nicRef.id ? lk.nicById[nicRef.id.toLowerCase()] : null;
        if (nic && nic.ipConfigurations) {
          nic.ipConfigurations.forEach(ipc => {
            if (ipc.subnet && ipc.subnet.id) {
              const subId = ipc.subnet.id.toLowerCase();
              if (!lk.vmsBySubnet[subId]) lk.vmsBySubnet[subId] = [];
              if (!lk.vmsBySubnet[subId].includes(vm)) lk.vmsBySubnet[subId].push(vm);
            }
          });
        }
      });
    }
  });

  // NSG by subnet
  lk.subnets.forEach(sub => {
    if (sub.networkSecurityGroup && sub.networkSecurityGroup.id) {
      lk.nsgBySubnet[sub.id.toLowerCase()] = lk.nsgById[sub.networkSecurityGroup.id.toLowerCase()] || sub.networkSecurityGroup;
    }
    // Route table by subnet
    if (sub.routeTable && sub.routeTable.id) {
      lk.rtBySubnet[sub.id.toLowerCase()] = lk.rtById[sub.routeTable.id.toLowerCase()] || sub.routeTable;
    }
    // NAT gateway by subnet
    if (sub.natGateway && sub.natGateway.id) {
      lk.natBySubnet[sub.id.toLowerCase()] = sub.natGateway;
    }
  });

  // Resolve NAT gateways to full objects
  lk.natGateways.forEach(nat => {
    if (nat.subnets) {
      nat.subnets.forEach(subRef => {
        if (subRef.id) lk.natBySubnet[subRef.id.toLowerCase()] = nat;
      });
    }
  });

  // Private endpoints by subnet
  lk.privateEndpoints.forEach(pe => {
    if (pe.subnet && pe.subnet.id) {
      const subId = pe.subnet.id.toLowerCase();
      if (!lk.pesBySubnet[subId]) lk.pesBySubnet[subId] = [];
      lk.pesBySubnet[subId].push(pe);
    }
  });

  // Peerings by VNet
  lk.peerings.forEach(p => {
    // The peering's parent VNet is encoded in its ID
    if (p.id) {
      const parsed = parseResourceId(p.id);
      if (parsed) {
        // Reconstruct VNet ID from peering ID
        const parts = p.id.split('/');
        const vnetIdx = parts.indexOf('virtualNetworks');
        if (vnetIdx >= 0) {
          const vnetId = parts.slice(0, vnetIdx + 2).join('/');
          if (!lk.peeringsByVnet[vnetId]) lk.peeringsByVnet[vnetId] = [];
          lk.peeringsByVnet[vnetId].push(p);
        }
      }
    }
  });

  // Also extract peerings embedded in VNet objects
  lk.vnets.forEach(vnet => {
    if (vnet.virtualNetworkPeerings) {
      vnet.virtualNetworkPeerings.forEach(p => {
        if (!lk.peeringsByVnet[vnet.id]) lk.peeringsByVnet[vnet.id] = [];
        lk.peeringsByVnet[vnet.id].push(p);
        if (!lk.peerings.includes(p)) lk.peerings.push(p);
      });
    }
  });

  // App Gateways by subnet
  lk.appGateways.forEach(agw => {
    if (agw.gatewayIPConfigurations || agw.gatewayIpConfigurations) {
      const configs = agw.gatewayIPConfigurations || agw.gatewayIpConfigurations || [];
      configs.forEach(conf => {
        if (conf.subnet && conf.subnet.id) {
          const subId = conf.subnet.id.toLowerCase();
          if (!lk.appGwBySubnet[subId]) lk.appGwBySubnet[subId] = [];
          lk.appGwBySubnet[subId].push(agw);
        }
      });
    }
  });

  // Load Balancers by subnet
  lk.loadBalancers.forEach(lb => {
    if (lb.frontendIPConfigurations || lb.frontendIpConfigurations) {
      const configs = lb.frontendIPConfigurations || lb.frontendIpConfigurations || [];
      configs.forEach(conf => {
        if (conf.subnet && conf.subnet.id) {
          const subId = conf.subnet.id.toLowerCase();
          if (!lk.lbBySubnet[subId]) lk.lbBySubnet[subId] = [];
          lk.lbBySubnet[subId].push(lb);
        }
      });
    }
  });

  // Function Apps by subnet
  lk.functionApps.forEach(fa => {
    if (fa.virtualNetworkSubnetId) {
      const subId = fa.virtualNetworkSubnetId.toLowerCase();
      if (!lk.funcBySubnet[subId]) lk.funcBySubnet[subId] = [];
      lk.funcBySubnet[subId].push(fa);
    }
  });

  // Disks by VM
  lk.disks.forEach(disk => {
    if (disk.managedBy) {
      const vmId = disk.managedBy.toLowerCase();
      if (!lk.disksByVm[vmId]) lk.disksByVm[vmId] = [];
      lk.disksByVm[vmId].push(disk);
    }
  });

  return lk;
}

// Determine if subnet is "public" (has public IP path or NAT)
function isSubnetPublic(subnetId, lk) {
  const subId = subnetId.toLowerCase();
  // Has NAT gateway
  if (lk.natBySubnet[subId]) return true;
  // Has NIC with public IP
  const nics = lk.nicsBySubnet[subId] || [];
  for (const nic of nics) {
    if (lk.publicIpByNic[nic.id.toLowerCase()]) return true;
  }
  // Has app gateway (typically public-facing)
  if (lk.appGwBySubnet[subId] && lk.appGwBySubnet[subId].length > 0) return true;
  return false;
}

// Count resources in a subnet
function countSubnetResources(subnetId, lk) {
  const subId = subnetId.toLowerCase();
  let count = 0;
  count += (lk.vmsBySubnet[subId] || []).length;
  count += (lk.pesBySubnet[subId] || []).length;
  count += (lk.appGwBySubnet[subId] || []).length;
  count += (lk.lbBySubnet[subId] || []).length;
  count += (lk.funcBySubnet[subId] || []).length;
  // Count firewalls on AzureFirewallSubnet
  lk.firewalls.forEach(fw => {
    const fwSub = (fw.ipConfigurations || []).find(c => c.subnet?.id)?.subnet?.id || '';
    if (fwSub.toLowerCase() === subId) count++;
  });
  // Count bastions on AzureBastionSubnet
  lk.bastions.forEach(b => {
    const bSub = (b.ipConfigurations || []).find(c => c.subnet?.id)?.subnet?.id || '';
    if (bSub.toLowerCase() === subId) count++;
  });
  return count;
}

// ============================================================
// D3.js GRID LAYOUT RENDERING ENGINE
// ============================================================

let zB = null; // D3 zoom behavior reference
let _currentData = null; // Current parsed data for search etc.

function renderMap() {
  const overlay = document.getElementById('loadingOverlay');
  overlay.style.display = 'flex';
  requestAnimationFrame(() => {
    setTimeout(() => {
      try { _renderMapInner() }
      catch(e) { console.error('Render error:', e) }
      finally { overlay.style.display = 'none' }
    }, 50);
  });
}

function _renderMapInner() {
  // Parse all inputs
  const data = {
    vnets: safeParse(gv('in_vnets')),
    nsgs: safeParse(gv('in_nsgs')),
    routeTables: safeParse(gv('in_rts')),
    nics: safeParse(gv('in_nics')),
    publicIps: safeParse(gv('in_pips')),
    natGateways: safeParse(gv('in_natgws')),
    privateEndpoints: safeParse(gv('in_pes')),
    asgs: safeParse(gv('in_asgs')),
    vms: safeParse(gv('in_vms')),
    functionApps: safeParse(gv('in_funcs')),
    containerInstances: safeParse(gv('in_aci')),
    aksClusters: safeParse(gv('in_aks')),
    appGateways: safeParse(gv('in_appgws')),
    loadBalancers: safeParse(gv('in_lbs')),
    peerings: safeParse(gv('in_peerings')),
    vpnConnections: safeParse(gv('in_vpnconns')),
    vwans: safeParse(gv('in_vwans')),
    vhubs: safeParse(gv('in_vhubs')),
    hubConnections: safeParse(gv('in_hubconns')),
    disks: safeParse(gv('in_disks')),
    snapshots: safeParse(gv('in_snapshots')),
    storageAccounts: safeParse(gv('in_storage')),
    dnsZones: safeParse(gv('in_dnszones')),
    privateDnsZones: safeParse(gv('in_privdns')),
    dnsRecords: safeParse(gv('in_dnsrecords')),
    frontDoors: safeParse(gv('in_frontdoors')),
    wafPolicies: safeParse(gv('in_wafpolicies')),
    sqlServers: safeParse(gv('in_sqlservers')),
    sqlDatabases: safeParse(gv('in_sqldbs')),
    redisCaches: safeParse(gv('in_redis')),
    synapseWorkspaces: safeParse(gv('in_synapse')),
    roleAssignments: safeParse(gv('in_roleassign')),
    roleDefinitions: safeParse(gv('in_roledefs')),
    servicePrincipals: safeParse(gv('in_sps')),
    resourceGroups: safeParse(gv('in_rgs')),
    bastions: safeParse(gv('in_bastions')),
    networkWatchers: safeParse(gv('in_watchers')),
    firewalls: safeParse(gv('in_firewalls')),
  };

  if (data.vnets.length === 0) {
    document.getElementById('emptyState').style.display = 'flex';
    document.getElementById('emptyTitle').textContent = 'No VNets found';
    document.getElementById('emptyDesc').textContent = 'Paste az network vnet list output and click Render Map';
    return;
  }

  document.getElementById('emptyState').style.display = 'none';

  // Build lookup maps
  _lk = buildLookups(data);
  _currentData = data;

  // Build subscription color map
  const subColors = ['#3b82f6', '#06b6d4', '#8b5cf6', '#10b981', '#f59e0b', '#ec4899', '#ef4444', '#60a5fa'];
  const subIds = [...new Set(_lk.vnets.map(v => { const p = parseResourceId(v.id || ''); return p ? p.subscriptionId : '' }).filter(Boolean))];
  _lk.subscriptionColorMap = {};
  subIds.forEach((sid, i) => { _lk.subscriptionColorMap[sid] = subColors[i % subColors.length] });
  _lk.multiSubscription = subIds.length > 1;

  const layoutMode = document.getElementById('layoutMode').value;

  // Clear SVG
  const svg = d3.select('#mapSvg');
  svg.selectAll('*').remove();

  // Add defs
  const defs = svg.append('defs');
  defs.append('filter').attr('id', 'alphaClamp')
    .append('feComponentTransfer')
    .append('feFuncA').attr('type', 'linear').attr('slope', 1).attr('intercept', 0);

  // Setup zoom
  const g = svg.append('g').attr('id', 'mapRoot');
  zB = d3.zoom().scaleExtent([0.08, 5]).on('zoom', e => {
    g.attr('transform', e.transform);
    document.getElementById('zoomLevel').textContent = Math.round(e.transform.k * 100) + '%';
  });
  svg.call(zB);

  // Render based on layout
  if (layoutMode === 'grid') {
    renderGridLayout(g, _lk);
  } else if (layoutMode === 'landingzone') {
    renderLandingZoneLayout(g, _lk);
  } else if (layoutMode === 'executive') {
    renderExecutiveLayout(g, _lk);
  } else {
    renderGridLayout(g, _lk);
  }

  // Show stats bar
  renderStatsBar(_lk);

  // Show legend and export bar
  document.getElementById('legend').style.display = 'flex';
  if (!_isElectron && _isMobile()) document.getElementById('legend').classList.add('collapsed');
  document.getElementById('exportBar').style.display = 'flex';

  // Hide Flow button in Executive mode (reporting only — no network tracing)
  const flowBtn = document.getElementById('flowBtn');
  if (flowBtn) flowBtn.style.display = layoutMode === 'executive' ? 'none' : 'flex';

  // Fit to view after render
  setTimeout(() => zoomFit(), 100);
}

// ---- Stats Bar ----
function renderStatsBar(lk) {
  const bar = document.getElementById('statsBar');
  const counts = [
    ['VNets', lk.vnets.length],
    ['Subnets', lk.subnets.length],
    ['NSGs', lk.nsgs.length],
    ['VMs', lk.vms.length],
    ['NICs', lk.nics.length],
    ['Public IPs', lk.publicIps.length],
    ['NAT GWs', lk.natGateways.length],
    ['Priv Endpoints', lk.privateEndpoints.length],
    ['App GWs', lk.appGateways.length],
    ['LBs', lk.loadBalancers.length],
    ['Peerings', lk.peerings.length],
    ['Firewalls', lk.firewalls.length],
  ].filter(([, c]) => c > 0);

  bar.innerHTML = counts.map(([label, count]) =>
    `<div class="stat-chip"><b>${count}</b>${esc(label)}</div>`
  ).join('');
  bar.style.display = 'flex';
}

// ---- Grid Layout ----
function renderGridLayout(g, lk) {
  const vnets = lk.vnets;
  const vnetCount = vnets.length;

  // Layout constants
  const VNET_PAD = 30;
  const SUBNET_H = 140;
  const SUBNET_W = 280;
  const SUBNET_GAP = 12;
  const SUBNET_PAD_TOP = 50;
  const VNET_GAP = 40;
  const RES_H = 18;
  const RES_GAP = 2;
  const COLS = vnetCount <= 2 ? vnetCount : vnetCount <= 6 ? 3 : 4;

  let colX = 0, rowY = 0, col = 0, maxRowH = 0;

  vnets.forEach((vnet, vi) => {
    const subnets = lk.subnetsByVnet[vnet.id] || [];
    const subCount = Math.max(subnets.length, 1);

    // Calculate VNet dimensions
    const subRows = Math.ceil(subCount / 2);
    const vnetW = Math.max(SUBNET_W * Math.min(subCount, 2) + SUBNET_GAP * (Math.min(subCount, 2) - 1) + VNET_PAD * 2, 300);

    // Calculate subnet heights based on resources
    let maxSubH = SUBNET_H;
    subnets.forEach(sub => {
      const resCount = countSubnetResources(sub.id, lk);
      const h = SUBNET_H + Math.max(0, resCount - 3) * (RES_H + RES_GAP);
      if (h > maxSubH) maxSubH = h;
    });

    const vnetH = SUBNET_PAD_TOP + subRows * (maxSubH + SUBNET_GAP) + VNET_PAD;

    // Position VNet
    const vx = colX;
    const vy = rowY;

    // Draw VNet container
    const vnetParsed = vnet.id ? parseResourceId(vnet.id) : null;
    const vnetSubId = vnetParsed ? vnetParsed.subscriptionId : '';
    const vnetStroke = lk.multiSubscription && vnetSubId ? (lk.subscriptionColorMap[vnetSubId] || 'var(--vnet-stroke)') : 'var(--vnet-stroke)';
    const vnetFill = lk.multiSubscription && vnetSubId ? (vnetStroke + '0a') : 'rgba(59,130,246,.04)';

    const vnetG = g.append('g').attr('class', 'vnet-group').attr('data-vnet-id', vnet.id);
    vnetG.append('rect')
      .attr('x', vx).attr('y', vy)
      .attr('width', vnetW).attr('height', vnetH)
      .attr('fill', vnetFill)
      .attr('stroke', vnetStroke)
      .attr('stroke-width', 1.5)
      .style('cursor', 'pointer')
      .on('click', () => openVNetPanel(vnet, lk))
      .on('mouseenter', function(event) {
        const peerCount = (lk.peeringsByVnet[vnet.id] || []).length;
        let ttHtml = `<div class="tt-title">${esc(shortName(vnet))}</div>`;
        ttHtml += `<div class="tt-sub">${esc(addressPrefixes.join(', '))} | ${esc(vnet.location || '')}</div>`;
        ttHtml += `<div class="tt-sec"><div class="tt-sh">Subnets</div><div class="tt-r">${subnets.length} subnets</div></div>`;
        if (peerCount > 0) ttHtml += `<div class="tt-sec"><div class="tt-sh">Peerings</div><div class="tt-r">${peerCount} peerings</div></div>`;
        if (lk.multiSubscription && vnetSubId) ttHtml += `<div class="tt-sec"><div class="tt-sh">Subscription</div><div class="tt-r" style="font-size:9px">${esc(vnetSubId)}</div></div>`;
        showTooltip(event, ttHtml);
      }).on('mouseleave', hideTooltip).on('mousemove', moveTooltip);

    // VNet label
    const addressPrefixes = (vnet.addressSpace && vnet.addressSpace.addressPrefixes) || [];
    const cidrText = addressPrefixes.join(', ') || '';
    vnetG.append('text').attr('class', 'vnet-label')
      .attr('x', vx + 12).attr('y', vy + 22)
      .text(shortName(vnet));
    vnetG.append('text').attr('class', 'vnet-cidr')
      .attr('x', vx + 12).attr('y', vy + 36)
      .text(cidrText);

    // Location and RG badge
    const locText = vnet.location || '';
    const rgParsed = vnet.id ? parseResourceId(vnet.id) : null;
    const rgText = rgParsed ? rgParsed.resourceGroup : '';
    if (locText || rgText) {
      vnetG.append('text')
        .attr('x', vx + vnetW - 10).attr('y', vy + 22)
        .attr('text-anchor', 'end')
        .attr('class', 'vnet-cidr')
        .text([locText, rgText].filter(Boolean).join(' | '));
    }

    // Draw subnets
    subnets.forEach((sub, si) => {
      const subCol = si % 2;
      const subRow = Math.floor(si / 2);
      const sx = vx + VNET_PAD + subCol * (SUBNET_W + SUBNET_GAP);
      const sy = vy + SUBNET_PAD_TOP + subRow * (maxSubH + SUBNET_GAP);

      const subId = sub.id ? sub.id.toLowerCase() : '';
      const isPub = isSubnetPublic(sub.id, lk);
      const fillColor = isPub ? 'rgba(6,182,212,.15)' : 'rgba(139,92,246,.15)';
      const strokeColor = isPub ? 'var(--subnet-public)' : 'var(--subnet-private)';

      const resCount = countSubnetResources(sub.id, lk);
      const subH = SUBNET_H + Math.max(0, resCount - 3) * (RES_H + RES_GAP);

      const subG = g.append('g').attr('class', 'subnet-node')
        .attr('data-subnet-id', sub.id)
        .style('cursor', 'pointer')
        .on('click', () => openSubnetPanel(sub, vnet, lk));

      subG.append('rect')
        .attr('x', sx).attr('y', sy)
        .attr('width', SUBNET_W).attr('height', subH)
        .attr('fill', fillColor)
        .attr('stroke', strokeColor)
        .attr('stroke-width', 1);

      // Subnet name
      subG.append('text').attr('class', 'subnet-label')
        .attr('x', sx + 8).attr('y', sy + 16)
        .text(shortName(sub));

      // Subnet CIDR
      const subCidr = sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]) || '';
      subG.append('text').attr('class', 'subnet-cidr')
        .attr('x', sx + 8).attr('y', sy + 28)
        .text(subCidr);

      // Public/Private badge
      subG.append('text').attr('class', 'subnet-badge')
        .attr('x', sx + SUBNET_W - 8).attr('y', sy + 16)
        .attr('text-anchor', 'end')
        .attr('fill', isPub ? 'var(--subnet-public)' : 'var(--subnet-private)')
        .text(isPub ? 'PUBLIC' : 'PRIVATE');

      // Resources inside subnet
      let resY = sy + 40;

      // VMs
      const vms = lk.vmsBySubnet[subId] || [];
      vms.forEach(vm => {
        const powerState = vm.powerState || '';
        const stateColor = powerState.includes('running') ? 'var(--accent-green)' :
                          powerState.includes('deallocated') ? 'var(--accent-red)' : 'var(--text-muted)';
        subG.append('text').attr('class', 'resource-icon')
          .attr('x', sx + 12).attr('y', resY)
          .attr('fill', stateColor)
          .text(`VM: ${shortName(vm)}`)
          .style('cursor', 'pointer')
          .on('click', (event) => { event.stopPropagation(); openVMPanel(vm.id); });
        resY += RES_H + RES_GAP;
      });

      // Private Endpoints
      const pes = lk.pesBySubnet[subId] || [];
      pes.forEach(pe => {
        subG.append('text').attr('class', 'resource-icon')
          .attr('x', sx + 12).attr('y', resY)
          .attr('fill', 'var(--pe-color)')
          .text(`PE: ${shortName(pe)}`)
          .style('cursor', 'pointer')
          .on('click', (event) => { event.stopPropagation(); openPEPanel(pe.id); });
        resY += RES_H + RES_GAP;
      });

      // App Gateways
      const agws = lk.appGwBySubnet[subId] || [];
      agws.forEach(agw => {
        subG.append('text').attr('class', 'resource-icon')
          .attr('x', sx + 12).attr('y', resY)
          .attr('fill', 'var(--appgw-color)')
          .text(`AGW: ${shortName(agw)}`)
          .style('cursor', 'pointer')
          .on('click', (event) => { event.stopPropagation(); openAppGwPanel(agw.id); });
        resY += RES_H + RES_GAP;
      });

      // Load Balancers
      const lbs = lk.lbBySubnet[subId] || [];
      lbs.forEach(lb => {
        subG.append('text').attr('class', 'resource-icon')
          .attr('x', sx + 12).attr('y', resY)
          .attr('fill', 'var(--lb-color)')
          .text(`LB: ${shortName(lb)}`)
          .style('cursor', 'pointer')
          .on('click', (event) => { event.stopPropagation(); openLBPanel(lb.id); });
        resY += RES_H + RES_GAP;
      });

      // Function Apps
      const funcs = lk.funcBySubnet[subId] || [];
      funcs.forEach(fa => {
        subG.append('text').attr('class', 'resource-icon')
          .attr('x', sx + 12).attr('y', resY)
          .attr('fill', 'var(--accent-orange)')
          .text(`Fn: ${shortName(fa)}`)
          .style('cursor', 'pointer')
          .on('click', (event) => { event.stopPropagation(); openFuncPanel(fa.id); });
        resY += RES_H + RES_GAP;
      });

      // Firewalls (on AzureFirewallSubnet)
      const subNameLc = (sub.name || '').toLowerCase();
      if (subNameLc === 'azurefirewallsubnet') {
        lk.firewalls.forEach(fw => {
          const fwSubId = (fw.ipConfigurations || []).find(c => c.subnet?.id)?.subnet?.id || '';
          if (fwSubId.toLowerCase() === subId) {
            subG.append('text').attr('class', 'resource-icon')
              .attr('x', sx + 12).attr('y', resY)
              .attr('fill', 'var(--fw-color)')
              .text(`FW: ${shortName(fw)}`)
              .style('cursor', 'pointer')
              .on('click', (event) => { event.stopPropagation(); openFirewallPanel(fw.id); });
            resY += RES_H + RES_GAP;
          }
        });
      }

      // Bastions (on AzureBastionSubnet)
      if (subNameLc === 'azurebastionsubnet') {
        lk.bastions.forEach(b => {
          const bSubId = (b.ipConfigurations || []).find(c => c.subnet?.id)?.subnet?.id || '';
          if (bSubId.toLowerCase() === subId) {
            subG.append('text').attr('class', 'resource-icon')
              .attr('x', sx + 12).attr('y', resY)
              .attr('fill', 'var(--bastion-color)')
              .text(`BST: ${shortName(b)}`)
              .style('cursor', 'pointer')
              .on('click', (event) => { event.stopPropagation(); openBastionPanel(b.id); });
            resY += RES_H + RES_GAP;
          }
        });
      }

      // Gateway icons near subnet
      const nsg = lk.nsgBySubnet[subId];
      if (nsg) {
        subG.append('circle')
          .attr('cx', sx + SUBNET_W - 20).attr('cy', sy + subH - 14)
          .attr('r', 5).attr('fill', 'var(--nsg-color)');
        subG.append('text').attr('class', 'resource-icon')
          .attr('x', sx + SUBNET_W - 28).attr('y', sy + subH - 10)
          .attr('text-anchor', 'end').attr('fill', 'var(--nsg-color)')
          .text('NSG');
      }

      const nat = lk.natBySubnet[subId];
      if (nat) {
        subG.append('circle')
          .attr('cx', sx + SUBNET_W - 40).attr('cy', sy + subH - 14)
          .attr('r', 5).attr('fill', 'var(--nat-color)');
        subG.append('text').attr('class', 'resource-icon')
          .attr('x', sx + SUBNET_W - 48).attr('y', sy + subH - 10)
          .attr('text-anchor', 'end').attr('fill', 'var(--nat-color)')
          .text('NAT');
      }

      // Tooltip on hover
      subG.on('mouseenter', function(event) {
        const resCount = countSubnetResources(sub.id, lk);
        const nsgName = nsg ? shortName(nsg) : 'None';
        const natName = nat ? shortName(nat) : 'None';
        let ttHtml = `<div class="tt-title">${esc(shortName(sub))}</div>`;
        ttHtml += `<div class="tt-sub">${esc(subCidr)} | ${isPub ? 'Public' : 'Private'}</div>`;
        ttHtml += `<div class="tt-sec"><div class="tt-sh">Resources</div><div class="tt-r">${resCount} total (${vms.length} VMs, ${pes.length} PEs)</div></div>`;
        ttHtml += `<div class="tt-sec"><div class="tt-sh">Security</div><div class="tt-r">NSG: <span class="${nsg ? 'a' : 'd'}">${esc(nsgName)}</span> | NAT: <span class="${nat ? 'a' : 'd'}">${esc(natName)}</span></div></div>`;
        showTooltip(event, ttHtml);
      }).on('mouseleave', hideTooltip).on('mousemove', moveTooltip);
    });

    // Advance grid position
    col++;
    colX += vnetW + VNET_GAP;
    if (vnetH > maxRowH) maxRowH = vnetH;

    if (col >= COLS) {
      col = 0;
      colX = 0;
      rowY += maxRowH + VNET_GAP;
      maxRowH = 0;
    }
  });

  // Draw peering lines between VNets
  renderPeeringLines(g, lk);
}

// ---- Landing Zone (Hub-Spoke Radial) Layout ----
function renderLandingZoneLayout(g, lk) {
  const vnets = lk.vnets;
  if (vnets.length === 0) return;

  // Detect hub: VNet with AzureFirewallSubnet, or VNet with most peerings
  let hubVnet = null;
  let maxPeerings = -1;
  vnets.forEach(v => {
    const subs = lk.subnetsByVnet[v.id] || [];
    const hasFwSubnet = subs.some(s => (s.name || '').toLowerCase() === 'azurefirewallsubnet');
    const peerCount = (lk.peeringsByVnet[v.id] || []).length;
    if (hasFwSubnet) hubVnet = v;
    if (peerCount > maxPeerings) { maxPeerings = peerCount; if (!hubVnet) hubVnet = v; }
  });
  if (!hubVnet) hubVnet = vnets[0];

  const spokes = vnets.filter(v => v.id !== hubVnet.id);

  // Layout constants
  const VNET_PAD = 30;
  const SUBNET_H = 140;
  const SUBNET_W = 280;
  const SUBNET_GAP = 12;
  const SUBNET_PAD_TOP = 50;
  const RES_H = 18;
  const RES_GAP = 2;

  // Calculate VNet dimensions helper
  function calcVnetSize(vnet) {
    const subnets = lk.subnetsByVnet[vnet.id] || [];
    const subCount = Math.max(subnets.length, 1);
    const subRows = Math.ceil(subCount / 2);
    let maxSubH = SUBNET_H;
    subnets.forEach(sub => {
      const resCount = countSubnetResources(sub.id, lk);
      const h = SUBNET_H + Math.max(0, resCount - 3) * (RES_H + RES_GAP);
      if (h > maxSubH) maxSubH = h;
    });
    const w = Math.max(SUBNET_W * Math.min(subCount, 2) + SUBNET_GAP * (Math.min(subCount, 2) - 1) + VNET_PAD * 2, 300);
    const h = SUBNET_PAD_TOP + subRows * (maxSubH + SUBNET_GAP) + VNET_PAD;
    return { w, h };
  }

  // Place hub at center
  const hubSize = calcVnetSize(hubVnet);
  const cx = 600;
  const cy = 500;
  const hubX = cx - hubSize.w / 2;
  const hubY = cy - hubSize.h / 2;

  renderVnetBox(g, hubVnet, hubX, hubY, hubSize.w, hubSize.h, lk);

  // Place spokes radially around hub
  const spokeRadius = Math.max(hubSize.w, hubSize.h) / 2 + 200;
  const angleStep = (2 * Math.PI) / Math.max(spokes.length, 1);
  const startAngle = -Math.PI / 2; // top

  spokes.forEach((spoke, i) => {
    const angle = startAngle + i * angleStep;
    const spokeSize = calcVnetSize(spoke);
    const sx = cx + Math.cos(angle) * spokeRadius - spokeSize.w / 2;
    const sy = cy + Math.sin(angle) * spokeRadius - spokeSize.h / 2;
    renderVnetBox(g, spoke, sx, sy, spokeSize.w, spokeSize.h, lk);
  });

  renderPeeringLines(g, lk);
}

// ---- Executive Overview Layout ----
function renderExecutiveLayout(g, lk) {
  const vnets = lk.vnets;
  if (vnets.length === 0) return;

  const CARD_W = 320;
  const CARD_H = 180;
  const GAP = 40;
  const COLS = vnets.length <= 3 ? vnets.length : Math.min(4, vnets.length);

  vnets.forEach((vnet, vi) => {
    const col = vi % COLS;
    const row = Math.floor(vi / COLS);
    const x = col * (CARD_W + GAP);
    const y = row * (CARD_H + GAP);

    const subnets = lk.subnetsByVnet[vnet.id] || [];
    const peerings = lk.peeringsByVnet[vnet.id] || [];
    const addressPrefixes = (vnet.addressSpace && vnet.addressSpace.addressPrefixes) || [];

    // Count all resources across subnets
    let totalVMs = 0, totalPEs = 0, totalFuncs = 0;
    subnets.forEach(sub => {
      const subId = sub.id ? sub.id.toLowerCase() : '';
      totalVMs += (lk.vmsBySubnet[subId] || []).length;
      totalPEs += (lk.pesBySubnet[subId] || []).length;
      totalFuncs += (lk.funcBySubnet[subId] || []).length;
    });

    const cardG = g.append('g').attr('class', 'vnet-group').attr('data-vnet-id', vnet.id)
      .style('cursor', 'pointer')
      .on('click', () => openVNetPanel(vnet, lk));

    cardG.append('rect')
      .attr('x', x).attr('y', y)
      .attr('width', CARD_W).attr('height', CARD_H)
      .attr('fill', 'rgba(59,130,246,.06)')
      .attr('stroke', 'var(--vnet-stroke)')
      .attr('stroke-width', 1.5)
      .attr('rx', 10).attr('ry', 10);

    // VNet name
    cardG.append('text').attr('class', 'vnet-label')
      .attr('x', x + 14).attr('y', y + 24)
      .text(shortName(vnet));

    // CIDR
    cardG.append('text').attr('class', 'vnet-cidr')
      .attr('x', x + 14).attr('y', y + 40)
      .text(addressPrefixes.join(', '));

    // Location
    cardG.append('text').attr('class', 'vnet-cidr')
      .attr('x', x + CARD_W - 10).attr('y', y + 24)
      .attr('text-anchor', 'end')
      .text(vnet.location || '');

    // Stats
    let statY = y + 62;
    const stats = [
      ['Subnets', subnets.length],
      ['VMs', totalVMs],
      ['Private Endpoints', totalPEs],
      ['Peerings', peerings.length],
    ].filter(([, v]) => v > 0);

    stats.forEach(([label, val]) => {
      cardG.append('text')
        .attr('x', x + 14).attr('y', statY)
        .attr('font-family', "'IBM Plex Mono',monospace")
        .attr('font-size', 'calc(10px * var(--txt-scale))')
        .attr('fill', 'var(--text-secondary)')
        .text(`${val} ${label}`);
      statY += 18;
    });

    // Key resources badges
    const hasFw = subnets.some(s => (s.name || '').toLowerCase() === 'azurefirewallsubnet') && lk.firewalls.length > 0;
    const hasBastion = subnets.some(s => (s.name || '').toLowerCase() === 'azurebastionsubnet') && lk.bastions.length > 0;
    let badgeX = x + 14;
    if (hasFw) {
      cardG.append('rect').attr('x', badgeX).attr('y', y + CARD_H - 30).attr('width', 50).attr('height', 18).attr('rx', 4).attr('fill', 'rgba(236,72,153,.15)');
      cardG.append('text').attr('x', badgeX + 25).attr('y', y + CARD_H - 18).attr('text-anchor', 'middle').attr('font-family', "'IBM Plex Mono',monospace").attr('font-size', '8px').attr('fill', 'var(--fw-color)').attr('font-weight', '600').text('FW');
      badgeX += 56;
    }
    if (hasBastion) {
      cardG.append('rect').attr('x', badgeX).attr('y', y + CARD_H - 30).attr('width', 50).attr('height', 18).attr('rx', 4).attr('fill', 'rgba(239,68,68,.15)');
      cardG.append('text').attr('x', badgeX + 25).attr('y', y + CARD_H - 18).attr('text-anchor', 'middle').attr('font-family', "'IBM Plex Mono',monospace").attr('font-size', '8px').attr('fill', 'var(--bastion-color)').attr('font-weight', '600').text('BST');
      badgeX += 56;
    }
    if (totalFuncs > 0) {
      cardG.append('rect').attr('x', badgeX).attr('y', y + CARD_H - 30).attr('width', 50).attr('height', 18).attr('rx', 4).attr('fill', 'rgba(245,158,11,.15)');
      cardG.append('text').attr('x', badgeX + 25).attr('y', y + CARD_H - 18).attr('text-anchor', 'middle').attr('font-family', "'IBM Plex Mono',monospace").attr('font-size', '8px').attr('fill', 'var(--accent-orange)').attr('font-weight', '600').text('FN');
    }
  });

  renderPeeringLines(g, lk);
}

// ---- Shared VNet box renderer (used by landing zone) ----
function renderVnetBox(g, vnet, vx, vy, vnetW, vnetH, lk) {
  const subnets = lk.subnetsByVnet[vnet.id] || [];
  const addressPrefixes = (vnet.addressSpace && vnet.addressSpace.addressPrefixes) || [];
  const VNET_PAD = 30, SUBNET_H = 140, SUBNET_W = 280, SUBNET_GAP = 12, SUBNET_PAD_TOP = 50, RES_H = 18, RES_GAP = 2;

  const vnetG = g.append('g').attr('class', 'vnet-group').attr('data-vnet-id', vnet.id);
  vnetG.append('rect')
    .attr('x', vx).attr('y', vy)
    .attr('width', vnetW).attr('height', vnetH)
    .attr('fill', 'rgba(59,130,246,.04)')
    .attr('stroke', 'var(--vnet-stroke)')
    .attr('stroke-width', 1.5)
    .style('cursor', 'pointer')
    .on('click', () => openVNetPanel(vnet, lk));

  vnetG.append('text').attr('class', 'vnet-label')
    .attr('x', vx + 12).attr('y', vy + 22)
    .text(shortName(vnet));
  vnetG.append('text').attr('class', 'vnet-cidr')
    .attr('x', vx + 12).attr('y', vy + 36)
    .text(addressPrefixes.join(', '));

  // Subnets
  let maxSubH = SUBNET_H;
  subnets.forEach(sub => {
    const resCount = countSubnetResources(sub.id, lk);
    const h = SUBNET_H + Math.max(0, resCount - 3) * (RES_H + RES_GAP);
    if (h > maxSubH) maxSubH = h;
  });

  subnets.forEach((sub, si) => {
    const subCol = si % 2;
    const subRow = Math.floor(si / 2);
    const sx = vx + VNET_PAD + subCol * (SUBNET_W + SUBNET_GAP);
    const sy = vy + SUBNET_PAD_TOP + subRow * (maxSubH + SUBNET_GAP);
    const subId = sub.id ? sub.id.toLowerCase() : '';
    const isPub = isSubnetPublic(sub.id, lk);
    const fillColor = isPub ? 'rgba(6,182,212,.15)' : 'rgba(139,92,246,.15)';
    const strokeColor = isPub ? 'var(--subnet-public)' : 'var(--subnet-private)';
    const resCount = countSubnetResources(sub.id, lk);
    const subH = SUBNET_H + Math.max(0, resCount - 3) * (RES_H + RES_GAP);

    const subG = g.append('g').attr('class', 'subnet-node')
      .attr('data-subnet-id', sub.id).style('cursor', 'pointer')
      .on('click', () => openSubnetPanel(sub, vnet, lk));

    subG.append('rect').attr('x', sx).attr('y', sy).attr('width', SUBNET_W).attr('height', subH)
      .attr('fill', fillColor).attr('stroke', strokeColor).attr('stroke-width', 1);
    subG.append('text').attr('class', 'subnet-label').attr('x', sx + 8).attr('y', sy + 16).text(shortName(sub));
    const subCidr = sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]) || '';
    subG.append('text').attr('class', 'subnet-cidr').attr('x', sx + 8).attr('y', sy + 28).text(subCidr);
    subG.append('text').attr('class', 'subnet-badge').attr('x', sx + SUBNET_W - 8).attr('y', sy + 16)
      .attr('text-anchor', 'end').attr('fill', isPub ? 'var(--subnet-public)' : 'var(--subnet-private)')
      .text(isPub ? 'PUBLIC' : 'PRIVATE');

    // Resources (compact: just count labels)
    let resY = sy + 40;
    const vms = lk.vmsBySubnet[subId] || [];
    vms.forEach(vm => {
      const stateColor = (vm.powerState || '').includes('running') ? 'var(--accent-green)' : 'var(--accent-red)';
      subG.append('text').attr('class', 'resource-icon').attr('x', sx + 12).attr('y', resY).attr('fill', stateColor)
        .text(`VM: ${shortName(vm)}`).style('cursor', 'pointer')
        .on('click', (event) => { event.stopPropagation(); openVMPanel(vm.id); });
      resY += RES_H + RES_GAP;
    });
    (lk.pesBySubnet[subId] || []).forEach(pe => {
      subG.append('text').attr('class', 'resource-icon').attr('x', sx + 12).attr('y', resY).attr('fill', 'var(--pe-color)').text(`PE: ${shortName(pe)}`);
      resY += RES_H + RES_GAP;
    });

    // NSG/NAT indicators
    const nsg = lk.nsgBySubnet[subId];
    if (nsg) {
      subG.append('circle').attr('cx', sx + SUBNET_W - 20).attr('cy', sy + subH - 14).attr('r', 5).attr('fill', 'var(--nsg-color)');
      subG.append('text').attr('class', 'resource-icon').attr('x', sx + SUBNET_W - 28).attr('y', sy + subH - 10)
        .attr('text-anchor', 'end').attr('fill', 'var(--nsg-color)').text('NSG');
    }
    const natGw = lk.natBySubnet[subId];
    if (natGw) {
      subG.append('circle').attr('cx', sx + SUBNET_W - 40).attr('cy', sy + subH - 14).attr('r', 5).attr('fill', 'var(--nat-color)');
      subG.append('text').attr('class', 'resource-icon').attr('x', sx + SUBNET_W - 48).attr('y', sy + subH - 10)
        .attr('text-anchor', 'end').attr('fill', 'var(--nat-color)').text('NAT');
    }
  });
}

// ---- Peering Lines (orthogonal routing with single connection ports) ----
function renderPeeringLines(g, lk) {
  const peerG = g.append('g').attr('class', 'peering-layer');
  const boxes = {};

  // Collect VNet bounding boxes
  g.selectAll('.vnet-group').each(function() {
    const rect = d3.select(this).select('rect');
    const id = d3.select(this).attr('data-vnet-id');
    if (rect.node()) {
      const x = +rect.attr('x'), y = +rect.attr('y');
      const w = +rect.attr('width'), h = +rect.attr('height');
      boxes[id] = { x, y, w, h, cx: x + w / 2, cy: y + h / 2 };
    }
  });

  const M = 20;   // gutter margin from VNet edge
  const R = 8;    // corner radius

  // ── Helpers ──

  function pad(b, m) { return { x: b.x - m, y: b.y - m, w: b.w + 2 * m, h: b.h + 2 * m }; }

  function segHitsBox(x1, y1, x2, y2, b) {
    return !(Math.max(x1, x2) < b.x || Math.min(x1, x2) > b.x + b.w ||
             Math.max(y1, y2) < b.y || Math.min(y1, y2) > b.y + b.h);
  }

  // Fixed connection-point at the centre of a given side
  function connPoint(box, side) {
    if (side === 'right') return { x: box.x + box.w, y: box.cy };
    if (side === 'left')  return { x: box.x, y: box.cy };
    if (side === 'bottom') return { x: box.cx, y: box.y + box.h };
    return { x: box.cx, y: box.y }; // top
  }

  // Which side of `src` faces `dst`?
  function facingSide(src, dst) {
    const dx = dst.cx - src.cx, dy = dst.cy - src.cy;
    if (Math.abs(dx) >= Math.abs(dy)) return dx >= 0 ? 'right' : 'left';
    return dy >= 0 ? 'bottom' : 'top';
  }

  // Step outward from a connection point by margin M
  function stepOut(pt, side) {
    if (side === 'right') return { x: pt.x + M, y: pt.y };
    if (side === 'left')  return { x: pt.x - M, y: pt.y };
    if (side === 'bottom') return { x: pt.x, y: pt.y + M };
    return { x: pt.x, y: pt.y - M };
  }

  function isHoriz(side) { return side === 'left' || side === 'right'; }

  // ── Phase 1: Deduplicate peering pairs ──

  const pairs = [];
  const drawn = new Set();
  lk.peerings.forEach(peer => {
    if (!peer.remoteVirtualNetwork || !peer.remoteVirtualNetwork.id) return;
    const remoteId = peer.remoteVirtualNetwork.id;
    let sourceId = null;
    if (peer.id) {
      const parts = peer.id.split('/');
      const idx = parts.indexOf('virtualNetworks');
      if (idx >= 0) sourceId = parts.slice(0, idx + 2).join('/');
    }
    if (!sourceId) return;
    const key = [sourceId, remoteId].sort().join('|');
    if (drawn.has(key)) return;
    drawn.add(key);
    if (!boxes[sourceId] || !boxes[remoteId]) return;
    pairs.push({ sourceId, remoteId });
  });

  // ── Phase 2: Assign sides & collect used ports ──

  const usedPorts = {}; // { vnetId|side : true }
  pairs.forEach(p => {
    p.srcSide = facingSide(boxes[p.sourceId], boxes[p.remoteId]);
    p.dstSide = facingSide(boxes[p.remoteId], boxes[p.sourceId]);
    usedPorts[p.sourceId + '|' + p.srcSide] = true;
    usedPorts[p.remoteId + '|' + p.dstSide] = true;
  });

  // ── Phase 3: Render connection-port icons (one per used side per VNet) ──

  const portIcons = {}; // track rendered ports so we don't duplicate
  function renderPort(vnetId, side) {
    const pk = vnetId + '|' + side;
    if (portIcons[pk]) return;
    portIcons[pk] = true;
    const pt = connPoint(boxes[vnetId], side);
    const portG = peerG.append('g').attr('class', 'peering-port')
      .attr('transform', `translate(${pt.x},${pt.y})`)
      .on('click', () => {
        const p = lk.peeringsByVnet[vnetId]?.[0];
        if (p) openPeeringPanel(p.id);
      })
      .on('mouseenter', function(event) {
        const vnet = lk.vnetById[vnetId?.toLowerCase()];
        const vName = vnet ? shortName(vnet) : '?';
        const peerList = (lk.peeringsByVnet[vnetId] || []).map(p => {
          const remote = lk.vnetById[(p.remoteVirtualNetwork?.id || '').toLowerCase()];
          return `${esc(p.name || '')} → ${esc(remote ? shortName(remote) : '?')} (${esc(p.peeringState || '?')})`;
        }).join('<br>');
        showTooltip(event, `<div class="tt-title">Peering Gateway</div><div class="tt-sub">${esc(vName)}</div><div class="tt-sec"><div class="tt-sh">Connections</div><div class="tt-r">${peerList}</div></div>`);
      })
      .on('mouseleave', hideTooltip)
      .on('mousemove', moveTooltip);
    portG.append('circle').attr('r', 6)
      .attr('fill', 'var(--peer-color)').attr('fill-opacity', .15)
      .attr('stroke', 'var(--peer-color)').attr('stroke-width', 1.5);
    portG.append('circle').attr('r', 2.5)
      .attr('fill', 'var(--peer-color)');
  }

  // ── Phase 4: Routing helpers ──

  function getObstacles(srcId, dstId) {
    return Object.entries(boxes)
      .filter(([id]) => id !== srcId && id !== dstId)
      .map(([, b]) => pad(b, M));
  }

  // Build initial orthogonal waypoints: port → outset → [bend] → outset → port
  function initialRoute(sp, so, sSide, dp, dout, dSide) {
    const sH = isHoriz(sSide), dH = isHoriz(dSide);
    if (sH && dH) {
      if (Math.abs(so.y - dout.y) < 1) return [sp, so, dout, dp];
      const mx = (so.x + dout.x) / 2;
      return [sp, so, { x: mx, y: so.y }, { x: mx, y: dout.y }, dout, dp];
    }
    if (!sH && !dH) {
      if (Math.abs(so.x - dout.x) < 1) return [sp, so, dout, dp];
      const my = (so.y + dout.y) / 2;
      return [sp, so, { x: so.x, y: my }, { x: dout.x, y: my }, dout, dp];
    }
    if (sH) return [sp, so, { x: dout.x, y: so.y }, dout, dp];
    return [sp, so, { x: so.x, y: dout.y }, dout, dp];
  }

  // Iteratively reroute segments that collide with obstacle boxes
  function avoidObstacles(pts, obs) {
    for (let iter = 0; iter < 8; iter++) {
      let changed = false;
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i], b = pts[i + 1];
        for (const o of obs) {
          if (!segHitsBox(a.x, a.y, b.x, b.y, o)) continue;
          const isH = Math.abs(a.y - b.y) < 1;
          const isV = Math.abs(a.x - b.x) < 1;
          if (isH) {
            const above = o.y - 1, below = o.y + o.h + 1;
            const newY = Math.abs(a.y - above) <= Math.abs(a.y - below) ? above : below;
            pts = [...pts.slice(0, i + 1), { x: a.x, y: newY }, { x: b.x, y: newY }, ...pts.slice(i + 1)];
          } else if (isV) {
            const left = o.x - 1, right = o.x + o.w + 1;
            const newX = Math.abs(a.x - left) <= Math.abs(a.x - right) ? left : right;
            pts = [...pts.slice(0, i + 1), { x: newX, y: a.y }, { x: newX, y: b.y }, ...pts.slice(i + 1)];
          } else {
            pts = [...pts.slice(0, i + 1), { x: b.x, y: a.y }, ...pts.slice(i + 1)];
          }
          changed = true; break;
        }
        if (changed) break;
      }
      if (!changed) break;
    }
    // Collapse duplicate & collinear points
    const clean = [pts[0]];
    for (let i = 1; i < pts.length; i++) {
      const p = pts[i], prev = clean[clean.length - 1];
      if (Math.abs(p.x - prev.x) > 0.5 || Math.abs(p.y - prev.y) > 0.5) clean.push(p);
    }
    const out = [clean[0]];
    for (let i = 1; i < clean.length - 1; i++) {
      const prev = out[out.length - 1], c = clean[i], next = clean[i + 1];
      if (!(Math.abs(prev.x - c.x) < 0.5 && Math.abs(c.x - next.x) < 0.5) &&
          !(Math.abs(prev.y - c.y) < 0.5 && Math.abs(c.y - next.y) < 0.5)) out.push(c);
    }
    out.push(clean[clean.length - 1]);
    return out;
  }

  // SVG path with rounded corners at each waypoint turn
  function toPath(pts) {
    if (pts.length < 2) return '';
    let d = `M${pts[0].x},${pts[0].y}`;
    for (let i = 1; i < pts.length - 1; i++) {
      const prev = pts[i - 1], c = pts[i], next = pts[i + 1];
      const d1 = Math.hypot(c.x - prev.x, c.y - prev.y);
      const d2 = Math.hypot(next.x - c.x, next.y - c.y);
      if (d1 === 0 || d2 === 0) { d += ` L${c.x},${c.y}`; continue; }
      const r = Math.min(R, d1 / 2, d2 / 2);
      d += ` L${c.x - (c.x - prev.x) / d1 * r},${c.y - (c.y - prev.y) / d1 * r}`;
      d += ` Q${c.x},${c.y} ${c.x + (next.x - c.x) / d2 * r},${c.y + (next.y - c.y) / d2 * r}`;
    }
    d += ` L${pts[pts.length - 1].x},${pts[pts.length - 1].y}`;
    return d;
  }

  // Walk half the total path length for label placement
  function pathMidpoint(pts) {
    let total = 0;
    const segs = [];
    for (let i = 0; i < pts.length - 1; i++) {
      const len = Math.hypot(pts[i + 1].x - pts[i].x, pts[i + 1].y - pts[i].y);
      segs.push({ i, len }); total += len;
    }
    let walk = total / 2;
    for (const s of segs) {
      if (walk <= s.len) {
        const t = s.len > 0 ? walk / s.len : 0;
        return { x: pts[s.i].x + (pts[s.i + 1].x - pts[s.i].x) * t,
                 y: pts[s.i].y + (pts[s.i + 1].y - pts[s.i].y) * t };
      }
      walk -= s.len;
    }
    return { x: pts[pts.length - 1].x, y: pts[pts.length - 1].y };
  }

  // ── Phase 5: Route & render each peering ──

  pairs.forEach(({ sourceId, remoteId, srcSide, dstSide }) => {
    const src = boxes[sourceId], dst = boxes[remoteId];
    const sp = connPoint(src, srcSide);
    const dp = connPoint(dst, dstSide);
    const so = stepOut(sp, srcSide);
    const dout = stepOut(dp, dstSide);
    const raw = initialRoute(sp, so, srcSide, dp, dout, dstSide);
    const pts = avoidObstacles(raw, getObstacles(sourceId, remoteId));

    peerG.append('path')
      .attr('class', 'peering-line')
      .attr('d', toPath(pts))
      .attr('stroke', 'var(--peer-color)');

    // Render port icons (once per side per VNet)
    renderPort(sourceId, srcSide);
    renderPort(remoteId, dstSide);

    // Label at path midpoint
    const mid = pathMidpoint(pts);
    peerG.append('text')
      .attr('x', mid.x).attr('y', mid.y - 8)
      .attr('text-anchor', 'middle')
      .attr('fill', 'var(--peer-color)')
      .attr('font-family', "'IBM Plex Mono',monospace")
      .attr('font-size', 'calc(8px * var(--txt-scale))')
      .text('PEERING');
  });
}

// ============================================================
// TOOLTIP HELPERS
// ============================================================

function showTooltip(event, html) {
  const tt = document.getElementById('tooltip');
  tt.innerHTML = html;
  tt.style.display = 'block';
  moveTooltip(event);
}

function moveTooltip(event) {
  const tt = document.getElementById('tooltip');
  const mainEl = document.querySelector('.main');
  const rect = mainEl.getBoundingClientRect();
  let x = event.clientX - rect.left + 16;
  let y = event.clientY - rect.top + 16;
  // Keep tooltip within viewport
  if (x + tt.offsetWidth > rect.width - 10) x = event.clientX - rect.left - tt.offsetWidth - 10;
  if (y + tt.offsetHeight > rect.height - 10) y = event.clientY - rect.top - tt.offsetHeight - 10;
  tt.style.left = x + 'px';
  tt.style.top = y + 'px';
}

function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

// ============================================================
// DETAIL PANELS
// ============================================================

function openDetailPanel(title, subtitle, bodyHtml) {
  const panel = document.getElementById('detailPanel');
  document.getElementById('dpTitle').innerHTML = title;
  document.getElementById('dpSub').innerHTML = subtitle;
  document.getElementById('dpBody').innerHTML = bodyHtml;
  panel.classList.add('open');

  // Bind collapsible section headers
  panel.querySelectorAll('.dp-sec-hdr').forEach(hdr => {
    hdr.addEventListener('click', () => {
      hdr.classList.toggle('collapsed');
      const body = hdr.nextElementSibling;
      if (body) body.classList.toggle('hidden');
    });
  });

  // Bind copyable elements
  panel.querySelectorAll('.copyable').forEach(el => {
    el.addEventListener('click', () => copyText(el.textContent));
  });
}

// ---- Subnet Detail Panel ----
function openSubnetPanel(sub, vnet, lk) {
  const subId = sub.id ? sub.id.toLowerCase() : '';
  const subName = shortName(sub);
  const vnetName = shortName(vnet);
  const cidr = sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]) || 'N/A';
  const isPub = isSubnetPublic(sub.id, lk);

  let html = '';

  // Overview section
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(subName)}</span></div>`;
  html += `<div class="dp-kv"><span class="k">VNet</span><span class="v copyable">${esc(vnetName)}</span></div>`;
  html += `<div class="dp-kv"><span class="k">CIDR</span><span class="v copyable">${esc(cidr)}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Type</span><span class="v">${isPub ? '<span class="i">PUBLIC</span>' : '<span class="s">PRIVATE</span>'}</span></div>`;
  if (sub.id) {
    const parsed = parseResourceId(sub.id);
    if (parsed) {
      html += `<div class="dp-kv"><span class="k">Resource Group</span><span class="v copyable">${esc(parsed.resourceGroup)}</span></div>`;
      html += `<div class="dp-kv"><span class="k">Subscription</span><span class="v copyable">${esc(parsed.subscriptionId)}</span></div>`;
    }
  }
  // Usable IPs
  const parsed = parseCIDR(cidr);
  if (parsed) {
    html += `<div class="dp-kv"><span class="k">Total IPs</span><span class="v">${parsed.size}</span></div>`;
    html += `<div class="dp-kv"><span class="k">Usable IPs</span><span class="v">${Math.max(0, parsed.size - 5)}</span></div>`;
  }
  html += `<div class="dp-kv"><span class="k">Resource ID</span><span class="v copyable" style="font-size:9px">${esc(sub.id || 'N/A')}</span></div>`;
  html += `</div></div>`;

  // NSG section
  const nsg = lk.nsgBySubnet[subId];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">NSG (Subnet-Level)</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  if (nsg) {
    html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(nsg))}</span></div>`;
    const rules = (nsg.securityRules || []).sort((a, b) => (a.priority || 9999) - (b.priority || 9999));
    if (rules.length > 0) {
      html += '<div class="fw-visual">';
      rules.forEach(rule => {
        const dir = rule.direction || 'Inbound';
        const access = (rule.access || 'Allow').toLowerCase();
        const proto = rule.protocol || '*';
        const dstPort = rule.destinationPortRange || rule.destinationPortRanges?.join(',') || '*';
        const src = rule.sourceAddressPrefix || rule.sourceAddressPrefixes?.join(',') || '*';
        html += `<div class="fw-rule-bar">`;
        html += `<div class="fw-arrow ${access}"><div class="fw-arrow-line"></div><div class="fw-arrow-head"></div></div>`;
        html += `<span class="fw-port ${access}">${esc(dstPort)}</span>`;
        html += `<span class="fw-proto">${esc(proto)}</span>`;
        html += `<span style="color:var(--text-secondary);font-size:8px">${esc(dir)} P:${rule.priority || '?'}</span>`;
        html += `<span class="fw-src">${esc(src)}</span>`;
        html += `</div>`;
      });
      html += '</div>';
    } else {
      html += '<div class="dp-empty">Default rules only</div>';
    }
  } else {
    html += '<div class="dp-empty">No NSG attached</div>';
  }
  html += `</div></div>`;

  // Route Table section
  const rt = lk.rtBySubnet[subId];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Route Table</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  if (rt) {
    html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(rt))}</span></div>`;
    const routes = rt.routes || [];
    routes.forEach(route => {
      html += `<div class="dp-row"><span class="lbl">${esc(route.name || '')}</span>`;
      html += `<span class="val">${esc(route.addressPrefix || '')} &rarr; ${esc(route.nextHopType || '')}`;
      if (route.nextHopIpAddress) html += ` (${esc(route.nextHopIpAddress)})`;
      html += `</span></div>`;
    });
    if (routes.length === 0) html += '<div class="dp-empty">No custom routes</div>';
  } else {
    html += '<div class="dp-empty">System routes only (no UDR)</div>';
  }
  html += `</div></div>`;

  // Resources section
  const vms = lk.vmsBySubnet[subId] || [];
  const pes = lk.pesBySubnet[subId] || [];
  const agws = lk.appGwBySubnet[subId] || [];
  const lbs = lk.lbBySubnet[subId] || [];
  const funcs = lk.funcBySubnet[subId] || [];
  const totalRes = vms.length + pes.length + agws.length + lbs.length + funcs.length;

  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Resources</span><span class="dp-sec-count">${totalRes}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;

  vms.forEach(vm => {
    const powerState = vm.powerState || '';
    const badge = powerState.includes('running') ? '<span class="dp-badge running">Running</span>' :
                  powerState.includes('deallocated') ? '<span class="dp-badge stopped">Deallocated</span>' : '';
    html += `<div class="dp-row" style="cursor:pointer" onclick="openVMPanel('${esc(vm.id)}')">`;
    html += `<span class="lbl">VM</span><span class="val">${esc(shortName(vm))} ${badge}</span>`;
    if (vm.hardwareProfile) html += `<span class="lbl">${esc(vm.hardwareProfile.vmSize || '')}</span>`;
    html += `</div>`;
  });

  pes.forEach(pe => {
    const svc = pe.privateLinkServiceConnections?.[0]?.privateLinkServiceId || '';
    html += `<div class="dp-row"><span class="lbl">Private Endpoint</span><span class="val">${esc(shortName(pe))}</span>`;
    if (svc) html += `<span class="lbl" style="font-size:8px">${esc(shortName(svc))}</span>`;
    html += `</div>`;
  });

  agws.forEach(agw => {
    html += `<div class="dp-row"><span class="lbl">App Gateway</span><span class="val">${esc(shortName(agw))}</span></div>`;
  });

  lbs.forEach(lb => {
    const skuName = lb.sku?.name || '';
    html += `<div class="dp-row"><span class="lbl">Load Balancer</span><span class="val">${esc(shortName(lb))} <span class="lbl">${esc(skuName)}</span></span></div>`;
  });

  funcs.forEach(fa => {
    html += `<div class="dp-row"><span class="lbl">Function App</span><span class="val">${esc(shortName(fa))}</span></div>`;
  });

  if (totalRes === 0) html += '<div class="dp-empty">No resources in this subnet</div>';
  html += `</div></div>`;

  // NAT Gateway section
  const nat = lk.natBySubnet[subId];
  if (nat) {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">NAT Gateway</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(nat))}</span></div>`;
    if (nat.publicIpAddresses) {
      nat.publicIpAddresses.forEach(pipRef => {
        const pip = pipRef.id ? lk.publicIpById[pipRef.id.toLowerCase()] : null;
        html += `<div class="dp-kv"><span class="k">Public IP</span><span class="v copyable">${esc(pip ? pip.ipAddress || shortName(pip) : shortName(pipRef))}</span></div>`;
      });
    }
    html += `</div></div>`;
  }

  openDetailPanel(
    esc(subName) + (isPub ? ' <span class="dp-badge pub">PUBLIC</span>' : ' <span class="dp-badge prv">PRIVATE</span>'),
    `Subnet in ${esc(vnetName)} | ${esc(cidr)}`,
    html
  );
}

// ---- VM Detail Panel ----
function openVMPanel(vmId) {
  const vm = _lk.vmById[vmId.toLowerCase()];
  if (!vm) return;

  let html = '';

  // Overview
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(vm))}</span></div>`;
  if (vm.hardwareProfile) html += `<div class="dp-kv"><span class="k">Size</span><span class="v">${esc(vm.hardwareProfile.vmSize || '')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">State</span><span class="v">${esc(vm.powerState || 'unknown')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(vm.location || '')}</span></div>`;
  if (vm.zones?.length) html += `<div class="dp-kv"><span class="k">Zone(s)</span><span class="v">${esc(vm.zones.join(', '))}</span></div>`;
  if (vm.id) {
    const p = parseResourceId(vm.id);
    if (p) html += `<div class="dp-kv"><span class="k">Resource Group</span><span class="v copyable">${esc(p.resourceGroup)}</span></div>`;
  }
  html += `<div class="dp-kv"><span class="k">Resource ID</span><span class="v copyable" style="font-size:9px">${esc(vm.id || '')}</span></div>`;
  html += `</div></div>`;

  // Network Interfaces
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Network Interfaces</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  if (vm.networkProfile?.networkInterfaces) {
    vm.networkProfile.networkInterfaces.forEach(nicRef => {
      const nic = nicRef.id ? _lk.nicById[nicRef.id.toLowerCase()] : null;
      if (nic) {
        html += `<div class="dp-row"><span class="lbl">NIC</span><span class="val copyable">${esc(shortName(nic))}</span></div>`;
        (nic.ipConfigurations || []).forEach(ipc => {
          html += `<div class="dp-kv"><span class="k">Private IP</span><span class="v copyable">${esc(ipc.privateIpAddress || '')}</span></div>`;
          if (ipc.publicIpAddress?.id) {
            const pip = _lk.publicIpById[ipc.publicIpAddress.id.toLowerCase()];
            html += `<div class="dp-kv"><span class="k">Public IP</span><span class="v copyable i">${esc(pip?.ipAddress || shortName(ipc.publicIpAddress))}</span></div>`;
          }
          if (ipc.subnet?.id) {
            html += `<div class="dp-kv"><span class="k">Subnet</span><span class="v copyable">${esc(shortName(ipc.subnet.id))}</span></div>`;
          }
        });
        // NIC-level NSG
        const nicNsg = _lk.nsgByNic[nic.id.toLowerCase()];
        if (nicNsg) {
          html += `<div class="dp-kv"><span class="k">NSG (NIC)</span><span class="v a">${esc(shortName(nicNsg))}</span></div>`;
        }
      } else {
        html += `<div class="dp-row"><span class="lbl">NIC</span><span class="val">${esc(shortName(nicRef.id || ''))}</span></div>`;
      }
    });
  }
  html += `</div></div>`;

  // Disks
  const disks = _lk.disksByVm[vm.id?.toLowerCase()] || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Disks</span><span class="dp-sec-count">${disks.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  if (vm.storageProfile?.osDisk) {
    const od = vm.storageProfile.osDisk;
    html += `<div class="dp-row"><span class="lbl">OS Disk</span><span class="val">${esc(od.name || '')} (${esc(od.osType || '')}${od.diskSizeGb ? ', ' + od.diskSizeGb + ' GB' : ''})</span></div>`;
  }
  disks.forEach(d => {
    html += `<div class="dp-row"><span class="lbl">Data Disk</span><span class="val">${esc(shortName(d))} (${esc(d.sku?.name || '')}${d.diskSizeGb ? ', ' + d.diskSizeGb + ' GB' : ''})</span></div>`;
  });
  if (disks.length === 0 && !vm.storageProfile?.osDisk) html += '<div class="dp-empty">No disk information</div>';
  html += `</div></div>`;

  const powerState = vm.powerState || '';
  const badge = powerState.includes('running') ? '<span class="dp-badge running">Running</span>' :
                powerState.includes('deallocated') ? '<span class="dp-badge stopped">Deallocated</span>' : '';

  openDetailPanel(
    esc(shortName(vm)) + ' ' + badge,
    `Virtual Machine | ${esc(vm.hardwareProfile?.vmSize || '')} | ${esc(vm.location || '')}`,
    html
  );
}

// ---- NSG Detail Panel ----
function openNSGPanel(nsgId) {
  const nsg = _lk.nsgById[nsgId.toLowerCase()];
  if (!nsg) return;

  let html = '';

  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(nsg))}</span></div>`;
  if (nsg.id) {
    const p = parseResourceId(nsg.id);
    if (p) {
      html += `<div class="dp-kv"><span class="k">Resource Group</span><span class="v copyable">${esc(p.resourceGroup)}</span></div>`;
    }
  }
  // Attached subnets
  const attachedSubnets = (nsg.subnets || []).map(s => shortName(s.id || s));
  if (attachedSubnets.length) {
    html += `<div class="dp-kv"><span class="k">Subnets</span><span class="v">${attachedSubnets.map(s => esc(s)).join(', ')}</span></div>`;
  }
  // Attached NICs
  const attachedNics = (nsg.networkInterfaces || []).map(n => shortName(n.id || n));
  if (attachedNics.length) {
    html += `<div class="dp-kv"><span class="k">NICs</span><span class="v">${attachedNics.map(n => esc(n)).join(', ')}</span></div>`;
  }
  html += `</div></div>`;

  // Inbound rules
  const allRules = (nsg.securityRules || []).sort((a, b) => (a.priority || 9999) - (b.priority || 9999));
  const inbound = allRules.filter(r => (r.direction || '').toLowerCase() === 'inbound');
  const outbound = allRules.filter(r => (r.direction || '').toLowerCase() === 'outbound');

  ['Inbound', 'Outbound'].forEach(dir => {
    const rules = dir === 'Inbound' ? inbound : outbound;
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">${dir} Rules</span><span class="dp-sec-count">${rules.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    if (rules.length > 0) {
      html += '<div class="fw-visual">';
      rules.forEach(rule => {
        const access = (rule.access || 'Allow').toLowerCase();
        const proto = rule.protocol || '*';
        const dstPort = rule.destinationPortRange || rule.destinationPortRanges?.join(',') || '*';
        const src = rule.sourceAddressPrefix || rule.sourceAddressPrefixes?.join(',') || '*';
        const dst = rule.destinationAddressPrefix || rule.destinationAddressPrefixes?.join(',') || '*';
        html += `<div class="fw-rule-bar">`;
        html += `<div class="fw-arrow ${access}"><div class="fw-arrow-line"></div><div class="fw-arrow-head"></div></div>`;
        html += `<span class="fw-port ${access}">${esc(dstPort)}</span>`;
        html += `<span class="fw-proto">${esc(proto)}</span>`;
        html += `<span style="color:var(--text-secondary);font-size:8px">P:${rule.priority || '?'} ${esc(rule.name || '')}</span>`;
        html += `<span class="fw-src">${esc(src)}</span>`;
        html += `</div>`;
      });
      html += '</div>';
    } else {
      html += '<div class="dp-empty">No custom rules</div>';
    }
    html += `</div></div>`;
  });

  // Default rules
  const defaults = nsg.defaultSecurityRules || [];
  if (defaults.length > 0) {
    html += `<div class="dp-section"><div class="dp-sec-hdr collapsed"><span class="dp-sec-title">Default Rules</span><span class="dp-sec-count">${defaults.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body hidden">`;
    html += '<div class="fw-visual">';
    defaults.forEach(rule => {
      const access = (rule.access || 'Allow').toLowerCase();
      const proto = rule.protocol || '*';
      const dstPort = rule.destinationPortRange || '*';
      const src = rule.sourceAddressPrefix || '*';
      html += `<div class="fw-rule-bar">`;
      html += `<div class="fw-arrow ${access}"><div class="fw-arrow-line"></div><div class="fw-arrow-head"></div></div>`;
      html += `<span class="fw-port ${access}">${esc(dstPort)}</span>`;
      html += `<span class="fw-proto">${esc(proto)}</span>`;
      html += `<span style="color:var(--text-muted);font-size:8px">${esc(rule.name || '')}</span>`;
      html += `<span class="fw-src">${esc(src)}</span>`;
      html += `</div>`;
    });
    html += '</div></div></div>';
  }

  openDetailPanel(
    esc(shortName(nsg)),
    `Network Security Group | ${allRules.length} custom rules`,
    html
  );
}

// ---- VNet Detail Panel ----
function openVNetPanel(vnet, lk) {
  const vnetName = shortName(vnet);
  const addressPrefixes = (vnet.addressSpace && vnet.addressSpace.addressPrefixes) || [];
  const subnets = lk.subnetsByVnet[vnet.id] || [];
  const peerings = lk.peeringsByVnet[vnet.id] || [];
  const parsed = vnet.id ? parseResourceId(vnet.id) : null;

  let html = '';

  // Overview
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(vnetName)}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Address Space</span><span class="v copyable">${esc(addressPrefixes.join(', '))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(vnet.location || '')}</span></div>`;
  if (parsed) {
    html += `<div class="dp-kv"><span class="k">Resource Group</span><span class="v copyable">${esc(parsed.resourceGroup)}</span></div>`;
    html += `<div class="dp-kv"><span class="k">Subscription</span><span class="v copyable">${esc(parsed.subscriptionId)}</span></div>`;
  }
  if (vnet.enableDdosProtection) html += `<div class="dp-kv"><span class="k">DDoS Protection</span><span class="v a">Enabled</span></div>`;
  let totalIps = 0;
  addressPrefixes.forEach(p => { const c = parseCIDR(p); if (c) totalIps += c.size });
  html += `<div class="dp-kv"><span class="k">Total IPs</span><span class="v">${totalIps.toLocaleString()}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Subnets</span><span class="v">${subnets.length}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Resource ID</span><span class="v copyable" style="font-size:9px">${esc(vnet.id || '')}</span></div>`;
  html += `</div></div>`;

  // Subnets
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Subnets</span><span class="dp-sec-count">${subnets.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  subnets.forEach(sub => {
    const isPub = isSubnetPublic(sub.id, lk);
    const cidr = sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]) || '';
    const badge = isPub ? '<span class="dp-badge pub">PUB</span>' : '<span class="dp-badge prv">PRV</span>';
    const resCount = countSubnetResources(sub.id, lk);
    html += `<div class="dp-row" style="cursor:pointer" data-act="1" onclick="openSubnetPanel(_lk.subnetById['${esc(sub.id.toLowerCase())}'],_lk.vnetById['${esc(vnet.id.toLowerCase())}'],_lk)">`;
    html += `<span class="val">${esc(shortName(sub))} ${badge}</span>`;
    html += `<span class="lbl">${esc(cidr)} | ${resCount} resources</span>`;
    html += `</div>`;
  });
  if (subnets.length === 0) html += '<div class="dp-empty">No subnets</div>';
  html += `</div></div>`;

  // Peerings
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Peerings</span><span class="dp-sec-count">${peerings.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  peerings.forEach(p => {
    const remoteName = p.remoteVirtualNetwork ? shortName(p.remoteVirtualNetwork.id) : '?';
    const state = p.peeringState || 'Unknown';
    const stateClass = state === 'Connected' ? 'a' : 'd';
    html += `<div class="dp-row">`;
    html += `<span class="val">${esc(p.name || remoteName)}</span>`;
    html += `<span class="lbl">Remote: ${esc(remoteName)} | <span class="${stateClass}">${esc(state)}</span></span>`;
    let flags = [];
    if (p.allowVirtualNetworkAccess) flags.push('VNet Access');
    if (p.allowForwardedTraffic) flags.push('Forwarding');
    if (p.allowGatewayTransit) flags.push('GW Transit');
    if (p.useRemoteGateways) flags.push('Use Remote GW');
    if (flags.length) html += `<span class="lbl" style="font-size:8px">${flags.join(' | ')}</span>`;
    html += `</div>`;
  });
  if (peerings.length === 0) html += '<div class="dp-empty">No peerings</div>';
  html += `</div></div>`;

  openDetailPanel(esc(vnetName), `Virtual Network | ${esc(addressPrefixes.join(', '))} | ${esc(vnet.location || '')}`, html);
}

// ---- NIC Detail Panel ----
function openNICPanel(nicId) {
  const nic = _lk.nicById[nicId.toLowerCase()];
  if (!nic) return;
  const vm = _lk.vmsByNic[nicId.toLowerCase()];
  const nicNsg = _lk.nsgByNic[nicId.toLowerCase()];

  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(nic))}</span></div>`;
  if (nic.macAddress) html += `<div class="dp-kv"><span class="k">MAC</span><span class="v copyable">${esc(nic.macAddress)}</span></div>`;
  if (vm) html += `<div class="dp-kv"><span class="k">VM</span><span class="v" style="cursor:pointer;color:var(--accent-cyan)" onclick="openVMPanel('${esc(vm.id)}')">${esc(shortName(vm))}</span></div>`;
  if (nic.id) { const p = parseResourceId(nic.id); if (p) html += `<div class="dp-kv"><span class="k">Resource Group</span><span class="v copyable">${esc(p.resourceGroup)}</span></div>` }
  html += `<div class="dp-kv"><span class="k">Resource ID</span><span class="v copyable" style="font-size:9px">${esc(nic.id || '')}</span></div>`;
  html += `</div></div>`;

  // IP Configurations
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">IP Configurations</span><span class="dp-sec-count">${(nic.ipConfigurations||[]).length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  (nic.ipConfigurations || []).forEach(ipc => {
    html += `<div class="dp-kv"><span class="k">Config</span><span class="v">${esc(ipc.name || 'ipconfig')}${ipc.primary ? ' <span class="dp-badge running">PRIMARY</span>' : ''}</span></div>`;
    html += `<div class="dp-kv"><span class="k">Private IP</span><span class="v copyable">${esc(ipc.privateIpAddress || '')}</span></div>`;
    if (ipc.publicIpAddress?.id) {
      const pip = _lk.publicIpById[ipc.publicIpAddress.id.toLowerCase()];
      html += `<div class="dp-kv"><span class="k">Public IP</span><span class="v copyable i">${esc(pip?.ipAddress || shortName(ipc.publicIpAddress))}</span></div>`;
    }
    if (ipc.subnet?.id) html += `<div class="dp-kv"><span class="k">Subnet</span><span class="v copyable">${esc(shortName(ipc.subnet.id))}</span></div>`;
  });
  html += `</div></div>`;

  // NSG
  if (nicNsg) {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">NSG (NIC-Level)</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    html += `<div class="dp-kv"><span class="k">Name</span><span class="v" style="cursor:pointer;color:var(--accent-cyan)" onclick="openNSGPanel('${esc(nicNsg.id || '')}')">${esc(shortName(nicNsg))}</span></div>`;
    html += `</div></div>`;
  }

  openDetailPanel(esc(shortName(nic)), `Network Interface${vm ? ' | Attached to ' + esc(shortName(vm)) : ''}`, html);
}

// ---- App Gateway Detail Panel ----
function openAppGwPanel(agwId) {
  const agw = _lk.appGateways.find(a => a.id && a.id.toLowerCase() === agwId.toLowerCase());
  if (!agw) return;
  let html = '';

  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(agw))}</span></div>`;
  if (agw.sku) html += `<div class="dp-kv"><span class="k">SKU</span><span class="v">${esc(agw.sku.name || '')} / ${esc(agw.sku.tier || '')}${agw.sku.capacity ? ' x' + agw.sku.capacity : ''}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(agw.location || '')}</span></div>`;
  html += `</div></div>`;

  // Frontend IPs
  const feIps = agw.frontendIPConfigurations || agw.frontendIpConfigurations || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Frontend IPs</span><span class="dp-sec-count">${feIps.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  feIps.forEach(fe => {
    if (fe.publicIpAddress?.id) {
      const pip = _lk.publicIpById[(fe.publicIpAddress.id || '').toLowerCase()];
      html += `<div class="dp-kv"><span class="k">Public</span><span class="v i copyable">${esc(pip?.ipAddress || shortName(fe.publicIpAddress))}</span></div>`;
    }
    if (fe.privateIPAddress) html += `<div class="dp-kv"><span class="k">Private</span><span class="v copyable">${esc(fe.privateIPAddress)}</span></div>`;
  });
  html += `</div></div>`;

  // Backend Pools
  const pools = agw.backendAddressPools || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Backend Pools</span><span class="dp-sec-count">${pools.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  pools.forEach(pool => {
    html += `<div class="dp-row"><span class="lbl">${esc(pool.name || '')}</span>`;
    const addrs = pool.backendAddresses || [];
    addrs.forEach(a => { html += `<span class="val">${esc(a.ipAddress || a.fqdn || '')}</span> ` });
    html += `</div>`;
  });
  html += `</div></div>`;

  // Listeners
  const listeners = agw.httpListeners || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">HTTP Listeners</span><span class="dp-sec-count">${listeners.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  listeners.forEach(l => {
    html += `<div class="dp-row"><span class="val">${esc(l.name || '')} | ${esc(l.protocol || '')}:${l.port || ''}</span>`;
    if (l.hostName) html += `<span class="lbl">${esc(l.hostName)}</span>`;
    html += `</div>`;
  });
  if (listeners.length === 0) html += '<div class="dp-empty">No listeners configured</div>';
  html += `</div></div>`;

  openDetailPanel(esc(shortName(agw)), `Application Gateway | ${esc(agw.sku?.name || '')}`, html);
}

// ---- Load Balancer Detail Panel ----
function openLBPanel(lbId) {
  const lb = _lk.loadBalancers.find(l => l.id && l.id.toLowerCase() === lbId.toLowerCase());
  if (!lb) return;
  let html = '';
  const skuName = lb.sku?.name || 'Basic';

  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(lb))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">SKU</span><span class="v">${esc(skuName)}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(lb.location || '')}</span></div>`;
  html += `</div></div>`;

  // Frontend IPs
  const feIps = lb.frontendIPConfigurations || lb.frontendIpConfigurations || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Frontend IPs</span><span class="dp-sec-count">${feIps.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  feIps.forEach(fe => {
    const type = fe.publicIpAddress ? 'Public' : 'Internal';
    if (fe.publicIpAddress?.id) {
      const pip = _lk.publicIpById[(fe.publicIpAddress.id || '').toLowerCase()];
      html += `<div class="dp-kv"><span class="k">${type}</span><span class="v i copyable">${esc(pip?.ipAddress || shortName(fe.publicIpAddress))}</span></div>`;
    } else if (fe.privateIPAddress) {
      html += `<div class="dp-kv"><span class="k">${type}</span><span class="v copyable">${esc(fe.privateIPAddress)}</span></div>`;
    }
  });
  html += `</div></div>`;

  // Backend Pools
  const pools = lb.backendAddressPools || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Backend Pools</span><span class="dp-sec-count">${pools.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  pools.forEach(pool => {
    const addrs = pool.loadBalancerBackendAddresses || pool.backendAddresses || [];
    html += `<div class="dp-row"><span class="lbl">${esc(pool.name || '')}</span><span class="val">${addrs.length} targets</span></div>`;
  });
  html += `</div></div>`;

  // LB Rules
  const rules = lb.loadBalancingRules || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Rules</span><span class="dp-sec-count">${rules.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  rules.forEach(r => {
    html += `<div class="dp-row"><span class="val">${esc(r.name || '')} | ${esc(r.protocol || '')}:${r.frontendPort || ''}&#8594;${r.backendPort || ''}</span></div>`;
  });
  if (rules.length === 0) html += '<div class="dp-empty">No rules</div>';
  html += `</div></div>`;

  // Health Probes
  const probes = lb.probes || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Health Probes</span><span class="dp-sec-count">${probes.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  probes.forEach(p => {
    html += `<div class="dp-row"><span class="val">${esc(p.name || '')} | ${esc(p.protocol || '')}:${p.port || ''} every ${p.intervalInSeconds || '?'}s</span></div>`;
  });
  html += `</div></div>`;

  openDetailPanel(esc(shortName(lb)), `Load Balancer | ${esc(skuName)}`, html);
}

// ---- Firewall Detail Panel ----
function openFirewallPanel(fwId) {
  const fw = _lk.firewalls.find(f => f.id && f.id.toLowerCase() === fwId.toLowerCase());
  if (!fw) return;
  let html = '';

  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(fw))}</span></div>`;
  if (fw.sku) html += `<div class="dp-kv"><span class="k">SKU</span><span class="v">${esc(fw.sku.name || '')} / ${esc(fw.sku.tier || '')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Threat Intel</span><span class="v">${esc(fw.threatIntelMode || 'Off')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(fw.location || '')}</span></div>`;
  if (fw.firewallPolicy?.id) html += `<div class="dp-kv"><span class="k">Policy</span><span class="v copyable">${esc(shortName(fw.firewallPolicy.id))}</span></div>`;
  html += `</div></div>`;

  // IP Configs
  const ipConfigs = fw.ipConfigurations || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">IP Configurations</span><span class="dp-sec-count">${ipConfigs.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  ipConfigs.forEach(c => {
    if (c.subnet?.id) html += `<div class="dp-kv"><span class="k">Subnet</span><span class="v copyable">${esc(shortName(c.subnet.id))}</span></div>`;
    if (c.publicIPAddress?.id) {
      const pip = _lk.publicIpById[(c.publicIPAddress.id || '').toLowerCase()];
      html += `<div class="dp-kv"><span class="k">Public IP</span><span class="v i copyable">${esc(pip?.ipAddress || shortName(c.publicIPAddress))}</span></div>`;
    }
  });
  html += `</div></div>`;

  openDetailPanel(esc(shortName(fw)), `Azure Firewall | ${esc(fw.sku?.tier || '')}`, html);
}

// ---- Bastion Detail Panel ----
function openBastionPanel(bastionId) {
  const b = _lk.bastions.find(x => x.id && x.id.toLowerCase() === bastionId.toLowerCase());
  if (!b) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(b))}</span></div>`;
  if (b.sku) html += `<div class="dp-kv"><span class="k">SKU</span><span class="v">${esc(b.sku.name || '')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(b.location || '')}</span></div>`;
  const ipConfigs = b.ipConfigurations || [];
  ipConfigs.forEach(c => {
    if (c.subnet?.id) html += `<div class="dp-kv"><span class="k">Subnet</span><span class="v copyable">${esc(shortName(c.subnet.id))}</span></div>`;
    if (c.publicIPAddress?.id) {
      const pip = _lk.publicIpById[(c.publicIPAddress.id || '').toLowerCase()];
      html += `<div class="dp-kv"><span class="k">Public IP</span><span class="v i copyable">${esc(pip?.ipAddress || shortName(c.publicIPAddress))}</span></div>`;
    }
  });
  html += `</div></div>`;
  openDetailPanel(esc(shortName(b)), 'Azure Bastion', html);
}

// ---- NAT Gateway Detail Panel ----
function openNATPanel(natId) {
  const nat = _lk.natGateways.find(n => n.id && n.id.toLowerCase() === natId.toLowerCase());
  if (!nat) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(nat))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Idle Timeout</span><span class="v">${nat.idleTimeoutInMinutes || 4} min</span></div>`;
  if (nat.zones?.length) html += `<div class="dp-kv"><span class="k">Zones</span><span class="v">${esc(nat.zones.join(', '))}</span></div>`;
  html += `</div></div>`;

  // Public IPs
  const pips = nat.publicIpAddresses || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Public IPs</span><span class="dp-sec-count">${pips.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  pips.forEach(ref => {
    const pip = ref.id ? _lk.publicIpById[ref.id.toLowerCase()] : null;
    html += `<div class="dp-kv"><span class="k">IP</span><span class="v i copyable">${esc(pip?.ipAddress || shortName(ref))}</span></div>`;
  });
  html += `</div></div>`;

  // Associated Subnets
  const subs = nat.subnets || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Subnets</span><span class="dp-sec-count">${subs.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  subs.forEach(s => { html += `<div class="dp-row"><span class="val copyable">${esc(shortName(s.id || s))}</span></div>` });
  html += `</div></div>`;

  openDetailPanel(esc(shortName(nat)), 'NAT Gateway', html);
}

// ---- Public IP Detail Panel ----
function openPublicIPPanel(pipId) {
  const pip = _lk.publicIpById[pipId.toLowerCase()];
  if (!pip) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(pip))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">IP Address</span><span class="v i copyable">${esc(pip.ipAddress || 'Not assigned')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Allocation</span><span class="v">${esc(pip.publicIpAllocationMethod || '')}</span></div>`;
  if (pip.sku) html += `<div class="dp-kv"><span class="k">SKU</span><span class="v">${esc(pip.sku.name || '')}</span></div>`;
  if (pip.zones?.length) html += `<div class="dp-kv"><span class="k">Zones</span><span class="v">${esc(pip.zones.join(', '))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(pip.location || '')}</span></div>`;
  html += `</div></div>`;
  openDetailPanel(esc(shortName(pip)), `Public IP | ${esc(pip.ipAddress || 'Unassigned')}`, html);
}

// ---- Route Table Detail Panel ----
function openRouteTablePanel(rtId) {
  const rt = _lk.rtById[rtId.toLowerCase()];
  if (!rt) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(rt))}</span></div>`;
  if (rt.disableBgpRoutePropagation !== undefined) html += `<div class="dp-kv"><span class="k">BGP Propagation</span><span class="v">${rt.disableBgpRoutePropagation ? '<span class="d">Disabled</span>' : '<span class="a">Enabled</span>'}</span></div>`;
  html += `</div></div>`;

  const routes = rt.routes || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Routes</span><span class="dp-sec-count">${routes.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  routes.forEach(r => {
    html += `<div class="dp-row"><span class="lbl">${esc(r.name || '')}</span>`;
    html += `<span class="val">${esc(r.addressPrefix || '')} &rarr; ${esc(r.nextHopType || '')}`;
    if (r.nextHopIpAddress) html += ` (${esc(r.nextHopIpAddress)})`;
    html += `</span></div>`;
  });
  if (routes.length === 0) html += '<div class="dp-empty">No routes defined</div>';
  html += `</div></div>`;

  // Associated Subnets
  const subs = rt.subnets || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Associated Subnets</span><span class="dp-sec-count">${subs.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  subs.forEach(s => { html += `<div class="dp-row"><span class="val copyable">${esc(shortName(s.id || s))}</span></div>` });
  if (subs.length === 0) {
    // Check lookup for subnets using this RT
    let found = 0;
    for (const [subId, subRt] of Object.entries(_lk.rtBySubnet)) {
      if (subRt && subRt.id && subRt.id.toLowerCase() === rt.id.toLowerCase()) {
        html += `<div class="dp-row"><span class="val copyable">${esc(shortName(subId))}</span></div>`;
        found++;
      }
    }
    if (found === 0) html += '<div class="dp-empty">No subnets associated</div>';
  }
  html += `</div></div>`;

  openDetailPanel(esc(shortName(rt)), `Route Table | ${routes.length} routes`, html);
}

// ---- Private Endpoint Detail Panel ----
function openPEPanel(peId) {
  const pe = _lk.privateEndpoints.find(p => p.id && p.id.toLowerCase() === peId.toLowerCase());
  if (!pe) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(pe))}</span></div>`;
  if (pe.subnet?.id) html += `<div class="dp-kv"><span class="k">Subnet</span><span class="v copyable">${esc(shortName(pe.subnet.id))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(pe.location || '')}</span></div>`;
  html += `</div></div>`;

  const conns = pe.privateLinkServiceConnections || [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Private Link Connections</span><span class="dp-sec-count">${conns.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  conns.forEach(c => {
    html += `<div class="dp-row"><span class="lbl">${esc(c.name || '')}</span>`;
    if (c.privateLinkServiceId) html += `<span class="val copyable" style="font-size:9px">${esc(shortName(c.privateLinkServiceId))}</span>`;
    if (c.groupIds?.length) html += `<span class="lbl">Groups: ${esc(c.groupIds.join(', '))}</span>`;
    html += `</div>`;
  });
  html += `</div></div>`;

  const dns = pe.customDnsConfigs || [];
  if (dns.length > 0) {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">DNS</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    dns.forEach(d => {
      html += `<div class="dp-kv"><span class="k">${esc(d.fqdn || '')}</span><span class="v copyable">${esc((d.ipAddresses || []).join(', '))}</span></div>`;
    });
    html += `</div></div>`;
  }

  openDetailPanel(esc(shortName(pe)), 'Private Endpoint', html);
}

// ---- Storage Account Detail Panel ----
function openStoragePanel(saId) {
  const sa = _lk.storageAccounts.find(s => s.id && s.id.toLowerCase() === saId.toLowerCase());
  if (!sa) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(sa))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Location</span><span class="v">${esc(sa.location || '')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Min TLS</span><span class="v">${esc(sa.minimumTlsVersion || '')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Public Blob Access</span><span class="v">${sa.allowBlobPublicAccess ? '<span class="d">Enabled</span>' : '<span class="a">Disabled</span>'}</span></div>`;
  html += `</div></div>`;

  // Network Rules
  const nr = sa.networkRuleSet || sa.networkAcls || {};
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Network Rules</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Default Action</span><span class="v">${(nr.defaultAction || 'Allow') === 'Deny' ? '<span class="a">Deny</span>' : '<span class="d">Allow</span>'}</span></div>`;
  const vnRules = nr.virtualNetworkRules || [];
  vnRules.forEach(r => { html += `<div class="dp-row"><span class="lbl">VNet Rule</span><span class="val copyable">${esc(shortName(r.id || r.virtualNetworkResourceId || ''))}</span></div>` });
  const ipRules = nr.ipRules || [];
  ipRules.forEach(r => { html += `<div class="dp-row"><span class="lbl">IP Rule</span><span class="val">${esc(r.ipAddressOrRange || r.value || '')}</span></div>` });
  html += `</div></div>`;

  openDetailPanel(esc(shortName(sa)), 'Storage Account', html);
}

// ---- SQL Server Detail Panel ----
function openSQLPanel(sqlId) {
  const sql = _lk.sqlServers.find(s => s.id && s.id.toLowerCase() === sqlId.toLowerCase());
  if (!sql) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(sql))}</span></div>`;
  if (sql.fullyQualifiedDomainName) html += `<div class="dp-kv"><span class="k">FQDN</span><span class="v copyable">${esc(sql.fullyQualifiedDomainName)}</span></div>`;
  if (sql.administratorLogin) html += `<div class="dp-kv"><span class="k">Admin</span><span class="v">${esc(sql.administratorLogin)}</span></div>`;
  html += `</div></div>`;

  // Databases
  const dbs = sql.name ? _lk.sqlDatabases.filter(d => d.id && d.id.toLowerCase().includes(sql.name.toLowerCase())) : [];
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Databases</span><span class="dp-sec-count">${dbs.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  dbs.forEach(db => {
    html += `<div class="dp-row"><span class="val">${esc(shortName(db))}</span>`;
    if (db.sku) html += `<span class="lbl">${esc(db.sku.name || '')} / ${esc(db.sku.tier || '')}</span>`;
    if (db.status) html += `<span class="dp-badge ${db.status === 'Online' ? 'running' : 'stopped'}">${esc(db.status)}</span>`;
    html += `</div>`;
  });
  if (dbs.length === 0) html += '<div class="dp-empty">No databases found</div>';
  html += `</div></div>`;

  openDetailPanel(esc(shortName(sql)), 'Azure SQL Server', html);
}

// ---- Redis Detail Panel ----
function openRedisPanel(redisId) {
  const r = _lk.redisCaches.find(x => x.id && x.id.toLowerCase() === redisId.toLowerCase());
  if (!r) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(r))}</span></div>`;
  if (r.hostName) html += `<div class="dp-kv"><span class="k">Hostname</span><span class="v copyable">${esc(r.hostName)}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Port</span><span class="v">${r.port || ''} / SSL: ${r.sslPort || ''}</span></div>`;
  if (r.sku) html += `<div class="dp-kv"><span class="k">SKU</span><span class="v">${esc(r.sku.name || '')} ${esc(r.sku.family || '')}${r.sku.capacity || ''}</span></div>`;
  if (r.shardCount) html += `<div class="dp-kv"><span class="k">Shards</span><span class="v">${r.shardCount}</span></div>`;
  html += `</div></div>`;
  openDetailPanel(esc(shortName(r)), `Redis Cache | ${esc(r.sku?.name || '')}`, html);
}

// ---- Function App Detail Panel ----
function openFuncPanel(funcId) {
  const fa = _lk.functionApps.find(f => f.id && f.id.toLowerCase() === funcId.toLowerCase());
  if (!fa) return;
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(shortName(fa))}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Kind</span><span class="v">${esc(fa.kind || '')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">State</span><span class="v">${(fa.state || '').toLowerCase() === 'running' ? '<span class="a">Running</span>' : esc(fa.state || '')}</span></div>`;
  if (fa.defaultHostName) html += `<div class="dp-kv"><span class="k">Hostname</span><span class="v copyable">${esc(fa.defaultHostName)}</span></div>`;
  if (fa.virtualNetworkSubnetId) html += `<div class="dp-kv"><span class="k">VNet Subnet</span><span class="v copyable">${esc(shortName(fa.virtualNetworkSubnetId))}</span></div>`;
  html += `</div></div>`;
  openDetailPanel(esc(shortName(fa)), `Function App | ${esc(fa.state || '')}`, html);
}

// ---- Peering Detail Panel ----
function openPeeringPanel(peeringId) {
  const p = _lk.peerings.find(x => x.id && x.id.toLowerCase() === peeringId.toLowerCase());
  if (!p) return;
  const remoteName = p.remoteVirtualNetwork ? shortName(p.remoteVirtualNetwork.id) : '?';
  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Overview</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Name</span><span class="v copyable">${esc(p.name || '')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">State</span><span class="v ${(p.peeringState === 'Connected') ? 'a' : 'd'}">${esc(p.peeringState || 'Unknown')}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Remote VNet</span><span class="v copyable">${esc(remoteName)}</span></div>`;
  if (p.remoteVirtualNetwork?.id) html += `<div class="dp-kv"><span class="k">Remote ID</span><span class="v copyable" style="font-size:9px">${esc(p.remoteVirtualNetwork.id)}</span></div>`;
  html += `</div></div>`;

  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Flags</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">VNet Access</span><span class="v">${p.allowVirtualNetworkAccess ? '<span class="a">Yes</span>' : '<span class="d">No</span>'}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Forwarded Traffic</span><span class="v">${p.allowForwardedTraffic ? '<span class="a">Yes</span>' : '<span class="d">No</span>'}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Gateway Transit</span><span class="v">${p.allowGatewayTransit ? '<span class="a">Yes</span>' : '<span class="d">No</span>'}</span></div>`;
  html += `<div class="dp-kv"><span class="k">Use Remote GW</span><span class="v">${p.useRemoteGateways ? '<span class="a">Yes</span>' : '<span class="d">No</span>'}</span></div>`;
  html += `</div></div>`;

  openDetailPanel(esc(p.name || remoteName), `VNet Peering | ${esc(remoteName)}`, html);
}

// ============================================================
// TRAFFIC FLOW TRACING ENGINE
// ============================================================

function findSubnetByIp(ip, lk) {
  for (const sub of lk.subnets) {
    const cidr = sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]);
    if (cidr && ipInCIDR(ip, cidr)) return sub;
  }
  return null;
}

function findVnetForSubnet(subId, lk) {
  for (const vnet of lk.vnets) {
    const subs = lk.subnetsByVnet[vnet.id] || [];
    if (subs.some(s => s.id === subId)) return vnet;
  }
  return null;
}

function matchNsgRule(rules, srcIp, dstIp, dstPort, protocol) {
  // Evaluate NSG rules by priority (lowest first). First match wins.
  const sorted = (rules || []).slice().sort((a, b) => (a.priority || 9999) - (b.priority || 9999));
  for (const rule of sorted) {
    const dir = (rule.direction || '').toLowerCase();
    const ruleProto = (rule.protocol || '*').toLowerCase();
    const ruleAccess = (rule.access || '').toLowerCase();

    // Protocol check
    if (ruleProto !== '*' && ruleProto !== protocol.toLowerCase()) continue;

    // Destination port check
    const dstPortStr = rule.destinationPortRange || '*';
    const dstPortRanges = rule.destinationPortRanges || [];
    if (!portMatches(dstPort, dstPortStr, dstPortRanges)) continue;

    // Source address check
    const srcPrefix = rule.sourceAddressPrefix || '*';
    const srcPrefixes = rule.sourceAddressPrefixes || [];
    if (!addressMatches(srcIp, srcPrefix, srcPrefixes)) continue;

    // Destination address check
    const dstPrefix = rule.destinationAddressPrefix || '*';
    const dstPrefixes = rule.destinationAddressPrefixes || [];
    if (!addressMatches(dstIp, dstPrefix, dstPrefixes)) continue;

    return { rule, access: ruleAccess };
  }
  return null; // No explicit match (implicit deny)
}

function portMatches(port, rangeStr, ranges) {
  const portNum = parseInt(port, 10);
  function checkRange(r) {
    if (r === '*') return true;
    if (r.includes('-')) {
      const [lo, hi] = r.split('-').map(Number);
      return portNum >= lo && portNum <= hi;
    }
    return parseInt(r, 10) === portNum;
  }
  if (checkRange(rangeStr)) return true;
  return ranges.some(r => checkRange(r));
}

function addressMatches(ip, prefix, prefixes) {
  function checkPrefix(p) {
    if (p === '*' || p === 'Internet' || p === '0.0.0.0/0') return true;
    if (p === 'VirtualNetwork') return true; // Simplified: assume VNet traffic
    if (p === 'AzureLoadBalancer') return false;
    if (p.includes('/')) return ipInCIDR(ip, p);
    return ip === p;
  }
  if (checkPrefix(prefix)) return true;
  return prefixes.some(p => checkPrefix(p));
}

function traceFlow(srcIp, dstIp, dstPort, protocol, lk) {
  const hops = [];
  const proto = protocol || 'Tcp';

  // Step 1: Find source subnet
  const srcSubnet = findSubnetByIp(srcIp, lk);
  if (!srcSubnet) {
    hops.push({ step: 'Source', desc: `Source IP ${srcIp} not found in any subnet`, result: 'unknown', detail: 'IP not in any known subnet CIDR' });
    return { hops, result: 'unknown' };
  }
  const srcSubId = srcSubnet.id.toLowerCase();
  const srcVnet = findVnetForSubnet(srcSubnet.id, lk);
  hops.push({ step: 'Source', desc: `Source: ${shortName(srcSubnet)} in ${srcVnet ? shortName(srcVnet) : '?'}`, result: 'info', detail: `IP ${srcIp} in ${srcSubnet.addressPrefix || ''}` });

  // Step 2: Evaluate source NIC-level NSG (outbound)
  // Find NIC with this IP
  let srcNic = null;
  for (const nic of lk.nics) {
    for (const ipc of (nic.ipConfigurations || [])) {
      if (ipc.privateIpAddress === srcIp) { srcNic = nic; break }
    }
    if (srcNic) break;
  }
  if (srcNic) {
    const nicNsg = lk.nsgByNic[srcNic.id.toLowerCase()];
    if (nicNsg) {
      const outRules = (nicNsg.securityRules || []).filter(r => (r.direction || '').toLowerCase() === 'outbound');
      const allOut = outRules.concat((nicNsg.defaultSecurityRules || []).filter(r => (r.direction || '').toLowerCase() === 'outbound'));
      const match = matchNsgRule(allOut, srcIp, dstIp, dstPort, proto);
      if (match && match.access === 'deny') {
        hops.push({ step: 'NIC NSG Out', desc: `Blocked by NIC NSG ${shortName(nicNsg)}: ${match.rule.name}`, result: 'deny', detail: `Rule: ${match.rule.name} (P:${match.rule.priority})` });
        return { hops, result: 'deny' };
      }
      hops.push({ step: 'NIC NSG Out', desc: `Allowed by NIC NSG ${shortName(nicNsg)}${match ? ': ' + match.rule.name : ''}`, result: 'allow' });
    }
  }

  // Step 3: Evaluate source subnet-level NSG (outbound)
  const subNsg = lk.nsgBySubnet[srcSubId];
  if (subNsg) {
    const outRules = (subNsg.securityRules || []).filter(r => (r.direction || '').toLowerCase() === 'outbound');
    const allOut = outRules.concat((subNsg.defaultSecurityRules || []).filter(r => (r.direction || '').toLowerCase() === 'outbound'));
    const match = matchNsgRule(allOut, srcIp, dstIp, dstPort, proto);
    if (match && match.access === 'deny') {
      hops.push({ step: 'Subnet NSG Out', desc: `Blocked by subnet NSG ${shortName(subNsg)}: ${match.rule.name}`, result: 'deny', detail: `Rule: ${match.rule.name} (P:${match.rule.priority})` });
      return { hops, result: 'deny' };
    }
    hops.push({ step: 'Subnet NSG Out', desc: `Allowed by subnet NSG ${shortName(subNsg)}${match ? ': ' + match.rule.name : ''}`, result: 'allow' });
  }

  // Step 4: Route table lookup
  const rt = lk.rtBySubnet[srcSubId];
  let nextHop = 'VnetLocal';
  if (rt) {
    const routes = (rt.routes || []).sort((a, b) => {
      // Longest prefix match
      const aMask = parseInt((a.addressPrefix || '').split('/')[1]) || 0;
      const bMask = parseInt((b.addressPrefix || '').split('/')[1]) || 0;
      return bMask - aMask;
    });
    for (const route of routes) {
      if (route.addressPrefix && ipInCIDR(dstIp, route.addressPrefix)) {
        nextHop = route.nextHopType || 'VnetLocal';
        hops.push({ step: 'Route', desc: `Route: ${route.name} -> ${nextHop}${route.nextHopIpAddress ? ' (' + route.nextHopIpAddress + ')' : ''}`, result: 'info', detail: `Prefix: ${route.addressPrefix}` });
        break;
      }
    }
    if (nextHop === 'VnetLocal') {
      hops.push({ step: 'Route', desc: 'Route: System default (VnetLocal)', result: 'info' });
    }
  } else {
    hops.push({ step: 'Route', desc: 'Route: System routes (no UDR)', result: 'info' });
  }

  // Step 5: Check if cross-VNet (peering)
  const dstSubnet = findSubnetByIp(dstIp, lk);
  if (dstSubnet) {
    const dstVnet = findVnetForSubnet(dstSubnet.id, lk);
    if (srcVnet && dstVnet && srcVnet.id !== dstVnet.id) {
      const peering = (lk.peeringsByVnet[srcVnet.id] || []).find(p =>
        p.remoteVirtualNetwork && p.remoteVirtualNetwork.id === dstVnet.id
      );
      if (!peering) {
        hops.push({ step: 'Peering', desc: `No peering between ${shortName(srcVnet)} and ${shortName(dstVnet)}`, result: 'deny' });
        return { hops, result: 'deny' };
      }
      if (peering.peeringState !== 'Connected') {
        hops.push({ step: 'Peering', desc: `Peering ${peering.name} is ${peering.peeringState}`, result: 'deny' });
        return { hops, result: 'deny' };
      }
      hops.push({ step: 'Peering', desc: `Peering: ${peering.name} (${shortName(srcVnet)} -> ${shortName(dstVnet)})`, result: 'allow' });
    }

    // Step 6: Evaluate dest subnet NSG (inbound)
    const dstSubId = dstSubnet.id.toLowerCase();
    const dstSubNsg = lk.nsgBySubnet[dstSubId];
    if (dstSubNsg) {
      const inRules = (dstSubNsg.securityRules || []).filter(r => (r.direction || '').toLowerCase() === 'inbound');
      const allIn = inRules.concat((dstSubNsg.defaultSecurityRules || []).filter(r => (r.direction || '').toLowerCase() === 'inbound'));
      const match = matchNsgRule(allIn, srcIp, dstIp, dstPort, proto);
      if (match && match.access === 'deny') {
        hops.push({ step: 'Dest Subnet NSG', desc: `Blocked by dest subnet NSG ${shortName(dstSubNsg)}: ${match.rule.name}`, result: 'deny', detail: `Rule: ${match.rule.name} (P:${match.rule.priority})` });
        return { hops, result: 'deny' };
      }
      hops.push({ step: 'Dest Subnet NSG', desc: `Allowed by dest NSG ${shortName(dstSubNsg)}${match ? ': ' + match.rule.name : ''}`, result: 'allow' });
    }

    // Step 7: Evaluate dest NIC-level NSG (inbound)
    let dstNic = null;
    for (const nic of lk.nics) {
      for (const ipc of (nic.ipConfigurations || [])) {
        if (ipc.privateIpAddress === dstIp) { dstNic = nic; break }
      }
      if (dstNic) break;
    }
    if (dstNic) {
      const dstNicNsg = lk.nsgByNic[dstNic.id.toLowerCase()];
      if (dstNicNsg) {
        const inRules = (dstNicNsg.securityRules || []).filter(r => (r.direction || '').toLowerCase() === 'inbound');
        const allIn = inRules.concat((dstNicNsg.defaultSecurityRules || []).filter(r => (r.direction || '').toLowerCase() === 'inbound'));
        const match = matchNsgRule(allIn, srcIp, dstIp, dstPort, proto);
        if (match && match.access === 'deny') {
          hops.push({ step: 'Dest NIC NSG', desc: `Blocked by dest NIC NSG ${shortName(dstNicNsg)}: ${match.rule.name}`, result: 'deny', detail: `Rule: ${match.rule.name} (P:${match.rule.priority})` });
          return { hops, result: 'deny' };
        }
        hops.push({ step: 'Dest NIC NSG', desc: `Allowed by dest NIC NSG ${shortName(dstNicNsg)}${match ? ': ' + match.rule.name : ''}`, result: 'allow' });
      }
    }

    hops.push({ step: 'Destination', desc: `Destination: ${shortName(dstSubnet)} (${dstIp}:${dstPort})`, result: 'allow' });
    return { hops, result: 'allow' };
  }

  // Destination not in known subnets -- likely internet
  hops.push({ step: 'Destination', desc: `Destination ${dstIp}:${dstPort} (external)`, result: 'info' });
  return { hops, result: nextHop === 'None' ? 'deny' : 'allow' };
}

// ---- Flow UI ----
function openFlowPanel(srcIp, dstIp, dstPort, protocol) {
  if (!_lk || !_lk.vnets) return;
  const flow = traceFlow(srcIp, dstIp, dstPort || '443', protocol || 'Tcp', _lk);
  let html = '';

  // Flow summary
  const resultColor = flow.result === 'allow' ? 'var(--accent-green)' : flow.result === 'deny' ? 'var(--accent-red)' : 'var(--accent-orange)';
  html += `<div style="padding:12px 16px;border-bottom:2px solid ${resultColor};background:${flow.result === 'allow' ? 'rgba(16,185,129,.08)' : flow.result === 'deny' ? 'rgba(239,68,68,.08)' : 'rgba(245,158,11,.08)'}">`;
  html += `<div style="font-family:'IBM Plex Mono',monospace;font-size:12px;font-weight:600;color:${resultColor};text-transform:uppercase;margin-bottom:4px">${flow.result === 'allow' ? 'TRAFFIC ALLOWED' : flow.result === 'deny' ? 'TRAFFIC BLOCKED' : 'UNKNOWN'}</div>`;
  html += `<div style="font-family:'IBM Plex Mono',monospace;font-size:10px;color:var(--text-secondary)">${esc(srcIp)} &rarr; ${esc(dstIp)}:${esc(dstPort || '443')} (${esc(protocol || 'Tcp')})</div>`;
  html += `</div>`;

  // Hop-by-hop
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Evaluation Steps</span><span class="dp-sec-count">${flow.hops.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  flow.hops.forEach((hop, i) => {
    const hopColor = hop.result === 'allow' ? 'a' : hop.result === 'deny' ? 'd' : hop.result === 'info' ? 'i' : 'p';
    const icon = hop.result === 'allow' ? '&#10003;' : hop.result === 'deny' ? '&#10007;' : '&#9656;';
    html += `<div class="dp-row" style="padding:6px 0">`;
    html += `<span class="lbl" style="font-size:8px;color:var(--text-muted)">STEP ${i + 1}: ${esc(hop.step)}</span>`;
    html += `<span class="val"><span class="${hopColor}">${icon}</span> ${esc(hop.desc)}</span>`;
    if (hop.detail) html += `<span class="lbl" style="font-size:8px">${esc(hop.detail)}</span>`;
    html += `</div>`;
  });
  html += `</div></div>`;

  openDetailPanel(
    `Flow: <span style="color:${resultColor}">${flow.result.toUpperCase()}</span>`,
    `${esc(srcIp)} &rarr; ${esc(dstIp)}:${esc(dstPort || '443')}/${esc(protocol || 'Tcp')}`,
    html
  );
}

// Flow form (Shift+T shortcut)
function openFlowForm() {
  if (!_lk || !_lk.vnets) return;
  // Flow tracing is not available in Executive Overview mode
  if (document.getElementById('layoutMode').value === 'executive') return;
  // Collect known IPs for suggestions
  const knownIps = [];
  _lk.nics.forEach(nic => {
    (nic.ipConfigurations || []).forEach(ipc => {
      if (ipc.privateIpAddress) knownIps.push({ ip: ipc.privateIpAddress, label: shortName(nic) });
    });
  });

  let html = '';
  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Trace Traffic Flow</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  html += `<div class="dp-kv"><span class="k">Source IP</span></div>`;
  html += `<input id="flowSrcIp" type="text" placeholder="e.g. 10.1.1.4" style="width:100%;box-sizing:border-box;padding:6px 8px;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:11px;margin-bottom:8px">`;
  html += `<div class="dp-kv"><span class="k">Destination IP</span></div>`;
  html += `<input id="flowDstIp" type="text" placeholder="e.g. 10.2.1.4 or 8.8.8.8" style="width:100%;box-sizing:border-box;padding:6px 8px;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:11px;margin-bottom:8px">`;
  html += `<div class="dp-kv"><span class="k">Destination Port</span></div>`;
  html += `<input id="flowDstPort" type="text" placeholder="443" value="443" style="width:100%;box-sizing:border-box;padding:6px 8px;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:11px;margin-bottom:8px">`;
  html += `<div class="dp-kv"><span class="k">Protocol</span></div>`;
  html += `<select id="flowProto" style="width:100%;box-sizing:border-box;padding:6px 8px;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-family:'IBM Plex Mono',monospace;font-size:11px;margin-bottom:12px"><option value="Tcp">TCP</option><option value="Udp">UDP</option><option value="*">Any</option></select>`;
  html += `<button onclick="openFlowPanel(document.getElementById('flowSrcIp').value,document.getElementById('flowDstIp').value,document.getElementById('flowDstPort').value,document.getElementById('flowProto').value)" style="width:100%;padding:8px;background:var(--accent-blue);color:#fff;border:none;border-radius:6px;font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:600;cursor:pointer;text-transform:uppercase">Trace Flow</button>`;
  html += `</div></div>`;

  // Quick test buttons
  if (knownIps.length >= 2) {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Quick Tests</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    const src = knownIps[0];
    const dst = knownIps[Math.min(1, knownIps.length - 1)];
    html += `<div class="dp-row" style="cursor:pointer" onclick="openFlowPanel('${esc(src.ip)}','${esc(dst.ip)}','443','Tcp')"><span class="val i">HTTPS ${esc(src.label)} &rarr; ${esc(dst.label)}</span></div>`;
    html += `<div class="dp-row" style="cursor:pointer" onclick="openFlowPanel('${esc(src.ip)}','${esc(dst.ip)}','22','Tcp')"><span class="val p">SSH ${esc(src.label)} &rarr; ${esc(dst.label)}</span></div>`;
    html += `</div></div>`;
  }

  // Known IPs list
  if (knownIps.length > 0) {
    html += `<div class="dp-section"><div class="dp-sec-hdr collapsed"><span class="dp-sec-title">Known IPs</span><span class="dp-sec-count">${knownIps.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body hidden">`;
    knownIps.forEach(k => {
      html += `<div class="dp-row"><span class="val copyable">${esc(k.ip)}</span><span class="lbl">${esc(k.label)}</span></div>`;
    });
    html += `</div></div>`;
  }

  openDetailPanel('Traffic Flow Tracer', 'Evaluate NSG rules + routing for a packet', html);
}

// ============================================================
// COMPLIANCE ENGINE
// ============================================================

function runComplianceChecks(lk) {
  const findings = [];

  // Helper: check if NSG rule allows from internet on specific port
  function nsgAllowsInternetPort(nsg, port, direction) {
    const rules = (nsg.securityRules || []).filter(r => (r.direction || '').toLowerCase() === direction.toLowerCase());
    for (const rule of rules) {
      if ((rule.access || '').toLowerCase() !== 'allow') continue;
      const src = rule.sourceAddressPrefix || '';
      const srcList = rule.sourceAddressPrefixes || [];
      const isInternet = src === '*' || src === 'Internet' || src === '0.0.0.0/0' || srcList.some(s => s === '*' || s === '0.0.0.0/0' || s === 'Internet');
      if (!isInternet) continue;
      const dstPort = rule.destinationPortRange || '*';
      const dstPorts = rule.destinationPortRanges || [];
      if (dstPort === '*' || dstPort === String(port) || dstPorts.includes(String(port))) return rule;
      // Check ranges
      if (dstPort.includes('-')) {
        const [lo, hi] = dstPort.split('-').map(Number);
        if (port >= lo && port <= hi) return rule;
      }
    }
    return null;
  }

  // CIS Azure 3.0 checks
  lk.nsgs.forEach(nsg => {
    // CIS-6.1: RDP from internet
    const rdpRule = nsgAllowsInternetPort(nsg, 3389, 'Inbound');
    if (rdpRule) findings.push({ id: 'CIS-6.1', framework: 'CIS', severity: 'HIGH', message: 'RDP (3389) unrestricted from internet', resource: nsg.name, resourceId: nsg.id, remediation: 'Restrict source to specific IP ranges or use Bastion', rule: rdpRule.name });

    // CIS-6.2: SSH from internet
    const sshRule = nsgAllowsInternetPort(nsg, 22, 'Inbound');
    if (sshRule) findings.push({ id: 'CIS-6.2', framework: 'CIS', severity: 'HIGH', message: 'SSH (22) unrestricted from internet', resource: nsg.name, resourceId: nsg.id, remediation: 'Restrict source to specific IP ranges or use Bastion', rule: sshRule.name });

    // CIS-6.3: Database ports from internet
    [1433, 3306, 5432].forEach(port => {
      const dbRule = nsgAllowsInternetPort(nsg, port, 'Inbound');
      if (dbRule) findings.push({ id: 'CIS-6.3', framework: 'CIS', severity: 'HIGH', message: `Database port (${port}) unrestricted from internet`, resource: nsg.name, resourceId: nsg.id, remediation: 'Restrict database access to application subnets only', rule: dbRule.name });
    });

    // CIS-6.6: UDP from internet
    const udpRules = (nsg.securityRules || []).filter(r =>
      (r.direction || '').toLowerCase() === 'inbound' &&
      (r.access || '').toLowerCase() === 'allow' &&
      ((r.protocol || '').toLowerCase() === 'udp' || (r.protocol || '') === '*') &&
      (r.sourceAddressPrefix === '*' || r.sourceAddressPrefix === 'Internet' || r.sourceAddressPrefix === '0.0.0.0/0')
    );
    if (udpRules.length > 0) findings.push({ id: 'CIS-6.6', framework: 'CIS', severity: 'MEDIUM', message: 'UDP traffic allowed from internet', resource: nsg.name, resourceId: nsg.id, remediation: 'Restrict UDP access to specific ports and sources' });

    // NET-2: All traffic allowed from internet
    const allTrafficRule = (nsg.securityRules || []).find(r =>
      (r.direction || '').toLowerCase() === 'inbound' &&
      (r.access || '').toLowerCase() === 'allow' &&
      (r.sourceAddressPrefix === '*' || r.sourceAddressPrefix === '0.0.0.0/0') &&
      (r.destinationPortRange === '*') &&
      (r.protocol || '') === '*'
    );
    if (allTrafficRule) findings.push({ id: 'NET-2', framework: 'CIS', severity: 'HIGH', message: 'NSG allows ALL traffic from internet', resource: nsg.name, resourceId: nsg.id, remediation: 'Replace with specific allow rules for required ports only' });
  });

  // CIS-6.8: No Bastion deployed
  if (lk.bastions.length === 0 && lk.vms.length > 0) {
    findings.push({ id: 'CIS-6.8', framework: 'CIS', severity: 'MEDIUM', message: 'No Azure Bastion deployed for secure VM access', resource: 'Environment', resourceId: '', remediation: 'Deploy Azure Bastion in hub VNet for secure SSH/RDP access' });
  }

  // Architecture checks
  // ARCH-N1: Subnet without NSG
  lk.subnets.forEach(sub => {
    const subName = (sub.name || '').toLowerCase();
    if (subName === 'azurefirewallsubnet' || subName === 'gatewaysubnet') return; // These don't need NSGs
    const subId = sub.id ? sub.id.toLowerCase() : '';
    if (!lk.nsgBySubnet[subId]) {
      findings.push({ id: 'ARCH-N1', framework: 'ARCH', severity: 'HIGH', message: 'Subnet has no NSG attached', resource: sub.name || shortName(sub), resourceId: sub.id, remediation: 'Attach an NSG to control traffic flow' });
    }
  });

  // ARCH-N2: Subnet without route table (for spoke subnets)
  lk.subnets.forEach(sub => {
    const subName = (sub.name || '').toLowerCase();
    if (subName === 'azurefirewallsubnet' || subName === 'gatewaysubnet' || subName === 'azurebastionsubnet') return;
    const subId = sub.id ? sub.id.toLowerCase() : '';
    if (!lk.rtBySubnet[subId] && lk.firewalls.length > 0) {
      findings.push({ id: 'ARCH-N2', framework: 'ARCH', severity: 'MEDIUM', message: 'Subnet missing UDR (firewall exists but traffic may bypass)', resource: sub.name || shortName(sub), resourceId: sub.id, remediation: 'Add route table with 0.0.0.0/0 -> Virtual Appliance (Firewall)' });
    }
  });

  // ARCH-P1: Unpaired peerings
  const peerPairs = {};
  lk.peerings.forEach(p => {
    if (!p.remoteVirtualNetwork?.id || !p.id) return;
    const parts = p.id.split('/');
    const idx = parts.indexOf('virtualNetworks');
    if (idx < 0) return;
    const srcVnet = parts.slice(0, idx + 2).join('/');
    const key = [srcVnet, p.remoteVirtualNetwork.id].sort().join('|');
    peerPairs[key] = (peerPairs[key] || 0) + 1;
  });
  for (const [key, count] of Object.entries(peerPairs)) {
    if (count < 2) {
      const [a, b] = key.split('|');
      findings.push({ id: 'ARCH-P1', framework: 'ARCH', severity: 'HIGH', message: `Unpaired peering: only one direction configured`, resource: `${shortName(a)} <-> ${shortName(b)}`, resourceId: a, remediation: 'Peerings must be configured in both directions' });
    }
  }

  // ARCH-S1: Storage with public blob access
  lk.storageAccounts.forEach(sa => {
    if (sa.allowBlobPublicAccess) {
      findings.push({ id: 'ARCH-S1', framework: 'ARCH', severity: 'HIGH', message: 'Storage account allows public blob access', resource: sa.name, resourceId: sa.id, remediation: 'Disable public blob access and use private endpoints' });
    }
    // ARCH-S2: Storage without network restrictions
    const nr = sa.networkRuleSet || sa.networkAcls || {};
    if ((nr.defaultAction || 'Allow') !== 'Deny') {
      findings.push({ id: 'ARCH-S2', framework: 'ARCH', severity: 'MEDIUM', message: 'Storage account allows access from all networks', resource: sa.name, resourceId: sa.id, remediation: 'Set default action to Deny and add VNet/IP rules' });
    }
  });

  // ARCH-F1: Firewall without policy
  lk.firewalls.forEach(fw => {
    if (!fw.firewallPolicy?.id) {
      findings.push({ id: 'ARCH-F1', framework: 'ARCH', severity: 'MEDIUM', message: 'Firewall has no associated policy', resource: fw.name, resourceId: fw.id, remediation: 'Create and associate an Azure Firewall Policy for centralized rule management' });
    }
  });

  // SOC2: Encryption + access controls
  lk.storageAccounts.forEach(sa => {
    if (sa.minimumTlsVersion && sa.minimumTlsVersion !== 'TLS1_2') {
      findings.push({ id: 'SOC2-CC6.1', framework: 'SOC2', severity: 'MEDIUM', message: `Storage TLS version below 1.2: ${sa.minimumTlsVersion}`, resource: sa.name, resourceId: sa.id, remediation: 'Set minimum TLS version to 1.2' });
    }
  });

  // PCI: Network segmentation
  if (lk.vnets.length === 1 && lk.subnets.length > 3) {
    findings.push({ id: 'PCI-1.3.1', framework: 'PCI', severity: 'HIGH', message: 'Single VNet with many subnets - consider network segmentation', resource: lk.vnets[0].name, resourceId: lk.vnets[0].id, remediation: 'Use separate VNets for different security zones with peering' });
  }

  // WAF checks
  if (lk.appGateways.length > 0) {
    lk.appGateways.forEach(agw => {
      const sku = agw.sku?.name || '';
      if (!sku.includes('WAF')) {
        findings.push({ id: 'WAF-1', framework: 'WAF', severity: 'MEDIUM', message: 'App Gateway without WAF SKU', resource: agw.name, resourceId: agw.id, remediation: 'Upgrade to WAF_v2 SKU for web application protection' });
      }
    });
  }

  return findings.sort((a, b) => {
    const sevOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
    return (sevOrder[a.severity] || 9) - (sevOrder[b.severity] || 9);
  });
}

// ---- Compliance Dashboard UI ----
function openComplianceDashboard() {
  if (!_lk || !_lk.vnets) return;
  const findings = runComplianceChecks(_lk);

  let html = '';

  // Summary bar
  const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
  findings.forEach(f => { counts[f.severity] = (counts[f.severity] || 0) + 1 });

  html += `<div style="padding:12px 16px;border-bottom:1px solid var(--border);display:flex;gap:8px;flex-wrap:wrap">`;
  ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].forEach(sev => {
    if (counts[sev] > 0) html += `<span class="sev-badge sev-${sev}">${counts[sev]} ${sev}</span>`;
  });
  if (findings.length === 0) html += `<span style="color:var(--accent-green);font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:600">No issues found</span>`;
  html += `</div>`;

  // Group by framework
  const frameworks = {};
  findings.forEach(f => {
    if (!frameworks[f.framework]) frameworks[f.framework] = [];
    frameworks[f.framework].push(f);
  });

  for (const [fw, items] of Object.entries(frameworks)) {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">${esc(fw)}</span><span class="dp-sec-count">${items.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    items.forEach(f => {
      html += `<div class="dp-row" style="padding:6px 0">`;
      html += `<span class="sev-badge sev-${f.severity}" style="font-size:8px;margin-right:4px">${esc(f.severity)}</span>`;
      html += `<span class="val">${esc(f.id)}: ${esc(f.message)}</span>`;
      html += `<span class="lbl">${esc(f.resource)}${f.rule ? ' (rule: ' + esc(f.rule) + ')' : ''}</span>`;
      html += `<span class="lbl" style="color:var(--accent-cyan);font-size:8px">${esc(f.remediation)}</span>`;
      html += `</div>`;
    });
    html += `</div></div>`;
  }

  // Export button
  html += `<div style="padding:12px 16px"><button onclick="exportComplianceCsv()" style="width:100%;padding:8px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:6px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:10px;cursor:pointer;text-transform:uppercase">Export CSV</button></div>`;

  openDetailPanel(
    `Compliance: ${findings.length} findings`,
    `${Object.keys(frameworks).length} frameworks | ${counts.HIGH + counts.CRITICAL} critical/high`,
    html
  );
}

function exportComplianceCsv() {
  if (!_lk) return;
  const findings = runComplianceChecks(_lk);
  let csv = 'Framework,Severity,Check ID,Resource,Message,Remediation\n';
  findings.forEach(f => {
    csv += `"${f.framework}","${f.severity}","${f.id}","${f.resource}","${f.message}","${f.remediation}"\n`;
  });
  const blob = new Blob([csv], { type: 'text/csv' });
  const a = document.createElement('a');
  a.download = 'azure-compliance-findings.csv';
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
}

// ============================================================
// BLAST RADIUS ENGINE
// ============================================================

function calculateBlastRadius(resourceId, lk) {
  const deps = { hard: [], soft: [], config: [] };
  const rid = (resourceId || '').toLowerCase();
  const parsed = parseResourceId(resourceId);
  if (!parsed) return deps;

  const resType = parsed.resourceType || '';

  // NSG removal impact
  if (resType.includes('networkSecurityGroups')) {
    for (const [subId, nsg] of Object.entries(lk.nsgBySubnet)) {
      if (nsg && nsg.id && nsg.id.toLowerCase() === rid) {
        deps.hard.push({ type: 'Subnet (unprotected)', name: shortName(subId), id: subId });
        // All resources in that subnet
        (lk.vmsBySubnet[subId] || []).forEach(vm => deps.soft.push({ type: 'VM (exposed)', name: shortName(vm), id: vm.id }));
      }
    }
    for (const [nicId, nsg] of Object.entries(lk.nsgByNic)) {
      if (nsg && nsg.id && nsg.id.toLowerCase() === rid) {
        deps.hard.push({ type: 'NIC (unprotected)', name: shortName(nicId), id: nicId });
      }
    }
  }

  // Route Table removal
  if (resType.includes('routeTables')) {
    for (const [subId, rt] of Object.entries(lk.rtBySubnet)) {
      if (rt && rt.id && rt.id.toLowerCase() === rid) {
        deps.hard.push({ type: 'Subnet (default routes)', name: shortName(subId), id: subId });
      }
    }
  }

  // Subnet removal
  if (rid.includes('/subnets/')) {
    (lk.vmsBySubnet[rid] || []).forEach(vm => deps.hard.push({ type: 'VM', name: shortName(vm), id: vm.id }));
    (lk.pesBySubnet[rid] || []).forEach(pe => deps.hard.push({ type: 'PE', name: shortName(pe), id: pe.id }));
    (lk.funcBySubnet[rid] || []).forEach(fa => deps.hard.push({ type: 'Function', name: shortName(fa), id: fa.id }));
  }

  // VNet removal
  if (resType.includes('virtualNetworks') && !rid.includes('/subnets/')) {
    const subs = lk.subnetsByVnet[resourceId] || [];
    subs.forEach(sub => deps.hard.push({ type: 'Subnet', name: shortName(sub), id: sub.id }));
    (lk.peeringsByVnet[resourceId] || []).forEach(p => deps.soft.push({ type: 'Peering', name: p.name, id: p.id }));
  }

  return deps;
}

function openBlastRadiusPanel(resourceId) {
  const deps = calculateBlastRadius(resourceId, _lk);
  const total = deps.hard.length + deps.soft.length + deps.config.length;
  let html = '';

  html += `<div style="padding:12px 16px;border-bottom:1px solid var(--border)">`;
  html += `<div style="font-family:'IBM Plex Mono',monospace;font-size:10px;color:var(--text-muted)">If this resource is removed:</div>`;
  html += `<div style="font-family:'IBM Plex Mono',monospace;font-size:12px;color:var(--text-primary);margin-top:4px">${total} impacted resources</div>`;
  html += `</div>`;

  if (deps.hard.length > 0) {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title" style="color:var(--accent-red)">Hard Dependencies</span><span class="dp-sec-count">${deps.hard.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    deps.hard.forEach(d => { html += `<div class="dp-row"><span class="lbl">${esc(d.type)}</span><span class="val d">${esc(d.name)}</span></div>` });
    html += `</div></div>`;
  }
  if (deps.soft.length > 0) {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title" style="color:var(--accent-orange)">Soft Dependencies</span><span class="dp-sec-count">${deps.soft.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    deps.soft.forEach(d => { html += `<div class="dp-row"><span class="lbl">${esc(d.type)}</span><span class="val p">${esc(d.name)}</span></div>` });
    html += `</div></div>`;
  }
  if (total === 0) {
    html += `<div style="padding:16px;text-align:center;color:var(--text-muted);font-family:'IBM Plex Mono',monospace;font-size:11px">No dependencies detected</div>`;
  }

  openDetailPanel('Blast Radius', `Impact analysis for ${esc(shortName(resourceId))}`, html);
}

// ============================================================
// IAC EXPORT GENERATORS
// ============================================================

function generateTerraform(lk) {
  let tf = '';
  tf += '# Generated by Azure Network Mapper\n';
  tf += '# Provider configuration\n';
  tf += 'terraform {\n  required_providers {\n    azurerm = {\n      source  = "hashicorp/azurerm"\n      version = "~> 3.0"\n    }\n  }\n}\n\nprovider "azurerm" {\n  features {}\n}\n\n';

  // Resource Groups
  const seenRgs = new Set();
  lk.vnets.forEach(v => {
    const p = parseResourceId(v.id || '');
    if (p && !seenRgs.has(p.resourceGroup)) {
      seenRgs.add(p.resourceGroup);
      const safeName = p.resourceGroup.replace(/[^a-zA-Z0-9_-]/g, '_');
      tf += `resource "azurerm_resource_group" "${safeName}" {\n  name     = "${p.resourceGroup}"\n  location = "${v.location || 'eastus'}"\n}\n\n`;
    }
  });

  // NSGs
  lk.nsgs.forEach(nsg => {
    const p = parseResourceId(nsg.id || '');
    const safeName = (nsg.name || 'nsg').replace(/[^a-zA-Z0-9_-]/g, '_');
    const rgRef = p ? p.resourceGroup.replace(/[^a-zA-Z0-9_-]/g, '_') : 'main';
    tf += `resource "azurerm_network_security_group" "${safeName}" {\n`;
    tf += `  name                = "${nsg.name}"\n`;
    tf += `  location            = azurerm_resource_group.${rgRef}.location\n`;
    tf += `  resource_group_name = azurerm_resource_group.${rgRef}.name\n`;
    (nsg.securityRules || []).forEach(rule => {
      tf += `\n  security_rule {\n`;
      tf += `    name                       = "${rule.name || ''}"\n`;
      tf += `    priority                   = ${rule.priority || 100}\n`;
      tf += `    direction                  = "${rule.direction || 'Inbound'}"\n`;
      tf += `    access                     = "${rule.access || 'Allow'}"\n`;
      tf += `    protocol                   = "${rule.protocol || '*'}"\n`;
      tf += `    source_port_range          = "${rule.sourcePortRange || '*'}"\n`;
      tf += `    destination_port_range     = "${rule.destinationPortRange || '*'}"\n`;
      tf += `    source_address_prefix      = "${rule.sourceAddressPrefix || '*'}"\n`;
      tf += `    destination_address_prefix = "${rule.destinationAddressPrefix || '*'}"\n`;
      tf += `  }\n`;
    });
    tf += `}\n\n`;
  });

  // Route Tables
  lk.routeTables.forEach(rt => {
    const p = parseResourceId(rt.id || '');
    const safeName = (rt.name || 'rt').replace(/[^a-zA-Z0-9_-]/g, '_');
    const rgRef = p ? p.resourceGroup.replace(/[^a-zA-Z0-9_-]/g, '_') : 'main';
    tf += `resource "azurerm_route_table" "${safeName}" {\n`;
    tf += `  name                = "${rt.name}"\n`;
    tf += `  location            = azurerm_resource_group.${rgRef}.location\n`;
    tf += `  resource_group_name = azurerm_resource_group.${rgRef}.name\n`;
    if (rt.disableBgpRoutePropagation) tf += `  disable_bgp_route_propagation = true\n`;
    (rt.routes || []).forEach(route => {
      tf += `\n  route {\n`;
      tf += `    name                   = "${route.name || ''}"\n`;
      tf += `    address_prefix         = "${route.addressPrefix || ''}"\n`;
      tf += `    next_hop_type          = "${route.nextHopType || 'None'}"\n`;
      if (route.nextHopIpAddress) tf += `    next_hop_ip_address = "${route.nextHopIpAddress}"\n`;
      tf += `  }\n`;
    });
    tf += `}\n\n`;
  });

  // VNets + Subnets
  lk.vnets.forEach(vnet => {
    const p = parseResourceId(vnet.id || '');
    const safeName = (vnet.name || 'vnet').replace(/[^a-zA-Z0-9_-]/g, '_');
    const rgRef = p ? p.resourceGroup.replace(/[^a-zA-Z0-9_-]/g, '_') : 'main';
    const addrPrefixes = (vnet.addressSpace?.addressPrefixes || []).map(a => `"${a}"`).join(', ');
    tf += `resource "azurerm_virtual_network" "${safeName}" {\n`;
    tf += `  name                = "${vnet.name}"\n`;
    tf += `  location            = azurerm_resource_group.${rgRef}.location\n`;
    tf += `  resource_group_name = azurerm_resource_group.${rgRef}.name\n`;
    tf += `  address_space       = [${addrPrefixes}]\n`;
    tf += `}\n\n`;

    const subnets = lk.subnetsByVnet[vnet.id] || [];
    subnets.forEach(sub => {
      const subSafe = `${safeName}__${(sub.name || 'sub').replace(/[^a-zA-Z0-9_-]/g, '_')}`;
      const cidr = sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]) || '';
      tf += `resource "azurerm_subnet" "${subSafe}" {\n`;
      tf += `  name                 = "${sub.name || ''}"\n`;
      tf += `  resource_group_name  = azurerm_resource_group.${rgRef}.name\n`;
      tf += `  virtual_network_name = azurerm_virtual_network.${safeName}.name\n`;
      tf += `  address_prefixes     = ["${cidr}"]\n`;
      tf += `}\n\n`;
    });
  });

  // Public IPs
  lk.publicIps.forEach(pip => {
    const p = parseResourceId(pip.id || '');
    const safeName = (pip.name || 'pip').replace(/[^a-zA-Z0-9_-]/g, '_');
    const rgRef = p ? p.resourceGroup.replace(/[^a-zA-Z0-9_-]/g, '_') : 'main';
    tf += `resource "azurerm_public_ip" "${safeName}" {\n`;
    tf += `  name                = "${pip.name}"\n`;
    tf += `  location            = azurerm_resource_group.${rgRef}.location\n`;
    tf += `  resource_group_name = azurerm_resource_group.${rgRef}.name\n`;
    tf += `  allocation_method   = "${pip.publicIpAllocationMethod || 'Static'}"\n`;
    tf += `  sku                 = "${pip.sku?.name || 'Standard'}"\n`;
    tf += `}\n\n`;
  });

  // Peerings
  const seenPeerings = new Set();
  lk.peerings.forEach(peer => {
    const safeName = (peer.name || 'peer').replace(/[^a-zA-Z0-9_-]/g, '_');
    if (seenPeerings.has(safeName)) return;
    seenPeerings.add(safeName);
    const parts = (peer.id || '').split('/');
    const vnetIdx = parts.indexOf('virtualNetworks');
    if (vnetIdx < 0) return;
    const srcVnetName = parts[vnetIdx + 1];
    const srcVnetSafe = srcVnetName.replace(/[^a-zA-Z0-9_-]/g, '_');
    const remoteId = peer.remoteVirtualNetwork?.id || '';
    const remoteVnetSafe = shortName(remoteId).replace(/[^a-zA-Z0-9_-]/g, '_');
    const p = parseResourceId(peer.id || '');
    const rgRef = p ? p.resourceGroup.replace(/[^a-zA-Z0-9_-]/g, '_') : 'main';

    tf += `resource "azurerm_virtual_network_peering" "${safeName}" {\n`;
    tf += `  name                      = "${peer.name}"\n`;
    tf += `  resource_group_name       = azurerm_resource_group.${rgRef}.name\n`;
    tf += `  virtual_network_name      = azurerm_virtual_network.${srcVnetSafe}.name\n`;
    tf += `  remote_virtual_network_id = azurerm_virtual_network.${remoteVnetSafe}.id\n`;
    if (peer.allowVirtualNetworkAccess) tf += `  allow_virtual_network_access = true\n`;
    if (peer.allowForwardedTraffic) tf += `  allow_forwarded_traffic      = true\n`;
    if (peer.allowGatewayTransit) tf += `  allow_gateway_transit         = true\n`;
    if (peer.useRemoteGateways) tf += `  use_remote_gateways           = true\n`;
    tf += `}\n\n`;
  });

  return tf;
}

function generateARM(lk) {
  const template = {
    '$schema': 'https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#',
    contentVersion: '1.0.0.0',
    parameters: {},
    variables: {},
    resources: [],
    outputs: {}
  };

  // NSGs
  lk.nsgs.forEach(nsg => {
    const p = parseResourceId(nsg.id || '');
    template.resources.push({
      type: 'Microsoft.Network/networkSecurityGroups',
      apiVersion: '2023-04-01',
      name: nsg.name,
      location: nsg.location || '[resourceGroup().location]',
      properties: {
        securityRules: (nsg.securityRules || []).map(r => ({
          name: r.name,
          properties: {
            priority: r.priority, direction: r.direction, access: r.access, protocol: r.protocol,
            sourcePortRange: r.sourcePortRange || '*', destinationPortRange: r.destinationPortRange || '*',
            sourceAddressPrefix: r.sourceAddressPrefix || '*', destinationAddressPrefix: r.destinationAddressPrefix || '*'
          }
        }))
      }
    });
  });

  // VNets
  lk.vnets.forEach(vnet => {
    const subnets = lk.subnetsByVnet[vnet.id] || [];
    template.resources.push({
      type: 'Microsoft.Network/virtualNetworks',
      apiVersion: '2023-04-01',
      name: vnet.name,
      location: vnet.location || '[resourceGroup().location]',
      dependsOn: lk.nsgs.map(n => `[resourceId('Microsoft.Network/networkSecurityGroups', '${n.name}')]`),
      properties: {
        addressSpace: { addressPrefixes: vnet.addressSpace?.addressPrefixes || [] },
        subnets: subnets.map(sub => {
          const subProps = { addressPrefix: sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]) || '' };
          const nsg = lk.nsgBySubnet[sub.id ? sub.id.toLowerCase() : ''];
          if (nsg) subProps.networkSecurityGroup = { id: `[resourceId('Microsoft.Network/networkSecurityGroups', '${nsg.name}')]` };
          return { name: sub.name, properties: subProps };
        })
      }
    });
  });

  // Public IPs
  lk.publicIps.forEach(pip => {
    template.resources.push({
      type: 'Microsoft.Network/publicIPAddresses',
      apiVersion: '2023-04-01',
      name: pip.name,
      location: pip.location || '[resourceGroup().location]',
      sku: { name: pip.sku?.name || 'Standard' },
      properties: { publicIPAllocationMethod: pip.publicIpAllocationMethod || 'Static' }
    });
  });

  return JSON.stringify(template, null, 2);
}

function generateBicep(lk) {
  let bicep = '// Generated by Azure Network Mapper\n\n';

  // NSGs
  lk.nsgs.forEach(nsg => {
    const safeName = (nsg.name || 'nsg').replace(/[^a-zA-Z0-9_]/g, '_');
    bicep += `resource ${safeName} 'Microsoft.Network/networkSecurityGroups@2023-04-01' = {\n`;
    bicep += `  name: '${nsg.name}'\n`;
    bicep += `  location: resourceGroup().location\n`;
    bicep += `  properties: {\n    securityRules: [\n`;
    (nsg.securityRules || []).forEach(r => {
      bicep += `      {\n        name: '${r.name || ''}'\n        properties: {\n`;
      bicep += `          priority: ${r.priority || 100}\n          direction: '${r.direction || 'Inbound'}'\n`;
      bicep += `          access: '${r.access || 'Allow'}'\n          protocol: '${r.protocol || '*'}'\n`;
      bicep += `          sourcePortRange: '${r.sourcePortRange || '*'}'\n          destinationPortRange: '${r.destinationPortRange || '*'}'\n`;
      bicep += `          sourceAddressPrefix: '${r.sourceAddressPrefix || '*'}'\n          destinationAddressPrefix: '${r.destinationAddressPrefix || '*'}'\n`;
      bicep += `        }\n      }\n`;
    });
    bicep += `    ]\n  }\n}\n\n`;
  });

  // VNets
  lk.vnets.forEach(vnet => {
    const safeName = (vnet.name || 'vnet').replace(/[^a-zA-Z0-9_]/g, '_');
    const addrPrefixes = (vnet.addressSpace?.addressPrefixes || []).map(a => `'${a}'`).join('\n      ');
    bicep += `resource ${safeName} 'Microsoft.Network/virtualNetworks@2023-04-01' = {\n`;
    bicep += `  name: '${vnet.name}'\n`;
    bicep += `  location: resourceGroup().location\n`;
    bicep += `  properties: {\n    addressSpace: {\n      addressPrefixes: [\n      ${addrPrefixes}\n      ]\n    }\n`;
    const subnets = lk.subnetsByVnet[vnet.id] || [];
    bicep += `    subnets: [\n`;
    subnets.forEach(sub => {
      const cidr = sub.addressPrefix || (sub.addressPrefixes && sub.addressPrefixes[0]) || '';
      bicep += `      {\n        name: '${sub.name || ''}'\n        properties: {\n          addressPrefix: '${cidr}'\n`;
      const nsg = lk.nsgBySubnet[sub.id ? sub.id.toLowerCase() : ''];
      if (nsg) {
        const nsgSafe = (nsg.name || 'nsg').replace(/[^a-zA-Z0-9_]/g, '_');
        bicep += `          networkSecurityGroup: { id: ${nsgSafe}.id }\n`;
      }
      bicep += `        }\n      }\n`;
    });
    bicep += `    ]\n  }\n}\n\n`;
  });

  return bicep;
}

// ---- IaC Export UI ----
function openIaCModal(format) {
  if (!_lk || !_lk.vnets) return;
  let code = '';
  let title = '';
  if (format === 'terraform') { code = generateTerraform(_lk); title = 'Terraform (HCL)'; }
  else if (format === 'arm') { code = generateARM(_lk); title = 'ARM Template (JSON)'; }
  else if (format === 'bicep') { code = generateBicep(_lk); title = 'Bicep'; }

  let html = '';
  html += `<div style="padding:8px 16px;display:flex;gap:6px;border-bottom:1px solid var(--border)">`;
  html += `<button onclick="openIaCModal('terraform')" style="padding:4px 10px;border-radius:4px;border:1px solid ${format==='terraform'?'var(--accent-cyan)':'var(--border)'};background:${format==='terraform'?'rgba(6,182,212,.1)':'transparent'};color:${format==='terraform'?'var(--accent-cyan)':'var(--text-secondary)'};font-family:'IBM Plex Mono',monospace;font-size:9px;cursor:pointer">Terraform</button>`;
  html += `<button onclick="openIaCModal('arm')" style="padding:4px 10px;border-radius:4px;border:1px solid ${format==='arm'?'var(--accent-cyan)':'var(--border)'};background:${format==='arm'?'rgba(6,182,212,.1)':'transparent'};color:${format==='arm'?'var(--accent-cyan)':'var(--text-secondary)'};font-family:'IBM Plex Mono',monospace;font-size:9px;cursor:pointer">ARM</button>`;
  html += `<button onclick="openIaCModal('bicep')" style="padding:4px 10px;border-radius:4px;border:1px solid ${format==='bicep'?'var(--accent-cyan)':'var(--border)'};background:${format==='bicep'?'rgba(6,182,212,.1)':'transparent'};color:${format==='bicep'?'var(--accent-cyan)':'var(--text-secondary)'};font-family:'IBM Plex Mono',monospace;font-size:9px;cursor:pointer">Bicep</button>`;
  html += `</div>`;

  // Code preview
  html += `<div style="padding:8px 16px"><pre style="background:var(--bg-primary);border:1px solid var(--border);border-radius:6px;padding:12px;font-family:'IBM Plex Mono',monospace;font-size:10px;color:var(--text-secondary);max-height:60vh;overflow:auto;white-space:pre-wrap;word-break:break-all;line-height:1.6">${esc(code)}</pre></div>`;

  // Action buttons
  html += `<div style="padding:8px 16px;display:flex;gap:8px">`;
  html += `<button onclick="copyText(document.querySelector('#dpBody pre').textContent)" style="flex:1;padding:8px;background:var(--accent-blue);color:#fff;border:none;border-radius:6px;font-family:'IBM Plex Mono',monospace;font-size:10px;cursor:pointer;font-weight:600">Copy to Clipboard</button>`;
  html += `<button onclick="downloadIaC('${format}')" style="flex:1;padding:8px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:6px;color:var(--text-secondary);font-family:'IBM Plex Mono',monospace;font-size:10px;cursor:pointer">Download</button>`;
  html += `</div>`;

  openDetailPanel(title, `Infrastructure as Code | ${_lk.vnets.length} VNets, ${_lk.nsgs.length} NSGs`, html);
}

function downloadIaC(format) {
  if (!_lk) return;
  let code, filename;
  if (format === 'terraform') { code = generateTerraform(_lk); filename = 'azure-network.tf'; }
  else if (format === 'arm') { code = generateARM(_lk); filename = 'azure-network-template.json'; }
  else if (format === 'bicep') { code = generateBicep(_lk); filename = 'azure-network.bicep'; }
  if (!code) return;
  const blob = new Blob([code], { type: 'text/plain' });
  const a = document.createElement('a');
  a.download = filename;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
}

// ============================================================
// SVG EXPORT
// ============================================================

function exportSVG() {
  const svg = document.getElementById('mapSvg');
  const root = svg.querySelector('#mapRoot');
  if (!root) return;
  const bbox = root.getBBox();
  const pad = 40;
  const cloneSvg = svg.cloneNode(true);
  cloneSvg.setAttribute('width', bbox.width + pad * 2);
  cloneSvg.setAttribute('height', bbox.height + pad * 2);
  cloneSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  cloneSvg.querySelector('#mapRoot').setAttribute('transform', `translate(${-bbox.x + pad},${-bbox.y + pad})`);
  resolveCssVars(cloneSvg);

  // Add background
  const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  bg.setAttribute('width', '100%');
  bg.setAttribute('height', '100%');
  bg.setAttribute('fill', '#0a0e17');
  cloneSvg.insertBefore(bg, cloneSvg.firstChild);

  const svgStr = new XMLSerializer().serializeToString(cloneSvg);
  const blob = new Blob([svgStr], { type: 'image/svg+xml' });
  const a = document.createElement('a');
  a.download = 'azure-network-map.svg';
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
}

// ============================================================
// SNAPSHOTS + DIFF
// ============================================================

function saveSnapshot() {
  const data = getProjectData();
  const snapshots = JSON.parse(localStorage.getItem('azureNetMap_snapshots') || '[]');
  snapshots.push({ timestamp: new Date().toISOString(), data });
  // Keep max 20 snapshots
  while (snapshots.length > 20) snapshots.shift();
  localStorage.setItem('azureNetMap_snapshots', JSON.stringify(snapshots));
  const toast = document.getElementById('copyToast');
  toast.textContent = 'Snapshot saved';
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 1500);
}

function openSnapshotPanel() {
  const snapshots = JSON.parse(localStorage.getItem('azureNetMap_snapshots') || '[]');
  let html = '';

  html += `<div style="padding:12px 16px;border-bottom:1px solid var(--border)">`;
  html += `<button onclick="saveSnapshot()" style="width:100%;padding:8px;background:var(--accent-green);color:#fff;border:none;border-radius:6px;font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:600;cursor:pointer">Save Snapshot Now</button>`;
  html += `</div>`;

  if (snapshots.length === 0) {
    html += `<div style="padding:16px;text-align:center;color:var(--text-muted);font-family:'IBM Plex Mono',monospace;font-size:11px">No snapshots saved</div>`;
  } else {
    html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Saved Snapshots</span><span class="dp-sec-count">${snapshots.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
    snapshots.slice().reverse().forEach((snap, i) => {
      const dt = new Date(snap.timestamp);
      const label = dt.toLocaleDateString() + ' ' + dt.toLocaleTimeString();
      html += `<div class="dp-row" style="cursor:pointer" onclick="loadSnapshotData(${snapshots.length - 1 - i})">`;
      html += `<span class="val i">${esc(label)}</span>`;
      html += `</div>`;
    });
    html += `</div></div>`;
  }

  openDetailPanel('Snapshots', `${snapshots.length} saved`, html);
}

function loadSnapshotData(index) {
  const snapshots = JSON.parse(localStorage.getItem('azureNetMap_snapshots') || '[]');
  if (index >= 0 && index < snapshots.length) {
    loadProjectData(snapshots[index].data);
  }
}

// ============================================================
// DEMO DATA GENERATOR -- Azure Enterprise Hub-Spoke
// ============================================================

function generateDemo() {
  const SUB_ID = '00000000-1111-2222-3333-444444444444';
  const RG_HUB = 'rg-hub-eastus';
  const RG_PROD = 'rg-prod-eastus';
  const RG_DEV = 'rg-dev-eastus';
  const RG_DATA = 'rg-data-eastus';
  const LOC = 'eastus';

  function rid(rg, type, name) { return `/subscriptions/${SUB_ID}/resourceGroups/${rg}/providers/${type}/${name}` }
  function subnetId(rg, vnet, subnet) { return `${rid(rg, 'Microsoft.Network/virtualNetworks', vnet)}/subnets/${subnet}` }
  function nsgId(rg, name) { return rid(rg, 'Microsoft.Network/networkSecurityGroups', name) }
  function rtId(rg, name) { return rid(rg, 'Microsoft.Network/routeTables', name) }
  function nicId(rg, name) { return rid(rg, 'Microsoft.Network/networkInterfaces', name) }
  function pipId(rg, name) { return rid(rg, 'Microsoft.Network/publicIPAddresses', name) }
  function vmId(rg, name) { return rid(rg, 'Microsoft.Compute/virtualMachines', name) }
  function natId(rg, name) { return rid(rg, 'Microsoft.Network/natGateways', name) }
  function peId(rg, name) { return rid(rg, 'Microsoft.Network/privateEndpoints', name) }
  function fwId(rg, name) { return rid(rg, 'Microsoft.Network/azureFirewalls', name) }
  function bastionId(rg, name) { return rid(rg, 'Microsoft.Network/bastionHosts', name) }

  // NSG helper
  function makeNsg(rg, name, customRules) {
    return {
      id: nsgId(rg, name), name, location: LOC, resourceGroup: rg,
      securityRules: customRules || [],
      defaultSecurityRules: [
        { name: 'AllowVnetInBound', priority: 65000, direction: 'Inbound', access: 'Allow', protocol: '*', sourceAddressPrefix: 'VirtualNetwork', destinationAddressPrefix: 'VirtualNetwork', destinationPortRange: '*' },
        { name: 'AllowAzureLoadBalancerInBound', priority: 65001, direction: 'Inbound', access: 'Allow', protocol: '*', sourceAddressPrefix: 'AzureLoadBalancer', destinationAddressPrefix: '*', destinationPortRange: '*' },
        { name: 'DenyAllInBound', priority: 65500, direction: 'Inbound', access: 'Deny', protocol: '*', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '*' },
        { name: 'AllowVnetOutBound', priority: 65000, direction: 'Outbound', access: 'Allow', protocol: '*', sourceAddressPrefix: 'VirtualNetwork', destinationAddressPrefix: 'VirtualNetwork', destinationPortRange: '*' },
        { name: 'AllowInternetOutBound', priority: 65001, direction: 'Outbound', access: 'Allow', protocol: '*', sourceAddressPrefix: '*', destinationAddressPrefix: 'Internet', destinationPortRange: '*' },
        { name: 'DenyAllOutBound', priority: 65500, direction: 'Outbound', access: 'Deny', protocol: '*', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '*' },
      ],
      subnets: [], networkInterfaces: []
    };
  }

  // NSGs
  const nsgWebProd = makeNsg(RG_PROD, 'nsg-prod-web', [
    { name: 'AllowHTTPS', priority: 100, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '443' },
    { name: 'AllowHTTP', priority: 110, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '80' },
    { name: 'DenyAllInbound', priority: 4000, direction: 'Inbound', access: 'Deny', protocol: '*', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '*' },
  ]);
  const nsgAppProd = makeNsg(RG_PROD, 'nsg-prod-app', [
    { name: 'AllowWebTier', priority: 100, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '10.1.1.0/24', destinationAddressPrefix: '*', destinationPortRange: '8080' },
    { name: 'DenyInternet', priority: 4000, direction: 'Inbound', access: 'Deny', protocol: '*', sourceAddressPrefix: 'Internet', destinationAddressPrefix: '*', destinationPortRange: '*' },
  ]);
  const nsgDataProd = makeNsg(RG_PROD, 'nsg-prod-data', [
    { name: 'AllowAppTier', priority: 100, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '10.1.2.0/24', destinationAddressPrefix: '*', destinationPortRange: '1433' },
    { name: 'DenyAll', priority: 4000, direction: 'Inbound', access: 'Deny', protocol: '*', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '*' },
  ]);
  const nsgHubMgmt = makeNsg(RG_HUB, 'nsg-hub-mgmt', [
    { name: 'AllowSSHFromBastion', priority: 100, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '10.0.0.64/26', destinationAddressPrefix: '*', destinationPortRange: '22' },
    { name: 'AllowRDPFromBastion', priority: 110, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '10.0.0.64/26', destinationAddressPrefix: '*', destinationPortRange: '3389' },
  ]);
  const nsgDevWeb = makeNsg(RG_DEV, 'nsg-dev-web', [
    { name: 'AllowHTTPS', priority: 100, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '443' },
    { name: 'AllowSSH', priority: 200, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '22' },
    { name: 'AllowRDP', priority: 210, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '3389' },
  ]);

  const nsgs = [nsgWebProd, nsgAppProd, nsgDataProd, nsgHubMgmt, nsgDevWeb];

  // Route Tables
  const rtProdSpoke = {
    id: rtId(RG_PROD, 'rt-prod-spoke'), name: 'rt-prod-spoke', location: LOC,
    routes: [
      { name: 'to-internet-via-fw', addressPrefix: '0.0.0.0/0', nextHopType: 'VirtualAppliance', nextHopIpAddress: '10.0.0.4' },
      { name: 'to-hub', addressPrefix: '10.0.0.0/16', nextHopType: 'VnetLocal' },
    ],
    subnets: []
  };
  const rtDevSpoke = {
    id: rtId(RG_DEV, 'rt-dev-spoke'), name: 'rt-dev-spoke', location: LOC,
    routes: [
      { name: 'to-internet-via-fw', addressPrefix: '0.0.0.0/0', nextHopType: 'VirtualAppliance', nextHopIpAddress: '10.0.0.4' },
    ],
    subnets: []
  };
  const routeTables = [rtProdSpoke, rtDevSpoke];

  // VNets with subnets
  const vnetHub = {
    id: rid(RG_HUB, 'Microsoft.Network/virtualNetworks', 'vnet-hub-eastus'),
    name: 'vnet-hub-eastus', location: LOC, resourceGroup: RG_HUB,
    addressSpace: { addressPrefixes: ['10.0.0.0/16'] },
    subnets: [
      { id: subnetId(RG_HUB, 'vnet-hub-eastus', 'AzureFirewallSubnet'), name: 'AzureFirewallSubnet', addressPrefix: '10.0.0.0/26' },
      { id: subnetId(RG_HUB, 'vnet-hub-eastus', 'AzureBastionSubnet'), name: 'AzureBastionSubnet', addressPrefix: '10.0.0.64/26',
        networkSecurityGroup: null },
      { id: subnetId(RG_HUB, 'vnet-hub-eastus', 'GatewaySubnet'), name: 'GatewaySubnet', addressPrefix: '10.0.0.128/27' },
      { id: subnetId(RG_HUB, 'vnet-hub-eastus', 'snet-hub-mgmt'), name: 'snet-hub-mgmt', addressPrefix: '10.0.1.0/24',
        networkSecurityGroup: { id: nsgHubMgmt.id }, routeTable: null },
      { id: subnetId(RG_HUB, 'vnet-hub-eastus', 'snet-hub-shared'), name: 'snet-hub-shared', addressPrefix: '10.0.2.0/24' },
    ]
  };

  const vnetProd = {
    id: rid(RG_PROD, 'Microsoft.Network/virtualNetworks', 'vnet-spoke-prod'),
    name: 'vnet-spoke-prod', location: LOC, resourceGroup: RG_PROD,
    addressSpace: { addressPrefixes: ['10.1.0.0/16'] },
    subnets: [
      { id: subnetId(RG_PROD, 'vnet-spoke-prod', 'snet-prod-web'), name: 'snet-prod-web', addressPrefix: '10.1.1.0/24',
        networkSecurityGroup: { id: nsgWebProd.id }, routeTable: { id: rtProdSpoke.id },
        natGateway: { id: natId(RG_PROD, 'nat-prod-web') } },
      { id: subnetId(RG_PROD, 'vnet-spoke-prod', 'snet-prod-app'), name: 'snet-prod-app', addressPrefix: '10.1.2.0/24',
        networkSecurityGroup: { id: nsgAppProd.id }, routeTable: { id: rtProdSpoke.id } },
      { id: subnetId(RG_PROD, 'vnet-spoke-prod', 'snet-prod-data'), name: 'snet-prod-data', addressPrefix: '10.1.3.0/24',
        networkSecurityGroup: { id: nsgDataProd.id }, routeTable: { id: rtProdSpoke.id } },
      { id: subnetId(RG_PROD, 'vnet-spoke-prod', 'snet-prod-aks'), name: 'snet-prod-aks', addressPrefix: '10.1.4.0/22',
        routeTable: { id: rtProdSpoke.id } },
      { id: subnetId(RG_PROD, 'vnet-spoke-prod', 'snet-prod-func'), name: 'snet-prod-func', addressPrefix: '10.1.8.0/24' },
      { id: subnetId(RG_PROD, 'vnet-spoke-prod', 'snet-prod-lb'), name: 'snet-prod-lb', addressPrefix: '10.1.9.0/24',
        networkSecurityGroup: { id: nsgAppProd.id }, routeTable: { id: rtProdSpoke.id } },
    ]
  };

  const vnetDev = {
    id: rid(RG_DEV, 'Microsoft.Network/virtualNetworks', 'vnet-spoke-dev'),
    name: 'vnet-spoke-dev', location: LOC, resourceGroup: RG_DEV,
    addressSpace: { addressPrefixes: ['10.2.0.0/16'] },
    subnets: [
      { id: subnetId(RG_DEV, 'vnet-spoke-dev', 'snet-dev-web'), name: 'snet-dev-web', addressPrefix: '10.2.1.0/24',
        networkSecurityGroup: { id: nsgDevWeb.id }, routeTable: { id: rtDevSpoke.id } },
      { id: subnetId(RG_DEV, 'vnet-spoke-dev', 'snet-dev-app'), name: 'snet-dev-app', addressPrefix: '10.2.2.0/24',
        routeTable: { id: rtDevSpoke.id } },
      { id: subnetId(RG_DEV, 'vnet-spoke-dev', 'snet-dev-data'), name: 'snet-dev-data', addressPrefix: '10.2.3.0/24' },
    ]
  };

  const vnetData = {
    id: rid(RG_DATA, 'Microsoft.Network/virtualNetworks', 'vnet-spoke-data'),
    name: 'vnet-spoke-data', location: LOC, resourceGroup: RG_DATA,
    addressSpace: { addressPrefixes: ['10.3.0.0/16'] },
    subnets: [
      { id: subnetId(RG_DATA, 'vnet-spoke-data', 'snet-data-sql'), name: 'snet-data-sql', addressPrefix: '10.3.1.0/24' },
      { id: subnetId(RG_DATA, 'vnet-spoke-data', 'snet-data-redis'), name: 'snet-data-redis', addressPrefix: '10.3.2.0/24' },
      { id: subnetId(RG_DATA, 'vnet-spoke-data', 'snet-data-storage'), name: 'snet-data-storage', addressPrefix: '10.3.3.0/24' },
    ]
  };

  const vnets = [vnetHub, vnetProd, vnetDev, vnetData];

  // NICs and VMs
  function makeNicAndVm(rg, vmName, subnetRef, privateIp, pipRef, nsgRef, size, powerState) {
    const nName = `nic-${vmName}`;
    const nic = {
      id: nicId(rg, nName), name: nName, location: LOC,
      ipConfigurations: [{ name: 'ipconfig1', subnet: subnetRef, privateIpAddress: privateIp, primary: true, publicIpAddress: pipRef || null }],
      networkSecurityGroup: nsgRef || null,
      virtualMachine: { id: vmId(rg, vmName) }, macAddress: '00-0D-3A-' + (Math.random().toString(16).substr(2, 8).padEnd(8, '0').match(/../g) || ['00','00','00','00']).join('-').toUpperCase().substring(0, 8)
    };
    const vm = {
      id: vmId(rg, vmName), name: vmName, location: LOC, resourceGroup: rg,
      hardwareProfile: { vmSize: size },
      powerState: powerState,
      networkProfile: { networkInterfaces: [{ id: nic.id, primary: true }] },
      storageProfile: { osDisk: { name: `${vmName}-osdisk`, osType: 'Linux', diskSizeGb: 128 } },
      zones: ['1']
    };
    return { nic, vm };
  }

  const nicsAndVms = [
    makeNicAndVm(RG_PROD, 'vm-prod-web-01', { id: vnetProd.subnets[0].id }, '10.1.1.4', null, null, 'Standard_D4s_v5', 'VM running'),
    makeNicAndVm(RG_PROD, 'vm-prod-web-02', { id: vnetProd.subnets[0].id }, '10.1.1.5', null, null, 'Standard_D4s_v5', 'VM running'),
    makeNicAndVm(RG_PROD, 'vm-prod-app-01', { id: vnetProd.subnets[1].id }, '10.1.2.4', null, null, 'Standard_D8s_v5', 'VM running'),
    makeNicAndVm(RG_PROD, 'vm-prod-app-02', { id: vnetProd.subnets[1].id }, '10.1.2.5', null, null, 'Standard_D8s_v5', 'VM running'),
    makeNicAndVm(RG_HUB, 'vm-hub-jumpbox', { id: vnetHub.subnets[3].id }, '10.0.1.4', null, null, 'Standard_B2ms', 'VM running'),
    makeNicAndVm(RG_HUB, 'vm-hub-dns', { id: vnetHub.subnets[4].id }, '10.0.2.4', null, null, 'Standard_B2ms', 'VM running'),
    makeNicAndVm(RG_DEV, 'vm-dev-web-01', { id: vnetDev.subnets[0].id }, '10.2.1.4', null, null, 'Standard_B2ms', 'VM running'),
    makeNicAndVm(RG_DEV, 'vm-dev-app-01', { id: vnetDev.subnets[1].id }, '10.2.2.4', null, null, 'Standard_B4ms', 'VM deallocated'),
  ];

  const nics = nicsAndVms.map(x => x.nic);
  const vms = nicsAndVms.map(x => x.vm);

  // Public IPs
  const publicIps = [
    { id: pipId(RG_HUB, 'pip-fw-eastus'), name: 'pip-fw-eastus', location: LOC, ipAddress: '20.85.100.10', publicIpAllocationMethod: 'Static', sku: { name: 'Standard' }, zones: ['1','2','3'] },
    { id: pipId(RG_HUB, 'pip-bastion-eastus'), name: 'pip-bastion-eastus', location: LOC, ipAddress: '20.85.100.11', publicIpAllocationMethod: 'Static', sku: { name: 'Standard' } },
    { id: pipId(RG_PROD, 'pip-nat-prod-web'), name: 'pip-nat-prod-web', location: LOC, ipAddress: '20.85.100.20', publicIpAllocationMethod: 'Static', sku: { name: 'Standard' } },
    { id: pipId(RG_PROD, 'pip-appgw-prod'), name: 'pip-appgw-prod', location: LOC, ipAddress: '20.85.100.21', publicIpAllocationMethod: 'Static', sku: { name: 'Standard' } },
  ];

  // NAT Gateways
  const natGateways = [
    { id: natId(RG_PROD, 'nat-prod-web'), name: 'nat-prod-web', location: LOC,
      publicIpAddresses: [{ id: pipId(RG_PROD, 'pip-nat-prod-web') }],
      subnets: [{ id: vnetProd.subnets[0].id }], idleTimeoutInMinutes: 10, zones: ['1'] },
  ];

  // Private Endpoints
  const privateEndpoints = [
    { id: peId(RG_PROD, 'pe-sql-prod'), name: 'pe-sql-prod', location: LOC,
      subnet: { id: vnetProd.subnets[2].id },
      privateLinkServiceConnections: [{ name: 'plsc-sql', privateLinkServiceId: rid(RG_DATA, 'Microsoft.Sql/servers', 'sql-prod-eastus'), groupIds: ['sqlServer'] }] },
    { id: peId(RG_DATA, 'pe-storage-data'), name: 'pe-storage-data', location: LOC,
      subnet: { id: vnetData.subnets[2].id },
      privateLinkServiceConnections: [{ name: 'plsc-storage', privateLinkServiceId: rid(RG_DATA, 'Microsoft.Storage/storageAccounts', 'stproddata01'), groupIds: ['blob'] }] },
    { id: peId(RG_DATA, 'pe-redis-data'), name: 'pe-redis-data', location: LOC,
      subnet: { id: vnetData.subnets[1].id },
      privateLinkServiceConnections: [{ name: 'plsc-redis', privateLinkServiceId: rid(RG_DATA, 'Microsoft.Cache/Redis', 'redis-prod-eastus'), groupIds: ['redisCache'] }] },
    { id: peId(RG_DATA, 'pe-sql-data'), name: 'pe-sql-data', location: LOC,
      subnet: { id: vnetData.subnets[0].id },
      privateLinkServiceConnections: [{ name: 'plsc-sql2', privateLinkServiceId: rid(RG_DATA, 'Microsoft.Sql/servers', 'sql-prod-eastus'), groupIds: ['sqlServer'] }] },
  ];

  // Peerings (hub <-> spoke)
  function makePeering(srcVnet, dstVnet, srcRg) {
    const srcName = shortName(srcVnet);
    const dstName = shortName(dstVnet);
    return {
      id: `${srcVnet.id}/virtualNetworkPeerings/peer-${srcName}-to-${dstName}`,
      name: `peer-${srcName}-to-${dstName}`,
      remoteVirtualNetwork: { id: dstVnet.id },
      peeringState: 'Connected',
      allowVirtualNetworkAccess: true, allowForwardedTraffic: true,
      allowGatewayTransit: srcName.includes('hub'), useRemoteGateways: !srcName.includes('hub')
    };
  }

  const peerings = [
    makePeering(vnetHub, vnetProd, RG_HUB), makePeering(vnetProd, vnetHub, RG_PROD),
    makePeering(vnetHub, vnetDev, RG_HUB), makePeering(vnetDev, vnetHub, RG_DEV),
    makePeering(vnetHub, vnetData, RG_HUB), makePeering(vnetData, vnetHub, RG_DATA),
  ];

  // Firewalls
  const firewalls = [{
    id: fwId(RG_HUB, 'fw-hub-eastus'), name: 'fw-hub-eastus', location: LOC,
    ipConfigurations: [{ name: 'fwconfig', subnet: { id: vnetHub.subnets[0].id }, publicIPAddress: { id: pipId(RG_HUB, 'pip-fw-eastus') } }],
    threatIntelMode: 'Alert', sku: { name: 'AZFW_VNet', tier: 'Standard' }
  }];

  // Bastions
  const bastions = [{
    id: bastionId(RG_HUB, 'bastion-hub-eastus'), name: 'bastion-hub-eastus', location: LOC,
    ipConfigurations: [{ subnet: { id: vnetHub.subnets[1].id }, publicIPAddress: { id: pipId(RG_HUB, 'pip-bastion-eastus') } }],
    sku: { name: 'Standard' }
  }];

  // Resource Groups
  const resourceGroups = [
    { id: `/subscriptions/${SUB_ID}/resourceGroups/${RG_HUB}`, name: RG_HUB, location: LOC, tags: { env: 'hub' } },
    { id: `/subscriptions/${SUB_ID}/resourceGroups/${RG_PROD}`, name: RG_PROD, location: LOC, tags: { env: 'production' } },
    { id: `/subscriptions/${SUB_ID}/resourceGroups/${RG_DEV}`, name: RG_DEV, location: LOC, tags: { env: 'development' } },
    { id: `/subscriptions/${SUB_ID}/resourceGroups/${RG_DATA}`, name: RG_DATA, location: LOC, tags: { env: 'data' } },
  ];

  // Function Apps
  const functionApps = [
    { id: rid(RG_PROD, 'Microsoft.Web/sites', 'func-prod-api'), name: 'func-prod-api', location: LOC, kind: 'functionapp,linux', state: 'Running',
      virtualNetworkSubnetId: vnetProd.subnets[4].id, defaultHostName: 'func-prod-api.azurewebsites.net', resourceGroup: RG_PROD },
  ];

  // Storage Accounts
  const storageAccounts = [
    { id: rid(RG_DATA, 'Microsoft.Storage/storageAccounts', 'stproddata01'), name: 'stproddata01', location: LOC,
      primaryEndpoints: { blob: 'https://stproddata01.blob.core.windows.net/' },
      encryption: { services: { blob: { enabled: true } } }, allowBlobPublicAccess: false, minimumTlsVersion: 'TLS1_2',
      networkRuleSet: { defaultAction: 'Deny', virtualNetworkRules: [{ id: vnetData.subnets[2].id }] } },
  ];

  // SQL Servers
  const sqlServers = [
    { id: rid(RG_DATA, 'Microsoft.Sql/servers', 'sql-prod-eastus'), name: 'sql-prod-eastus', location: LOC,
      fullyQualifiedDomainName: 'sql-prod-eastus.database.windows.net', administratorLogin: 'sqladmin', resourceGroup: RG_DATA },
  ];

  const sqlDatabases = [
    { id: `${rid(RG_DATA, 'Microsoft.Sql/servers', 'sql-prod-eastus')}/databases/db-orders`, name: 'db-orders', sku: { name: 'S3', tier: 'Standard' }, maxSizeBytes: 268435456000, status: 'Online' },
    { id: `${rid(RG_DATA, 'Microsoft.Sql/servers', 'sql-prod-eastus')}/databases/db-users`, name: 'db-users', sku: { name: 'S2', tier: 'Standard' }, maxSizeBytes: 268435456000, status: 'Online' },
  ];

  // Redis
  const redisCaches = [
    { id: rid(RG_DATA, 'Microsoft.Cache/Redis', 'redis-prod-eastus'), name: 'redis-prod-eastus', location: LOC,
      hostName: 'redis-prod-eastus.redis.cache.windows.net', port: 6380, sslPort: 6380,
      sku: { name: 'Premium', family: 'P', capacity: 1 }, shardCount: 2 },
  ];

  // App Gateways
  const appGateways = [{
    id: rid(RG_PROD, 'Microsoft.Network/applicationGateways', 'appgw-prod-web'),
    name: 'appgw-prod-web', location: LOC,
    gatewayIpConfigurations: [{ name: 'gwip', subnet: { id: vnetProd.subnets[0].id } }],
    frontendIpConfigurations: [{ publicIpAddress: { id: pipId(RG_PROD, 'pip-appgw-prod') } }],
    backendAddressPools: [{ name: 'pool-web', backendAddresses: [{ ipAddress: '10.1.1.4' }, { ipAddress: '10.1.1.5' }] }],
    sku: { name: 'WAF_v2', tier: 'WAF_v2', capacity: 2 },
  }];

  // Additional Public IPs
  publicIps.push(
    { id: pipId(RG_PROD, 'pip-lb-prod-web'), name: 'pip-lb-prod-web', location: LOC, ipAddress: '20.85.100.30', publicIpAllocationMethod: 'Static', sku: { name: 'Standard' }, zones: ['1','2','3'] },
    { id: pipId(RG_DEV, 'pip-appgw-dev'), name: 'pip-appgw-dev', location: LOC, ipAddress: '20.85.100.40', publicIpAllocationMethod: 'Static', sku: { name: 'Standard' } }
  );

  // Load Balancers
  const loadBalancers = [
    // Internal LB fronting app tier
    { id: rid(RG_PROD, 'Microsoft.Network/loadBalancers', 'lb-prod-app-internal'),
      name: 'lb-prod-app-internal', location: LOC,
      sku: { name: 'Standard' },
      frontendIPConfigurations: [{ name: 'fe-internal', privateIPAddress: '10.1.9.4', subnet: { id: subnetId(RG_PROD, 'vnet-spoke-prod', 'snet-prod-lb') } }],
      backendAddressPools: [{ name: 'pool-app', loadBalancerBackendAddresses: [
        { name: 'vm-prod-app-01', ipAddress: '10.1.2.4' },
        { name: 'vm-prod-app-02', ipAddress: '10.1.2.5' },
      ]}],
      loadBalancingRules: [
        { name: 'rule-http', protocol: 'Tcp', frontendPort: 8080, backendPort: 8080 },
        { name: 'rule-https', protocol: 'Tcp', frontendPort: 8443, backendPort: 8443 },
      ],
      probes: [
        { name: 'probe-http', protocol: 'Http', port: 8080, intervalInSeconds: 15 },
        { name: 'probe-https', protocol: 'Https', port: 8443, intervalInSeconds: 15 },
      ]
    },
    // Public LB fronting web tier
    { id: rid(RG_PROD, 'Microsoft.Network/loadBalancers', 'lb-prod-web-public'),
      name: 'lb-prod-web-public', location: LOC,
      sku: { name: 'Standard' },
      frontendIPConfigurations: [{ name: 'fe-public', publicIpAddress: { id: pipId(RG_PROD, 'pip-lb-prod-web') } }],
      backendAddressPools: [{ name: 'pool-web', loadBalancerBackendAddresses: [
        { name: 'vm-prod-web-01', ipAddress: '10.1.1.4' },
        { name: 'vm-prod-web-02', ipAddress: '10.1.1.5' },
      ]}],
      loadBalancingRules: [
        { name: 'rule-https', protocol: 'Tcp', frontendPort: 443, backendPort: 443 },
        { name: 'rule-http', protocol: 'Tcp', frontendPort: 80, backendPort: 80 },
      ],
      probes: [
        { name: 'probe-https', protocol: 'Https', port: 443, intervalInSeconds: 10 },
      ]
    },
  ];

  // Managed Disks (data disks attached to VMs)
  const disks = [
    { id: rid(RG_PROD, 'Microsoft.Compute/disks', 'disk-prod-web-01-data'), name: 'disk-prod-web-01-data',
      location: LOC, sku: { name: 'Premium_LRS' }, diskSizeGb: 256,
      managedBy: vmId(RG_PROD, 'vm-prod-web-01') },
    { id: rid(RG_PROD, 'Microsoft.Compute/disks', 'disk-prod-web-02-data'), name: 'disk-prod-web-02-data',
      location: LOC, sku: { name: 'Premium_LRS' }, diskSizeGb: 256,
      managedBy: vmId(RG_PROD, 'vm-prod-web-02') },
    { id: rid(RG_PROD, 'Microsoft.Compute/disks', 'disk-prod-app-01-data'), name: 'disk-prod-app-01-data',
      location: LOC, sku: { name: 'Premium_LRS' }, diskSizeGb: 512,
      managedBy: vmId(RG_PROD, 'vm-prod-app-01') },
    { id: rid(RG_PROD, 'Microsoft.Compute/disks', 'disk-prod-app-02-data'), name: 'disk-prod-app-02-data',
      location: LOC, sku: { name: 'Premium_LRS' }, diskSizeGb: 512,
      managedBy: vmId(RG_PROD, 'vm-prod-app-02') },
    { id: rid(RG_HUB, 'Microsoft.Compute/disks', 'disk-hub-jumpbox-data'), name: 'disk-hub-jumpbox-data',
      location: LOC, sku: { name: 'StandardSSD_LRS' }, diskSizeGb: 64,
      managedBy: vmId(RG_HUB, 'vm-hub-jumpbox') },
  ];

  // Second storage account — intentional compliance violations for demo
  storageAccounts.push(
    { id: rid(RG_DEV, 'Microsoft.Storage/storageAccounts', 'stdevdata01'), name: 'stdevdata01', location: LOC,
      primaryEndpoints: { blob: 'https://stdevdata01.blob.core.windows.net/' },
      encryption: { services: { blob: { enabled: true } } },
      allowBlobPublicAccess: true,            // ARCH-S1 violation: public blob access
      minimumTlsVersion: 'TLS1_0',           // SOC2-CC6.1 violation: old TLS
      networkRuleSet: { defaultAction: 'Allow', virtualNetworkRules: [] } } // ARCH-S2 violation: open network
  );

  // Second App Gateway without WAF — WAF-1 compliance violation
  appGateways.push({
    id: rid(RG_DEV, 'Microsoft.Network/applicationGateways', 'appgw-dev-web'),
    name: 'appgw-dev-web', location: LOC,
    gatewayIpConfigurations: [{ name: 'gwip', subnet: { id: subnetId(RG_DEV, 'vnet-spoke-dev', 'snet-dev-web') } }],
    frontendIpConfigurations: [{ publicIpAddress: { id: pipId(RG_DEV, 'pip-appgw-dev') } }],
    backendAddressPools: [{ name: 'pool-dev-web', backendAddresses: [{ ipAddress: '10.2.1.4' }] }],
    sku: { name: 'Standard_v2', tier: 'Standard_v2', capacity: 1 },  // No WAF! WAF-1 violation
  });

  // Set textarea values
  function setInput(id, data) {
    const el = document.getElementById(id);
    if (el) { el.value = JSON.stringify(data, null, 2); el.className = 'ji valid' }
  }

  setInput('in_vnets', vnets);
  setInput('in_nsgs', nsgs);
  setInput('in_rts', routeTables);
  setInput('in_nics', nics);
  setInput('in_pips', publicIps);
  setInput('in_natgws', natGateways);
  setInput('in_pes', privateEndpoints);
  setInput('in_vms', vms);
  setInput('in_funcs', functionApps);
  setInput('in_peerings', peerings);
  setInput('in_firewalls', firewalls);
  setInput('in_bastions', bastions);
  setInput('in_rgs', resourceGroups);
  setInput('in_storage', storageAccounts);
  setInput('in_sqlservers', sqlServers);
  setInput('in_sqldbs', sqlDatabases);
  setInput('in_redis', redisCaches);
  setInput('in_appgws', appGateways);
  setInput('in_lbs', loadBalancers);
  setInput('in_disks', disks);

  // Auto-render
  renderMap();
}

// ============================================================
// ZOOM / PAN / SEARCH / SAVE-LOAD / KEYBOARD / ELECTRON
// ============================================================

// ---- Zoom Controls ----
function zoomFit() {
  const svg = d3.select('#mapSvg');
  const root = svg.select('#mapRoot');
  if (!root.node() || !zB) return;
  const bounds = root.node().getBBox();
  if (bounds.width === 0 || bounds.height === 0) return;

  const svgEl = svg.node();
  const fullW = svgEl.clientWidth;
  const fullH = svgEl.clientHeight;
  const pad = 60;
  const scale = Math.min((fullW - pad * 2) / bounds.width, (fullH - pad * 2) / bounds.height, 2);
  const tx = fullW / 2 - (bounds.x + bounds.width / 2) * scale;
  const ty = fullH / 2 - (bounds.y + bounds.height / 2) * scale;

  svg.transition().duration(500)
    .call(zB.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

document.getElementById('zoomIn').addEventListener('click', () => {
  const svg = d3.select('#mapSvg');
  if (zB) svg.transition().duration(200).call(zB.scaleBy, 1.4);
});
document.getElementById('zoomOut').addEventListener('click', () => {
  const svg = d3.select('#mapSvg');
  if (zB) svg.transition().duration(200).call(zB.scaleBy, 0.7);
});
document.getElementById('zoomFit').addEventListener('click', zoomFit);

// ---- Search ----
let _searchIndex = [];

function buildSearchIndex(lk) {
  const idx = [];
  lk.vnets.forEach(v => idx.push({ type: 'VNet', name: v.name, id: v.id, cidr: v.addressSpace?.addressPrefixes?.join(', '), resource: v }));
  lk.subnets.forEach(s => idx.push({ type: 'Subnet', name: s.name || shortName(s), id: s.id, cidr: s.addressPrefix, resource: s }));
  lk.nsgs.forEach(n => idx.push({ type: 'NSG', name: n.name, id: n.id, resource: n }));
  lk.vms.forEach(v => idx.push({ type: 'VM', name: v.name, id: v.id, resource: v }));
  lk.nics.forEach(n => idx.push({ type: 'NIC', name: n.name, id: n.id, resource: n }));
  lk.publicIps.forEach(p => idx.push({ type: 'Public IP', name: p.name, id: p.id, extra: p.ipAddress, resource: p }));
  lk.natGateways.forEach(n => idx.push({ type: 'NAT GW', name: n.name, id: n.id, resource: n }));
  lk.privateEndpoints.forEach(p => idx.push({ type: 'Private Endpoint', name: p.name, id: p.id, resource: p }));
  lk.appGateways.forEach(a => idx.push({ type: 'App Gateway', name: a.name, id: a.id, resource: a }));
  lk.loadBalancers.forEach(l => idx.push({ type: 'Load Balancer', name: l.name, id: l.id, resource: l }));
  lk.firewalls.forEach(f => idx.push({ type: 'Firewall', name: f.name, id: f.id, resource: f }));
  lk.bastions.forEach(b => idx.push({ type: 'Bastion', name: b.name, id: b.id, resource: b }));
  lk.routeTables.forEach(r => idx.push({ type: 'Route Table', name: r.name, id: r.id, resource: r }));
  lk.peerings.forEach(p => idx.push({ type: 'Peering', name: p.name, id: p.id, extra: p.remoteVirtualNetwork?.id ? shortName(p.remoteVirtualNetwork.id) : '', resource: p }));
  lk.storageAccounts.forEach(s => idx.push({ type: 'Storage', name: s.name, id: s.id, resource: s }));
  lk.sqlServers.forEach(s => idx.push({ type: 'SQL Server', name: s.name, id: s.id, extra: s.fullyQualifiedDomainName, resource: s }));
  lk.redisCaches.forEach(r => idx.push({ type: 'Redis', name: r.name, id: r.id, extra: r.hostName, resource: r }));
  lk.functionApps.forEach(f => idx.push({ type: 'Function App', name: f.name, id: f.id, extra: f.defaultHostName, resource: f }));
  if (lk.resourceGroups) lk.resourceGroups.forEach(r => idx.push({ type: 'Resource Group', name: r.name, id: r.id, extra: r.location, resource: r }));
  _searchIndex = idx;
}

function openSearch() {
  if (_lk.vnets) buildSearchIndex(_lk);
  document.getElementById('searchOverlay').style.display = 'block';
  const input = document.getElementById('searchInput');
  input.value = '';
  input.focus();
  document.getElementById('searchResults').innerHTML = '';
}

function closeSearch() {
  document.getElementById('searchOverlay').style.display = 'none';
}

document.getElementById('searchBtn').addEventListener('click', openSearch);
document.getElementById('searchBackdrop').addEventListener('click', closeSearch);

document.getElementById('searchInput').addEventListener('input', function() {
  const q = this.value.toLowerCase().trim();
  const results = document.getElementById('searchResults');
  if (!q) { results.innerHTML = ''; return }

  const matches = _searchIndex.filter(item => {
    return (item.name && item.name.toLowerCase().includes(q)) ||
           (item.id && item.id.toLowerCase().includes(q)) ||
           (item.cidr && item.cidr.toLowerCase().includes(q)) ||
           (item.extra && item.extra.toLowerCase().includes(q)) ||
           (item.type && item.type.toLowerCase().includes(q));
  }).slice(0, 20);

  results.innerHTML = matches.map(m => {
    const display = m.name || shortName(m.id);
    return `<div style="padding:8px 12px;cursor:pointer;border-bottom:1px solid var(--border);font-family:'IBM Plex Mono',monospace;font-size:12px;transition:background .15s" onmouseover="this.style.background='rgba(59,130,246,.1)'" onmouseout="this.style.background='transparent'" onclick="handleSearchClick('${esc(m.type)}','${esc(m.id || '')}')">
      <span style="color:var(--accent-cyan);font-size:9px;text-transform:uppercase;margin-right:6px">${esc(m.type)}</span>
      <span style="color:var(--text-primary)">${esc(display)}</span>
      ${m.cidr ? `<span style="color:var(--text-muted);font-size:10px;margin-left:8px">${esc(m.cidr)}</span>` : ''}
      ${m.extra ? `<span style="color:var(--accent-green);font-size:10px;margin-left:8px">${esc(m.extra)}</span>` : ''}
    </div>`;
  }).join('');

  if (matches.length === 0) {
    results.innerHTML = '<div style="padding:12px;color:var(--text-muted);font-size:11px;text-align:center">No results</div>';
  }
});

function handleSearchClick(type, id) {
  closeSearch();
  if (type === 'VM' && id) openVMPanel(id);
  else if (type === 'NSG' && id) openNSGPanel(id);
  else if (type === 'NIC' && id) openNICPanel(id);
  else if (type === 'Public IP' && id) openPublicIPPanel(id);
  else if (type === 'NAT GW' && id) openNATPanel(id);
  else if (type === 'Private Endpoint' && id) openPEPanel(id);
  else if (type === 'App Gateway' && id) openAppGwPanel(id);
  else if (type === 'Load Balancer' && id) openLBPanel(id);
  else if (type === 'Firewall' && id) openFirewallPanel(id);
  else if (type === 'Bastion' && id) openBastionPanel(id);
  else if (type === 'Route Table' && id) openRouteTablePanel(id);
  else if (type === 'Storage' && id) openStoragePanel(id);
  else if (type === 'SQL Server' && id) openSQLPanel(id);
  else if (type === 'Redis' && id) openRedisPanel(id);
  else if (type === 'Function App' && id) openFuncPanel(id);
  else if (type === 'Peering' && id) openPeeringPanel(id);
  else if (type === 'VNet' && id) {
    const vnet = _lk.vnetById[id.toLowerCase()];
    if (vnet) openVNetPanel(vnet, _lk);
  }
  else if (type === 'Subnet' && id) {
    const sub = _lk.subnetById[id.toLowerCase()];
    if (sub) {
      for (const vnet of _lk.vnets) {
        const subs = _lk.subnetsByVnet[vnet.id] || [];
        if (subs.some(s => s.id === sub.id)) {
          openSubnetPanel(sub, vnet, _lk);
          break;
        }
      }
    }
  }
  zoomToResource(id);
}

function zoomToResource(id) {
  if (!id || !zB) return;
  const svg = d3.select('#mapSvg');
  // CSS.escape prevents selector injection from resource IDs containing "]
  const safeId = CSS.escape(id);
  const node = svg.select(`[data-subnet-id="${safeId}"]`).node() ||
               svg.select(`[data-vnet-id="${safeId}"]`).node();
  if (!node) return;
  const bbox = node.getBBox();
  const svgEl = svg.node();
  const scale = Math.min(svgEl.clientWidth / (bbox.width + 100), svgEl.clientHeight / (bbox.height + 100), 2);
  const tx = svgEl.clientWidth / 2 - (bbox.x + bbox.width / 2) * scale;
  const ty = svgEl.clientHeight / 2 - (bbox.y + bbox.height / 2) * scale;
  svg.transition().duration(400).call(zB.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

// ---- Export Bar Toggle ----
document.getElementById('ebToggle').addEventListener('click', () => {
  document.getElementById('exportBar').classList.toggle('collapsed');
});

// ---- PNG Export ----
function resolveCssVars(svgEl) {
  // Resolve all var(--xxx) references to computed hex values for standalone SVG
  const computed = getComputedStyle(document.documentElement);
  const varMap = {};
  const rootStyle = document.documentElement.style;
  // Collect all CSS custom properties from :root
  for (const sheet of document.styleSheets) {
    try {
      for (const rule of sheet.cssRules) {
        if (rule.selectorText === ':root') {
          for (const prop of rule.style) {
            if (prop.startsWith('--')) varMap[prop] = rule.style.getPropertyValue(prop).trim();
          }
        }
      }
    } catch(e) {} // skip cross-origin
  }
  // Walk all elements and resolve var() in inline styles and attributes
  const allEls = svgEl.querySelectorAll('*');
  const attrNames = ['fill', 'stroke', 'color', 'stop-color', 'flood-color'];
  const varRe = /var\((--[a-zA-Z0-9_-]+)\)/g;
  function resolveVal(val) {
    if (!val || !val.includes('var(')) return val;
    return val.replace(varRe, (_, name) => varMap[name] || computed.getPropertyValue(name).trim() || '');
  }
  allEls.forEach(el => {
    attrNames.forEach(attr => {
      const v = el.getAttribute(attr);
      if (v && v.includes('var(')) el.setAttribute(attr, resolveVal(v));
    });
    if (el.style) {
      for (let i = 0; i < el.style.length; i++) {
        const prop = el.style[i];
        const val = el.style.getPropertyValue(prop);
        if (val && val.includes('var(')) el.style.setProperty(prop, resolveVal(val));
      }
    }
  });
  // Also resolve calc() with var() in font-size by computing actual px
  svgEl.querySelectorAll('text').forEach(textEl => {
    const fs = textEl.getAttribute('font-size') || '';
    if (fs.includes('var(') || fs.includes('calc(')) {
      // Get the actual computed font size from the original DOM element
      const origId = textEl.getAttribute('data-orig-id');
      // Fallback: just strip calc and use a reasonable default
      const cleaned = resolveVal(fs).replace(/calc\(([^)]+)\)/g, (_, expr) => {
        // Simple eval for "Npx * M" patterns
        const m = expr.match(/([\d.]+)px\s*\*\s*([\d.]+)/);
        return m ? (parseFloat(m[1]) * parseFloat(m[2])) + 'px' : expr;
      });
      textEl.setAttribute('font-size', cleaned);
    }
  });
}

document.getElementById('expPng').addEventListener('click', () => {
  const svg = document.getElementById('mapSvg');
  const root = svg.querySelector('#mapRoot');
  if (!root) return;
  const bbox = root.getBBox();
  const pad = 40;
  const cloneSvg = svg.cloneNode(true);
  cloneSvg.setAttribute('width', bbox.width + pad * 2);
  cloneSvg.setAttribute('height', bbox.height + pad * 2);
  cloneSvg.querySelector('#mapRoot').setAttribute('transform', `translate(${-bbox.x + pad},${-bbox.y + pad})`);

  // Resolve CSS variables for standalone SVG
  resolveCssVars(cloneSvg);

  const serializer = new XMLSerializer();
  const svgStr = serializer.serializeToString(cloneSvg);
  const canvas = document.createElement('canvas');
  const scale = 2;
  canvas.width = (bbox.width + pad * 2) * scale;
  canvas.height = (bbox.height + pad * 2) * scale;
  const ctx = canvas.getContext('2d');
  ctx.scale(scale, scale);
  ctx.fillStyle = '#0a0e17';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const img = new Image();
  img.onload = () => {
    ctx.drawImage(img, 0, 0);
    const a = document.createElement('a');
    a.download = 'azure-network-map.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
  };
  img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgStr)));
});

// ---- Save / Load Project ----
let _currentFilePath = null;

function getProjectData() {
  const data = {};
  INPUT_SECTIONS.forEach(sec => {
    sec.inputs.forEach(inp => { data[inp.id] = gv(inp.id) });
  });
  return JSON.stringify({ version: 1, type: 'azuremap', timestamp: new Date().toISOString(), data }, null, 2);
}

function loadProjectData(json) {
  try {
    const proj = typeof json === 'string' ? JSON.parse(json) : json;
    if (proj.data) {
      for (const [id, value] of Object.entries(proj.data)) {
        const el = document.getElementById(id);
        if (el) {
          el.value = value;
          if (value.trim()) { try { JSON.parse(value); el.className = 'ji valid' } catch(e) { el.className = 'ji invalid' } }
          else { el.className = 'ji' }
        }
      }
      renderMap();
    }
  } catch(e) { console.error('Failed to load project:', e) }
}

// Save button
document.getElementById('saveProjectBtn').addEventListener('click', async () => {
  if (_isElectron && window.electronAPI) {
    if (_currentFilePath) {
      await window.electronAPI.saveFile(_currentFilePath, getProjectData());
    } else {
      const result = await window.electronAPI.saveAs();
      if (!result.canceled && result.filePath) {
        _currentFilePath = result.filePath;
        await window.electronAPI.saveFile(_currentFilePath, getProjectData());
      }
    }
  } else {
    const blob = new Blob([getProjectData()], { type: 'application/json' });
    const a = document.createElement('a');
    a.download = 'network-map.azuremap';
    a.href = URL.createObjectURL(blob);
    a.click();
    URL.revokeObjectURL(a.href);
  }
});

// Open button
document.getElementById('loadProjectBtn').addEventListener('click', () => {
  document.getElementById('loadProjectInput').click();
});
document.getElementById('loadProjectInput').addEventListener('change', function() {
  if (this.files.length > 0) {
    const reader = new FileReader();
    reader.onload = e => loadProjectData(e.target.result);
    reader.readAsText(this.files[0]);
  }
});

// Auto-save to localStorage every 30s
setInterval(() => {
  try { localStorage.setItem('azureNetMap_autosave', getProjectData()) } catch(e) {}
}, 30000);

// Restore auto-save on load
(function restoreAutosave() {
  try {
    const saved = localStorage.getItem('azureNetMap_autosave');
    if (saved) {
      const proj = JSON.parse(saved);
      if (proj.data) {
        let hasData = false;
        for (const [id, value] of Object.entries(proj.data)) {
          if (value && value.trim()) { hasData = true; break }
        }
        if (hasData) {
          for (const [id, value] of Object.entries(proj.data)) {
            const el = document.getElementById(id);
            if (el && value) {
              el.value = value;
              if (value.trim()) { try { JSON.parse(value); el.className = 'ji valid' } catch(e) { el.className = 'ji invalid' } }
            }
          }
        }
      }
    }
  } catch(e) {}
})();

// ---- Keyboard shortcuts ----
document.addEventListener('keydown', e => {
  // Don't handle if typing in an input
  if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

  if (e.key === '/') { e.preventDefault(); openSearch() }
  else if (e.key === 'Escape') {
    closeSearch();
    closeDetailPanel();
  }
  else if (e.key === '+' || e.key === '=') { document.getElementById('zoomIn').click() }
  else if (e.key === '-') { document.getElementById('zoomOut').click() }
  else if (e.key === 's' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); document.getElementById('saveProjectBtn').click() }
  else if (e.key === 'T' && e.shiftKey) { e.preventDefault(); if (document.getElementById('layoutMode').value !== 'executive') openFlowForm() }
  else if (e.key === 'C' && e.shiftKey) { e.preventDefault(); openComplianceDashboard() }
});

// ---- Button handlers ----
document.getElementById('renderBtn').addEventListener('click', renderMap);
document.getElementById('loadDemo').addEventListener('click', generateDemo);
document.getElementById('clearBtn').addEventListener('click', () => {
  document.querySelectorAll('.ji').forEach(el => { el.value = ''; el.className = 'ji' });
  d3.select('#mapSvg').selectAll('*').remove();
  document.getElementById('emptyState').style.display = 'flex';
  document.getElementById('emptyTitle').textContent = 'No data loaded';
  document.getElementById('emptyDesc').textContent = 'Paste Azure CLI JSON exports and click Render Map';
  document.getElementById('statsBar').style.display = 'none';
  document.getElementById('legend').style.display = 'none';
  document.getElementById('exportBar').style.display = 'none';
  closeDetailPanel();
});

// ---- Electron integration ----
if (_isElectron && window.electronAPI) {
  document.getElementById('scanAzureBtn').style.display = 'flex';

  // Menu handlers
  window.electronAPI.onMenuSave(() => document.getElementById('saveProjectBtn').click());
  window.electronAPI.onMenuSaveAs(filePath => {
    if (filePath) { _currentFilePath = filePath; window.electronAPI.saveFile(filePath, getProjectData()) }
  });
  window.electronAPI.onMenuScanAzure(() => {
    document.getElementById('scanModal').style.display = 'flex';
  });
  window.electronAPI.onProjectLoad(({ data, filePath }) => {
    _currentFilePath = filePath;
    loadProjectData(data);
  });

  // Update notification — shows a persistent banner with download link
  if (window.electronAPI.onUpdateAvailable) {
    window.electronAPI.onUpdateAvailable(({ version }) => {
      const banner = document.getElementById('updateBanner');
      document.getElementById('updateMsg').textContent = 'Azure Network Mapper v' + version + ' is available';
      document.getElementById('updateLink').href = 'https://github.com/schylerchase/Azure-Mapper/releases/tag/v' + version;
      banner.classList.add('visible');
    });
  }

  // Scan modal
  document.getElementById('scanAzureBtn').addEventListener('click', () => {
    document.getElementById('scanModal').style.display = 'flex';
  });
  document.getElementById('scanCancel').addEventListener('click', () => {
    document.getElementById('scanModal').style.display = 'none';
  });
  document.getElementById('scanStart').addEventListener('click', async () => {
    const subscription = document.getElementById('scanSubscription').value.trim();
    if (!subscription) { alert('Subscription is required'); return }
    const resourceGroup = document.getElementById('scanResourceGroup').value.trim();

    document.getElementById('scanForm').style.display = 'none';
    document.getElementById('scanProgress').style.display = 'block';
    const log = document.getElementById('scanLog');
    log.textContent = 'Starting scan...\n';

    window.electronAPI.onScanProgress(msg => { log.textContent += msg; log.scrollTop = log.scrollHeight });

    const result = await window.electronAPI.scanAzure({ subscription, resourceGroup: resourceGroup || undefined });
    if (result.success && result.outputDir) {
      log.textContent += '\nScan complete. Loading data...\n';
      // The main process would import the folder
    } else {
      log.textContent += '\nScan failed: ' + (result.error || 'Unknown error') + '\n';
    }
  });
}

// ---- Layout mode change triggers re-render ----
document.getElementById('layoutMode').addEventListener('change', () => {
  // Toggle Flow button visibility — executive mode is for reporting, no tracing
  const mode = document.getElementById('layoutMode').value;
  const flowBtn = document.getElementById('flowBtn');
  if (flowBtn) flowBtn.style.display = mode === 'executive' ? 'none' : 'flex';
  if (_lk.vnets && _lk.vnets.length > 0) renderMap();
});

// ---- Apply initial text scale ----
applyGlobalTxtScale();

// ---- iOS gesture conflict fix: prevent pinch-zoom on map container (browser only) ----
if (!_isElectron) {
  (function() {
    const mapSvg = document.getElementById('mapSvg');
    if (mapSvg) {
      mapSvg.addEventListener('gesturestart', function(e) { e.preventDefault(); }, { passive: false });
      mapSvg.addEventListener('gesturechange', function(e) { e.preventDefault(); }, { passive: false });
      mapSvg.addEventListener('gestureend', function(e) { e.preventDefault(); }, { passive: false });
    }
  })();
}

// ============================================================
// SELF-TEST SUITE
// ============================================================

function runSelfTests() {
  const results = [];
  let passed = 0;
  let failed = 0;

  function assert(name, condition, detail) {
    if (condition) { results.push({ name, pass: true }); passed++; }
    else { results.push({ name, pass: false, detail: detail || '' }); failed++; }
  }

  // ============================================================
  // safeParse — JSON parsing robustness
  // ============================================================
  assert('safeParse: valid array', JSON.stringify(safeParse('[1,2,3]')) === '[1,2,3]');
  assert('safeParse: valid object wraps in array', safeParse('{"a":1}').length === 1);
  assert('safeParse: empty string returns []', safeParse('').length === 0);
  assert('safeParse: null returns []', safeParse(null).length === 0);
  assert('safeParse: undefined returns []', safeParse(undefined).length === 0);
  assert('safeParse: invalid JSON returns []', safeParse('not json').length === 0);
  assert('safeParse: whitespace-only returns []', safeParse('   \n\t  ').length === 0);
  assert('safeParse: nested array stays flat', safeParse('[[1],[2]]').length === 2);
  assert('safeParse: multi-object concatenation', safeParse('{"a":1}{"b":2}').length === 2, 'got: ' + safeParse('{"a":1}{"b":2}').length);
  assert('safeParse: object + array concatenation', safeParse('{"a":1}[2,3]').length === 3, 'got: ' + safeParse('{"a":1}[2,3]').length);
  assert('safeParse: JSON with leading whitespace', safeParse('  [1]  ').length === 1);
  assert('safeParse: empty array returns []', safeParse('[]').length === 0);
  assert('safeParse: empty object wraps in array', safeParse('{}').length === 1);
  assert('safeParse: string with quotes inside', safeParse('[{"name":"O\'Brien"}]').length === 1);
  assert('safeParse: number input', safeParse(42).length === 0, 'number should fail (no .trim)');

  // ============================================================
  // parseResourceId — Azure resource ID parsing
  // ============================================================
  const rid = parseResourceId('/subscriptions/abc-123/resourceGroups/rg-test/providers/Microsoft.Network/virtualNetworks/vnet-1');
  assert('parseResourceId: subscriptionId', rid && rid.subscriptionId === 'abc-123');
  assert('parseResourceId: resourceGroup', rid && rid.resourceGroup === 'rg-test');
  assert('parseResourceId: provider', rid && rid.provider === 'Microsoft.Network/virtualNetworks');
  assert('parseResourceId: resourceName', rid && rid.resourceName === 'vnet-1');
  assert('parseResourceId: null for empty', parseResourceId('') === null);
  assert('parseResourceId: null for null', parseResourceId(null) === null);
  assert('parseResourceId: null for undefined', parseResourceId(undefined) === null);
  assert('parseResourceId: null for garbage', parseResourceId('foobar') === null);
  assert('parseResourceId: null for short path', parseResourceId('/subscriptions/abc') === null);

  // Subnet child resource
  const subRid = parseResourceId('/subscriptions/abc-123/resourceGroups/rg-test/providers/Microsoft.Network/virtualNetworks/vnet-1/subnets/snet-web');
  assert('parseResourceId: child subnet type', subRid && subRid.childType === 'subnets');
  assert('parseResourceId: child subnet name', subRid && subRid.childName === 'snet-web');

  // Case sensitivity preservation
  const caseRid = parseResourceId('/subscriptions/ABC-123/resourceGroups/RG-Test/providers/Microsoft.Network/virtualNetworks/VNet-1');
  assert('parseResourceId: preserves case in subscription', caseRid && caseRid.subscriptionId === 'ABC-123');
  assert('parseResourceId: preserves case in RG', caseRid && caseRid.resourceGroup === 'RG-Test');

  // ============================================================
  // esc — XSS prevention
  // ============================================================
  assert('esc: escapes <', esc('<script>') === '&lt;script&gt;');
  assert('esc: escapes >', esc('a>b') === 'a&gt;b');
  assert('esc: escapes single quote', esc("O'Brien") === 'O&#39;Brien');
  assert('esc: escapes &', esc('A&B') === 'A&amp;B');
  assert('esc: escapes double quote', esc('He said "hi"').includes('&quot;'));
  assert('esc: handles empty string', esc('') === '');
  assert('esc: handles number', typeof esc(42) === 'string');
  assert('esc: handles null gracefully', typeof esc(null) === 'string');
  assert('esc: multi-attack vector', esc('<img onerror="alert(1)" src=x>').includes('&lt;'));
  assert('esc: single-quote in onclick context', !esc("';alert(1);//").includes("'"), 'single quotes must be escaped for onclick safety');
  assert('esc: backtick preserved or escaped', esc('`test`').length > 0); // backticks not dangerous in HTML context
  assert('esc: escapes backslash', esc('test\\x27') === 'test&#92;x27');

  // ============================================================
  // parseCIDR — CIDR notation parsing
  // ============================================================
  const cidr24 = parseCIDR('10.0.0.0/24');
  assert('parseCIDR: /24 size is 256', cidr24 && cidr24.size === 256);
  assert('parseCIDR: /24 network correct', cidr24 && cidr24.network === ((10 << 24) >>> 0));
  assert('parseCIDR: /24 prefix', cidr24 && cidr24.prefix === 24);

  const cidr32 = parseCIDR('192.168.1.1/32');
  assert('parseCIDR: /32 single host size', cidr32 && cidr32.size === 1);
  assert('parseCIDR: /32 network equals IP', cidr32 && cidr32.network === cidr32.ip);

  const cidr0 = parseCIDR('0.0.0.0/0');
  assert('parseCIDR: /0 size is 2^32', cidr0 && cidr0.size === 4294967296);
  assert('parseCIDR: /0 network is 0', cidr0 && cidr0.network === 0);

  const cidr16 = parseCIDR('10.1.0.0/16');
  assert('parseCIDR: /16 size is 65536', cidr16 && cidr16.size === 65536);

  const cidr31 = parseCIDR('10.0.0.0/31');
  assert('parseCIDR: /31 size is 2', cidr31 && cidr31.size === 2);

  // Invalid inputs
  assert('parseCIDR: null for empty', parseCIDR('') === null);
  assert('parseCIDR: null for null', parseCIDR(null) === null);
  assert('parseCIDR: null for non-string', parseCIDR(42) === null);
  assert('parseCIDR: null for invalid format', parseCIDR('not-cidr') === null);
  assert('parseCIDR: null for missing prefix', parseCIDR('10.0.0.0') === null);
  assert('parseCIDR: null for prefix > 32', parseCIDR('10.0.0.0/33') === null);
  assert('parseCIDR: null for negative prefix', parseCIDR('10.0.0.0/-1') === null);
  assert('parseCIDR: null for octet > 255', parseCIDR('256.0.0.0/24') === null);
  assert('parseCIDR: null for IP with spaces', parseCIDR(' 10.0.0.0/24') === null);
  assert('parseCIDR: null for partial IP', parseCIDR('10.0.0/24') === null);

  // ============================================================
  // ipInCIDR — IP address containment
  // ============================================================
  assert('ipInCIDR: first IP in /24', ipInCIDR('10.0.0.0', '10.0.0.0/24') === true);
  assert('ipInCIDR: last IP in /24', ipInCIDR('10.0.0.255', '10.0.0.0/24') === true);
  assert('ipInCIDR: mid IP in /24', ipInCIDR('10.0.0.128', '10.0.0.0/24') === true);
  assert('ipInCIDR: just outside /24 (next subnet)', ipInCIDR('10.0.1.0', '10.0.0.0/24') === false);
  assert('ipInCIDR: before subnet', ipInCIDR('9.255.255.255', '10.0.0.0/24') === false);
  assert('ipInCIDR: /32 exact match', ipInCIDR('192.168.1.1', '192.168.1.1/32') === true);
  assert('ipInCIDR: /32 non-match', ipInCIDR('192.168.1.2', '192.168.1.1/32') === false);
  assert('ipInCIDR: /0 matches anything', ipInCIDR('8.8.8.8', '0.0.0.0/0') === true);
  assert('ipInCIDR: /0 matches private', ipInCIDR('192.168.0.1', '0.0.0.0/0') === true);
  assert('ipInCIDR: /16 boundary first', ipInCIDR('10.1.0.0', '10.1.0.0/16') === true);
  assert('ipInCIDR: /16 boundary last', ipInCIDR('10.1.255.255', '10.1.0.0/16') === true);
  assert('ipInCIDR: /16 boundary outside', ipInCIDR('10.2.0.0', '10.1.0.0/16') === false);
  // Edge: null/empty
  assert('ipInCIDR: null IP returns false', ipInCIDR(null, '10.0.0.0/24') === false);
  assert('ipInCIDR: empty IP returns false', ipInCIDR('', '10.0.0.0/24') === false);
  assert('ipInCIDR: null CIDR returns false', ipInCIDR('10.0.0.1', null) === false);
  assert('ipInCIDR: invalid CIDR returns false', ipInCIDR('10.0.0.1', 'garbage') === false);
  assert('ipInCIDR: malformed IP does not crash', typeof ipInCIDR('not-an-ip', '10.0.0.0/24') === 'boolean');

  // ============================================================
  // cidrContains — supernet/subnet relationship
  // ============================================================
  assert('cidrContains: /16 contains /24', cidrContains('10.0.0.0/16', '10.0.1.0/24') === true);
  assert('cidrContains: /24 does NOT contain /16', cidrContains('10.0.1.0/24', '10.0.0.0/16') === false);
  assert('cidrContains: identical CIDRs', cidrContains('10.0.0.0/24', '10.0.0.0/24') === true);
  assert('cidrContains: /0 contains everything', cidrContains('0.0.0.0/0', '192.168.1.0/24') === true);
  assert('cidrContains: non-overlapping', cidrContains('10.0.0.0/24', '10.0.1.0/24') === false);
  assert('cidrContains: null parent', cidrContains(null, '10.0.0.0/24') === false);
  assert('cidrContains: null child', cidrContains('10.0.0.0/24', null) === false);

  // ============================================================
  // shortName — resource name extraction
  // ============================================================
  assert('shortName: extracts last path segment', shortName('/a/b/c/name-1') === 'name-1');
  assert('shortName: handles object with name', shortName({ name: 'test' }) === 'test');
  assert('shortName: handles object with id only', shortName({ id: '/sub/rg/prov/type/myres' }) === 'myres');
  assert('shortName: returns ? for null', shortName(null) === '?');
  assert('shortName: returns ? for undefined', shortName(undefined) === '?');
  assert('shortName: returns string for plain string', shortName('hello') === 'hello');
  assert('shortName: empty string returns empty', shortName('') === '?');
  assert('shortName: single segment path (no slash)', shortName('solo') === 'solo');
  assert('shortName: deep path', shortName('/a/b/c/d/e/f/g/last') === 'last');
  assert('shortName: trailing slash edge', shortName('/a/b/') === '');
  assert('shortName: object with name=null uses id', shortName({ name: null, id: '/a/b/fallback' }) === 'fallback');

  // ============================================================
  // portMatches — NSG port matching
  // ============================================================
  assert('portMatches: wildcard matches any port', portMatches('443', '*', []) === true);
  assert('portMatches: exact match', portMatches('443', '443', []) === true);
  assert('portMatches: exact non-match', portMatches('443', '80', []) === false);
  assert('portMatches: range inclusive low', portMatches('80', '80-443', []) === true);
  assert('portMatches: range inclusive high', portMatches('443', '80-443', []) === true);
  assert('portMatches: range mid', portMatches('200', '80-443', []) === true);
  assert('portMatches: range outside below', portMatches('79', '80-443', []) === false);
  assert('portMatches: range outside above', portMatches('444', '80-443', []) === false);
  assert('portMatches: from ranges array', portMatches('8080', '22', ['80', '8080-8090']) === true);
  assert('portMatches: ranges array no match', portMatches('9999', '22', ['80', '8080-8090']) === false);
  assert('portMatches: port 0', portMatches('0', '0', []) === true);
  assert('portMatches: port 65535', portMatches('65535', '0-65535', []) === true);
  assert('portMatches: NaN port does not crash', typeof portMatches('abc', '443', []) === 'boolean');
  assert('portMatches: empty range string', portMatches('443', '', []) === false);
  assert('portMatches: wildcard in ranges array', portMatches('443', '22', ['*']) === true);

  // ============================================================
  // addressMatches — NSG address matching
  // ============================================================
  assert('addressMatches: wildcard * matches', addressMatches('10.0.0.1', '*', []) === true);
  assert('addressMatches: Internet tag', addressMatches('10.0.0.1', 'Internet', []) === true);
  assert('addressMatches: 0.0.0.0/0', addressMatches('10.0.0.1', '0.0.0.0/0', []) === true);
  assert('addressMatches: VirtualNetwork tag', addressMatches('10.0.0.1', 'VirtualNetwork', []) === true);
  assert('addressMatches: AzureLoadBalancer returns false', addressMatches('10.0.0.1', 'AzureLoadBalancer', []) === false);
  assert('addressMatches: CIDR match', addressMatches('10.0.0.50', '10.0.0.0/24', []) === true);
  assert('addressMatches: CIDR no match', addressMatches('10.0.1.50', '10.0.0.0/24', []) === false);
  assert('addressMatches: exact IP match', addressMatches('10.0.0.1', '10.0.0.1', []) === true);
  assert('addressMatches: exact IP no match', addressMatches('10.0.0.1', '10.0.0.2', []) === false);
  assert('addressMatches: match via prefixes array', addressMatches('10.0.0.1', 'AzureLoadBalancer', ['10.0.0.0/24']) === true);
  assert('addressMatches: no match prefix or array', addressMatches('10.0.0.1', '192.168.0.0/16', ['172.16.0.0/12']) === false);
  assert('addressMatches: Internet in prefixes array', addressMatches('10.0.0.1', 'AzureLoadBalancer', ['Internet']) === true);
  assert('addressMatches: multiple prefixes, one matches', addressMatches('10.0.0.1', 'none', ['192.168.0.0/16', '10.0.0.0/8']) === true);

  // ============================================================
  // matchNsgRule — priority-based rule matching
  // ============================================================
  const testRules = [
    { name: 'DenyAll', priority: 4000, direction: 'Inbound', access: 'Deny', protocol: '*', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '*' },
    { name: 'AllowHTTPS', priority: 100, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRange: '443' },
    { name: 'AllowSSH', priority: 200, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '10.0.0.0/8', destinationAddressPrefix: '*', destinationPortRange: '22' },
  ];

  let m = matchNsgRule(testRules, '1.2.3.4', '10.0.0.5', '443', 'Tcp');
  assert('matchNsgRule: HTTPS allowed (priority 100 before DenyAll 4000)', m && m.access === 'allow' && m.rule.name === 'AllowHTTPS');

  m = matchNsgRule(testRules, '1.2.3.4', '10.0.0.5', '80', 'Tcp');
  assert('matchNsgRule: HTTP denied (no allow, hits DenyAll)', m && m.access === 'deny' && m.rule.name === 'DenyAll');

  m = matchNsgRule(testRules, '10.0.0.1', '10.0.0.5', '22', 'Tcp');
  assert('matchNsgRule: SSH from 10.x allowed', m && m.access === 'allow' && m.rule.name === 'AllowSSH');

  m = matchNsgRule(testRules, '1.2.3.4', '10.0.0.5', '22', 'Tcp');
  assert('matchNsgRule: SSH from external denied (10.x only, hits DenyAll)', m && m.access === 'deny');

  m = matchNsgRule(testRules, '1.2.3.4', '10.0.0.5', '443', 'Udp');
  assert('matchNsgRule: HTTPS on UDP denied (rule is Tcp only)', m && m.access === 'deny', 'AllowHTTPS is Tcp, DenyAll is * so UDP hits DenyAll');

  m = matchNsgRule([], '1.2.3.4', '10.0.0.5', '443', 'Tcp');
  assert('matchNsgRule: empty rules returns null', m === null);

  // Rule with destinationPortRanges (array)
  const rangeRules = [
    { name: 'AllowWeb', priority: 100, direction: 'Inbound', access: 'Allow', protocol: 'Tcp', sourceAddressPrefix: '*', destinationAddressPrefix: '*', destinationPortRanges: ['80', '443', '8080-8090'] },
  ];
  m = matchNsgRule(rangeRules, '1.2.3.4', '10.0.0.5', '8085', 'Tcp');
  assert('matchNsgRule: port range in destinationPortRanges', m && m.access === 'allow');
  m = matchNsgRule(rangeRules, '1.2.3.4', '10.0.0.5', '9999', 'Tcp');
  assert('matchNsgRule: port not in range returns null', m === null);

  // ============================================================
  // generateDemo — demo data integrity
  // ============================================================
  try {
    generateDemo();
    assert('generateDemo: runs without error', true);
    assert('generateDemo: populates vnets', safeParse(gv('in_vnets')).length > 0);
    assert('generateDemo: populates nsgs', safeParse(gv('in_nsgs')).length > 0);
    assert('generateDemo: populates vms', safeParse(gv('in_vms')).length > 0);
    assert('generateDemo: populates peerings', safeParse(gv('in_peerings')).length > 0);
    assert('generateDemo: populates nics', safeParse(gv('in_nics')).length > 0);
    assert('generateDemo: populates firewalls', safeParse(gv('in_firewalls')).length > 0);
    assert('generateDemo: populates bastions', safeParse(gv('in_bastions')).length > 0);
    assert('generateDemo: populates storage', safeParse(gv('in_storage')).length > 0);
    assert('generateDemo: populates resource groups', safeParse(gv('in_rgs')).length > 0);
    assert('generateDemo: 4 VNets (hub + 3 spokes)', safeParse(gv('in_vnets')).length === 4);
    assert('generateDemo: 6 peerings (3 pairs)', safeParse(gv('in_peerings')).length === 6);
  } catch(e) {
    assert('generateDemo: runs without error', false, e.message);
  }

  // ============================================================
  // buildLookups — relationship map building
  // ============================================================
  function makeTestData() {
    return {
      vnets: safeParse(gv('in_vnets')),
      nsgs: safeParse(gv('in_nsgs')),
      routeTables: safeParse(gv('in_rts')),
      nics: safeParse(gv('in_nics')),
      publicIps: safeParse(gv('in_pips')),
      natGateways: safeParse(gv('in_natgws')),
      privateEndpoints: safeParse(gv('in_pes')),
      asgs: [], vms: safeParse(gv('in_vms')),
      functionApps: safeParse(gv('in_funcs')),
      containerInstances: [], aksClusters: [],
      appGateways: safeParse(gv('in_appgws')),
      loadBalancers: safeParse(gv('in_lbs')),
      peerings: safeParse(gv('in_peerings')),
      vpnConnections: [], vwans: [], vhubs: [], hubConnections: [],
      disks: safeParse(gv('in_disks')), snapshots: [],
      storageAccounts: safeParse(gv('in_storage')),
      dnsZones: [], privateDnsZones: [], dnsRecords: [],
      frontDoors: [], wafPolicies: [],
      sqlServers: safeParse(gv('in_sqlservers')),
      sqlDatabases: safeParse(gv('in_sqldbs')),
      redisCaches: safeParse(gv('in_redis')),
      synapseWorkspaces: [],
      roleAssignments: [], roleDefinitions: [], servicePrincipals: [],
      resourceGroups: safeParse(gv('in_rgs')),
      bastions: safeParse(gv('in_bastions')),
      networkWatchers: [],
      firewalls: safeParse(gv('in_firewalls')),
    };
  }

  try {
    const lk = buildLookups(makeTestData());
    assert('buildLookups: vnets populated', lk.vnets.length > 0);
    assert('buildLookups: subnets populated', lk.subnets.length > 0);
    assert('buildLookups: subnetsByVnet has entries', Object.keys(lk.subnetsByVnet).length > 0);
    assert('buildLookups: vmsBySubnet has entries', Object.keys(lk.vmsBySubnet).length > 0);
    assert('buildLookups: nsgBySubnet has entries', Object.keys(lk.nsgBySubnet).length > 0);
    assert('buildLookups: publicIpById has entries', Object.keys(lk.publicIpById).length > 0);
    assert('buildLookups: peeringsByVnet has entries', Object.keys(lk.peeringsByVnet).length > 0);
    assert('buildLookups: subnetById has entries', Object.keys(lk.subnetById).length > 0);
    assert('buildLookups: vnetById has entries', Object.keys(lk.vnetById).length > 0);
    assert('buildLookups: rtBySubnet has entries for prod', Object.keys(lk.rtBySubnet).length > 0);
    assert('buildLookups: natBySubnet has entry for web subnet',
      Object.values(lk.natBySubnet).some(v => v !== undefined));
    assert('buildLookups: nicsBySubnet has entries', Object.keys(lk.nicsBySubnet).length > 0);
    assert('buildLookups: funcBySubnet has entries', Object.keys(lk.funcBySubnet).length > 0);
    assert('buildLookups: lbBySubnet has entries', Object.keys(lk.lbBySubnet).length > 0);
    assert('buildLookups: disksByVm has entries', Object.keys(lk.disksByVm).length > 0);

    // Verify case-insensitive lookups
    const firstSubnet = lk.subnets[0];
    if (firstSubnet && firstSubnet.id) {
      const lcId = firstSubnet.id.toLowerCase();
      assert('buildLookups: subnetById uses lowercase keys', lk.subnetById[lcId] !== undefined);
    }
  } catch(e) {
    assert('buildLookups: no errors', false, e.message);
  }

  // buildLookups with completely empty data
  try {
    const emptyData = {
      vnets: [], nsgs: [], routeTables: [], nics: [], publicIps: [],
      natGateways: [], privateEndpoints: [], asgs: [], vms: [],
      functionApps: [], containerInstances: [], aksClusters: [],
      appGateways: [], loadBalancers: [], peerings: [],
      vpnConnections: [], vwans: [], vhubs: [], hubConnections: [],
      disks: [], snapshots: [], storageAccounts: [],
      dnsZones: [], privateDnsZones: [], dnsRecords: [],
      frontDoors: [], wafPolicies: [],
      sqlServers: [], sqlDatabases: [], redisCaches: [],
      synapseWorkspaces: [],
      roleAssignments: [], roleDefinitions: [], servicePrincipals: [],
      resourceGroups: [], bastions: [], networkWatchers: [], firewalls: [],
    };
    const emptyLk = buildLookups(emptyData);
    assert('buildLookups: empty data does not crash', emptyLk !== null);
    assert('buildLookups: empty vnets', emptyLk.vnets.length === 0);
    assert('buildLookups: empty subnetsByVnet', Object.keys(emptyLk.subnetsByVnet).length === 0);
  } catch(e) {
    assert('buildLookups: empty data no errors', false, e.message);
  }

  // ============================================================
  // isSubnetPublic — public subnet detection
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());
    // snet-prod-web has NAT gateway -> public
    const prodWebSub = lk.subnets.find(s => (s.name || '').includes('prod-web'));
    if (prodWebSub) {
      assert('isSubnetPublic: prod-web with NAT is public', isSubnetPublic(prodWebSub.id, lk) === true);
    }
    // snet-prod-data has no NAT, no PIP, no AGW -> private
    const prodDataSub = lk.subnets.find(s => (s.name || '').includes('prod-data'));
    if (prodDataSub) {
      assert('isSubnetPublic: prod-data without NAT/PIP is private', isSubnetPublic(prodDataSub.id, lk) === false);
    }
    // AzureFirewallSubnet - no NAT but firewall has PIP
    const fwSub = lk.subnets.find(s => (s.name || '').toLowerCase() === 'azurefirewallsubnet');
    if (fwSub) {
      // Firewall has PIP but isSubnetPublic checks NIC PIPs, not FW PIPs
      const fwPublic = isSubnetPublic(fwSub.id, lk);
      assert('isSubnetPublic: AzureFirewallSubnet detection runs', typeof fwPublic === 'boolean');
    }
  } catch(e) {
    assert('isSubnetPublic: no errors', false, e.message);
  }

  // ============================================================
  // countSubnetResources — resource counting
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());
    const prodWebSub = lk.subnets.find(s => (s.name || '').includes('prod-web'));
    if (prodWebSub) {
      const count = countSubnetResources(prodWebSub.id, lk);
      assert('countSubnetResources: prod-web has VMs', count >= 2, 'got: ' + count);
    }
    const fwSub = lk.subnets.find(s => (s.name || '').toLowerCase() === 'azurefirewallsubnet');
    if (fwSub) {
      const count = countSubnetResources(fwSub.id, lk);
      assert('countSubnetResources: AzureFirewallSubnet counts firewall', count >= 1, 'got: ' + count);
    }
    const bastionSub = lk.subnets.find(s => (s.name || '').toLowerCase() === 'azurebastionsubnet');
    if (bastionSub) {
      const count = countSubnetResources(bastionSub.id, lk);
      assert('countSubnetResources: AzureBastionSubnet counts bastion', count >= 1, 'got: ' + count);
    }
    // Non-existent subnet returns 0
    assert('countSubnetResources: non-existent subnet returns 0', countSubnetResources('fake-subnet-id', lk) === 0);
  } catch(e) {
    assert('countSubnetResources: no errors', false, e.message);
  }

  // ============================================================
  // Compliance engine — specific rule triggers
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());
    const findings = runComplianceChecks(lk);
    assert('compliance: returns array', Array.isArray(findings));
    assert('compliance: findings have required fields', findings.length === 0 || (findings[0].id && findings[0].severity && findings[0].message && findings[0].remediation));
    assert('compliance: sorted by severity', findings.length < 2 || (['CRITICAL', 'HIGH'].includes(findings[0].severity)));

    // Check specific rules fire on demo data
    const archN1 = findings.filter(f => f.id === 'ARCH-N1');
    assert('compliance: ARCH-N1 fires for subnets without NSG', archN1.length > 0, 'Demo has subnets without NSG (GatewaySubnet excluded, but snet-hub-shared has none)');

    const archN2 = findings.filter(f => f.id === 'ARCH-N2');
    assert('compliance: ARCH-N2 fires for subnets without UDR (FW exists)', archN2.length > 0, 'Demo has firewall but some subnets have no route table');

    // Check that AzureFirewallSubnet and GatewaySubnet are NOT flagged by ARCH-N1
    const fwNsgFindings = archN1.filter(f => (f.resource || '').toLowerCase() === 'azurefirewallsubnet');
    assert('compliance: ARCH-N1 excludes AzureFirewallSubnet', fwNsgFindings.length === 0);
    const gwNsgFindings = archN1.filter(f => (f.resource || '').toLowerCase() === 'gatewaysubnet');
    assert('compliance: ARCH-N1 excludes GatewaySubnet', gwNsgFindings.length === 0);

    // ARCH-S1: stdevdata01 has allowBlobPublicAccess = true -> should fire
    const archS1 = findings.filter(f => f.id === 'ARCH-S1');
    assert('compliance: ARCH-S1 fires for storage with publicBlob=true', archS1.length > 0, 'stdevdata01 has allowBlobPublicAccess: true');
    // But stproddata01 should NOT be in ARCH-S1 (it has publicBlob=false)
    assert('compliance: ARCH-S1 only targets public-access storage', archS1.every(f => f.resource !== 'stproddata01'));

    // ARCH-S2: stdevdata01 has defaultAction='Allow' -> should fire
    const archS2 = findings.filter(f => f.id === 'ARCH-S2');
    assert('compliance: ARCH-S2 fires for storage without network restrictions', archS2.length > 0, 'stdevdata01 has defaultAction: Allow');

    // SOC2-CC6.1: stdevdata01 has TLS1_0 -> should fire
    const soc2 = findings.filter(f => f.id === 'SOC2-CC6.1');
    assert('compliance: SOC2-CC6.1 fires for TLS below 1.2', soc2.length > 0, 'stdevdata01 has TLS1_0');

    // CIS-6.1: nsg-dev-web has RDP from * -> should fire
    const cis61 = findings.filter(f => f.id === 'CIS-6.1');
    assert('compliance: CIS-6.1 fires for RDP from internet', cis61.length > 0, 'nsg-dev-web allows RDP from *');

    // CIS-6.2: nsg-dev-web has SSH from * -> should fire
    const cis62 = findings.filter(f => f.id === 'CIS-6.2');
    assert('compliance: CIS-6.2 fires for SSH from internet', cis62.length > 0, 'nsg-dev-web allows SSH from *');

    // WAF-1: appgw-dev-web has Standard_v2 (no WAF) -> should fire
    const waf1 = findings.filter(f => f.id === 'WAF-1');
    assert('compliance: WAF-1 fires for App Gateway without WAF', waf1.length > 0, 'appgw-dev-web has Standard_v2 SKU');

    // ARCH-F1: demo firewall has no policy
    const archF1 = findings.filter(f => f.id === 'ARCH-F1');
    assert('compliance: ARCH-F1 fires for firewall without policy', archF1.length > 0, 'Demo firewall has no firewallPolicy');
  } catch(e) {
    assert('compliance: no errors', false, e.message);
  }

  // Compliance with empty data
  try {
    const emptyLk = buildLookups({
      vnets: [], nsgs: [], routeTables: [], nics: [], publicIps: [],
      natGateways: [], privateEndpoints: [], asgs: [], vms: [],
      functionApps: [], containerInstances: [], aksClusters: [],
      appGateways: [], loadBalancers: [], peerings: [],
      vpnConnections: [], vwans: [], vhubs: [], hubConnections: [],
      disks: [], snapshots: [], storageAccounts: [],
      dnsZones: [], privateDnsZones: [], dnsRecords: [],
      frontDoors: [], wafPolicies: [],
      sqlServers: [], sqlDatabases: [], redisCaches: [],
      synapseWorkspaces: [],
      roleAssignments: [], roleDefinitions: [], servicePrincipals: [],
      resourceGroups: [], bastions: [], networkWatchers: [], firewalls: [],
    });
    const emptyFindings = runComplianceChecks(emptyLk);
    assert('compliance: empty data returns empty array', emptyFindings.length === 0);
  } catch(e) {
    assert('compliance: empty data no crash', false, e.message);
  }

  // ============================================================
  // Traffic flow — various scenarios
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());

    // Same-subnet flow (prod-web VM to VM)
    const f1 = traceFlow('10.1.1.4', '10.1.1.5', '443', 'Tcp', lk);
    assert('traceFlow: same-subnet returns hops', f1 && f1.hops.length > 0);
    assert('traceFlow: same-subnet has result', f1 && ['allow', 'deny', 'unknown'].includes(f1.result));

    // Cross-VNet flow (prod to hub via peering)
    const f2 = traceFlow('10.1.1.4', '10.0.2.4', '22', 'Tcp', lk);
    assert('traceFlow: cross-VNet returns hops', f2 && f2.hops.length > 0);
    assert('traceFlow: cross-VNet has peering hop', f2 && f2.hops.some(h => h.step === 'Peering'));

    // Unknown source IP (not in any subnet)
    const f3 = traceFlow('192.168.99.1', '10.1.1.4', '443', 'Tcp', lk);
    assert('traceFlow: unknown source IP', f3 && f3.result === 'unknown');
    assert('traceFlow: unknown source has 1 hop', f3 && f3.hops.length === 1);

    // External destination
    const f4 = traceFlow('10.1.1.4', '8.8.8.8', '53', 'Udp', lk);
    assert('traceFlow: external dest returns result', f4 && ['allow', 'deny', 'unknown'].includes(f4.result));
    assert('traceFlow: external dest has Destination hop', f4 && f4.hops.some(h => h.step === 'Destination'));

    // Null/undefined protocol defaults to Tcp
    const f5 = traceFlow('10.1.1.4', '10.1.1.5', '443', null, lk);
    assert('traceFlow: null protocol defaults to Tcp', f5 && f5.hops.length > 0);

    // Port as string
    const f6 = traceFlow('10.1.1.4', '10.1.1.5', 443, 'Tcp', lk);
    assert('traceFlow: numeric port works', f6 && f6.hops.length > 0);
  } catch(e) {
    assert('traceFlow: no errors', false, e.message);
  }

  // ============================================================
  // IaC generators — output validation
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());

    // Terraform
    const tf = generateTerraform(lk);
    assert('terraform: generates output', tf.length > 100);
    assert('terraform: contains provider block', tf.includes('provider "azurerm"'));
    assert('terraform: contains resource_group', tf.includes('azurerm_resource_group'));
    assert('terraform: contains virtual_network', tf.includes('azurerm_virtual_network'));
    assert('terraform: contains nsg', tf.includes('azurerm_network_security_group'));
    assert('terraform: contains subnet', tf.includes('azurerm_subnet'));
    assert('terraform: contains peering', tf.includes('azurerm_virtual_network_peering'));
    assert('terraform: contains public_ip', tf.includes('azurerm_public_ip'));
    assert('terraform: contains route_table', tf.includes('azurerm_route_table'));
    assert('terraform: no next_hop_in_ typo', !tf.includes('next_hop_in_ip_address'));
    assert('terraform: correct next_hop_ip_address', tf.includes('next_hop_ip_address') || !tf.includes('nextHopIpAddress'));

    // ARM
    const arm = generateARM(lk);
    const armJson = JSON.parse(arm);
    assert('arm: generates valid JSON', armJson !== null);
    assert('arm: has $schema', armJson['$schema'] !== undefined);
    assert('arm: has resources array', Array.isArray(armJson.resources));
    assert('arm: has resources', armJson.resources.length > 0);
    assert('arm: contains NSG resource', armJson.resources.some(r => r.type === 'Microsoft.Network/networkSecurityGroups'));
    assert('arm: contains VNet resource', armJson.resources.some(r => r.type === 'Microsoft.Network/virtualNetworks'));
    assert('arm: contains PIP resource', armJson.resources.some(r => r.type === 'Microsoft.Network/publicIPAddresses'));

    // Bicep
    const bicep = generateBicep(lk);
    assert('bicep: generates output', bicep.length > 50);
    assert('bicep: contains resource blocks', bicep.includes('resource'));
    assert('bicep: contains NSG', bicep.includes('networkSecurityGroups'));
    assert('bicep: contains VNet', bicep.includes('virtualNetworks'));
    assert('bicep: contains properties', bicep.includes('properties'));
  } catch(e) {
    assert('iac: no errors', false, e.message);
  }

  // IaC with empty data
  try {
    const emptyLk = buildLookups({
      vnets: [], nsgs: [], routeTables: [], nics: [], publicIps: [],
      natGateways: [], privateEndpoints: [], asgs: [], vms: [],
      functionApps: [], containerInstances: [], aksClusters: [],
      appGateways: [], loadBalancers: [], peerings: [],
      vpnConnections: [], vwans: [], vhubs: [], hubConnections: [],
      disks: [], snapshots: [], storageAccounts: [],
      dnsZones: [], privateDnsZones: [], dnsRecords: [],
      frontDoors: [], wafPolicies: [],
      sqlServers: [], sqlDatabases: [], redisCaches: [],
      synapseWorkspaces: [],
      roleAssignments: [], roleDefinitions: [], servicePrincipals: [],
      resourceGroups: [], bastions: [], networkWatchers: [], firewalls: [],
    });
    const emptyTf = generateTerraform(emptyLk);
    assert('terraform: empty data still generates header', emptyTf.includes('terraform'));
    const emptyArm = generateARM(emptyLk);
    assert('arm: empty data generates valid JSON', JSON.parse(emptyArm) !== null);
    assert('arm: empty data has 0 resources', JSON.parse(emptyArm).resources.length === 0);
    const emptyBicep = generateBicep(emptyLk);
    assert('bicep: empty data generates header', emptyBicep.includes('Generated'));
  } catch(e) {
    assert('iac: empty data no crash', false, e.message);
  }

  // ============================================================
  // Blast radius — dependency calculation
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());

    // NSG removal should impact subnets and VMs
    const nsg = lk.nsgs.find(n => (n.name || '').includes('prod-web'));
    if (nsg) {
      const br = calculateBlastRadius(nsg.id, lk);
      assert('blastRadius: NSG removal has hard deps', br.hard.length > 0, 'NSG protects subnet -> hard dep');
      assert('blastRadius: NSG removal has soft deps (VMs)', br.soft.length > 0, 'VMs in protected subnet');
    }

    // VNet removal should list subnets and peerings
    const vnet = lk.vnets.find(v => (v.name || '').includes('spoke-prod'));
    if (vnet) {
      const br = calculateBlastRadius(vnet.id, lk);
      assert('blastRadius: VNet removal lists subnets', br.hard.some(d => d.type === 'Subnet'));
      assert('blastRadius: VNet removal lists peerings', br.soft.some(d => d.type === 'Peering'));
    }

    // Non-existent resource
    const brNone = calculateBlastRadius('/subscriptions/fake/resourceGroups/fake/providers/fake/type/fake-name', lk);
    assert('blastRadius: unknown resource returns empty deps', brNone.hard.length === 0 && brNone.soft.length === 0);

    // Null resource
    const brNull = calculateBlastRadius(null, lk);
    assert('blastRadius: null resource returns empty deps', brNull.hard.length === 0);

    // Subnet removal
    const prodWebSub = lk.subnets.find(s => (s.name || '').includes('prod-web'));
    if (prodWebSub) {
      const br = calculateBlastRadius(prodWebSub.id, lk);
      assert('blastRadius: subnet removal lists VMs', br.hard.some(d => d.type === 'VM'));
    }
  } catch(e) {
    assert('blastRadius: no errors', false, e.message);
  }

  // ============================================================
  // findSubnetByIp / findVnetForSubnet — helper lookup functions
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());

    // Known IP in prod-web subnet
    const sub1 = findSubnetByIp('10.1.1.4', lk);
    assert('findSubnetByIp: finds subnet for known IP', sub1 !== null);
    assert('findSubnetByIp: correct subnet found', sub1 && (sub1.name || '').includes('web'));

    // Unknown IP
    const sub2 = findSubnetByIp('192.168.99.1', lk);
    assert('findSubnetByIp: null for unknown IP', sub2 === null);

    // Null IP
    const sub3 = findSubnetByIp(null, lk);
    assert('findSubnetByIp: null for null IP', sub3 === null);

    // findVnetForSubnet
    if (sub1) {
      const vnet = findVnetForSubnet(sub1.id, lk);
      assert('findVnetForSubnet: finds parent VNet', vnet !== null);
      assert('findVnetForSubnet: correct VNet', vnet && (vnet.name || '').includes('prod'));
    }

    const vnet2 = findVnetForSubnet('fake-subnet-id', lk);
    assert('findVnetForSubnet: null for unknown subnet', vnet2 === null);
  } catch(e) {
    assert('findSubnetByIp: no errors', false, e.message);
  }

  // ============================================================
  // buildSearchIndex — search indexing
  // ============================================================
  try {
    const lk = buildLookups(makeTestData());
    buildSearchIndex(lk);
    assert('searchIndex: populated', _searchIndex.length > 0);
    assert('searchIndex: has VNets', _searchIndex.some(i => i.type === 'VNet'));
    assert('searchIndex: has Subnets', _searchIndex.some(i => i.type === 'Subnet'));
    assert('searchIndex: has VMs', _searchIndex.some(i => i.type === 'VM'));
    assert('searchIndex: has NSGs', _searchIndex.some(i => i.type === 'NSG'));
    assert('searchIndex: has Firewalls', _searchIndex.some(i => i.type === 'Firewall'));
    assert('searchIndex: has Bastions', _searchIndex.some(i => i.type === 'Bastion'));
    assert('searchIndex: has Route Tables', _searchIndex.some(i => i.type === 'Route Table'));
    assert('searchIndex: has Peerings', _searchIndex.some(i => i.type === 'Peering'));
    assert('searchIndex: has Storage', _searchIndex.some(i => i.type === 'Storage'));
    assert('searchIndex: has SQL Servers', _searchIndex.some(i => i.type === 'SQL Server'));
    assert('searchIndex: has Redis', _searchIndex.some(i => i.type === 'Redis'));
    assert('searchIndex: has Function Apps', _searchIndex.some(i => i.type === 'Function App'));
    assert('searchIndex: has Resource Groups', _searchIndex.some(i => i.type === 'Resource Group'));
    // Every entry has required fields
    const allValid = _searchIndex.every(i => i.type && (i.name || i.id));
    assert('searchIndex: all entries have type and name/id', allValid);
  } catch(e) {
    assert('searchIndex: no errors', false, e.message);
  }

  // Display results
  let html = '';
  html += `<div style="padding:12px 16px;border-bottom:1px solid var(--border);background:${failed === 0 ? 'rgba(16,185,129,.08)' : 'rgba(239,68,68,.08)'}">`;
  html += `<div style="font-family:'IBM Plex Mono',monospace;font-size:13px;font-weight:600;color:${failed === 0 ? 'var(--accent-green)' : 'var(--accent-red)'}">${passed} passed, ${failed} failed</div>`;
  html += `</div>`;

  html += `<div class="dp-section"><div class="dp-sec-hdr"><span class="dp-sec-title">Results</span><span class="dp-sec-count">${results.length}</span><span class="dp-sec-arr">&#9660;</span></div><div class="dp-sec-body">`;
  results.forEach(r => {
    html += `<div class="dp-row"><span class="${r.pass ? 'a' : 'd'}">${r.pass ? '&#10003;' : '&#10007;'}</span> <span class="val">${esc(r.name)}</span>`;
    if (r.detail) html += ` <span class="lbl" style="color:var(--accent-red)">${esc(r.detail)}</span>`;
    html += `</div>`;
  });
  html += `</div></div>`;

  openDetailPanel(`Self-Tests: ${failed === 0 ? 'ALL PASSED' : failed + ' FAILED'}`, `${passed}/${results.length} tests passed`, html);

  // Also log to console
  console.log(`Self-tests: ${passed} passed, ${failed} failed`);
  results.filter(r => !r.pass).forEach(r => console.warn(`FAIL: ${r.name}${r.detail ? ' - ' + r.detail : ''}`));
  return { passed, failed, results };
}

// Expose to console: runSelfTests()
window.runSelfTests = runSelfTests;

</script>
</body>
</html>
